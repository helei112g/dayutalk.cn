<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Dockerfile 与 Compose 环境搭建学习笔记（二）]]></title>
      <url>https://helei112g.github.io/2018/06/26/Dockerfile-%E4%B8%8E-Compose-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Dockerfile 的编写是门手艺<br><a id="more"></a></p>
<p>上一篇文章对整体结构进行了简单记录，这一篇介绍下关于Dockerfile自定义镜像以及各个服务的配置。</p>
<blockquote>
<p>其实 <code>https://hub.docker.com/</code> 上面各种基础镜像非常完善，特别是官方的镜像质量非常之高，而我再捣腾一次完全是为了让自己掌握 Dockerfile 方面的技能而已。  </p>
</blockquote>
<p>在选择基础镜像方面，推荐使用 <code>Alpine</code> ，然后再它上面进行定制，因为它非常的小仅3M。我的 Nginx/Redis 是在 <code>Alpine</code> 基础上定制的，<code>PHP</code> 是在 <code>CentOS7</code>上面进行的定制。截图大家可以感受下大小：</p>
<p><img src="&amp;&amp;&amp;SFLOCALFILEPATH&amp;&amp;&amp;FE7C23F8-FC2D-4B9A-8CF3-B22471ABC2E2.png" alt=""></p>
<h1 id="Dockerfile-与-Compose-建立关联"><a href="#Dockerfile-与-Compose-建立关联" class="headerlink" title="Dockerfile 与 Compose 建立关联"></a>Dockerfile 与 Compose 建立关联</h1><p>关于概念可以看这里：<br><a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a></p>
<p>我这里以 PHP/Redis/Nginx 的定制来进行一些说明（我也只是现学现用，希望高手多指教）。</p>
<p>在上篇的 docker-compose.yml 文件中如下的配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dev.nginx.srv:</span><br><span class="line">	image: lei_nginx:<span class="number">1.14</span><span class="number">.0</span></span><br><span class="line">	build: ./nginx</span><br><span class="line">	volumes:</span><br><span class="line">		- ./nginx/conf:/home/work/app/nginx/conf</span><br><span class="line"><span class="bullet">      -</span> ./www:/home/work/www</span><br><span class="line">	ports:</span><br><span class="line">		- <span class="string">"80:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"443:443"</span></span><br><span class="line">	restart: always</span><br></pre></td></tr></table></figure></p>
<p>这里重要的是多了 build 这个选项，设置的对应目录中可以找到 <code>Dockerfile</code> 这个文件，当我们 <code>docker-compose up</code> 时，docker会根据这个文件去先创建镜像，然后启动一个容器。</p>
<h2 id="Dockerfile-如何写"><a href="#Dockerfile-如何写" class="headerlink" title="Dockerfile 如何写"></a>Dockerfile 如何写</h2><p>网络上有非常多关于 <code>Dockerfile</code> 该如何写的最佳实践，我觉得有几点特别重要：</p>
<ul>
<li>一个容器只运行一个进程；</li>
<li>镜像层数尽可能少，当然还需要考虑可读性等方面的因素；</li>
<li>RUN指令应该用 \ 分成多行方便阅读；</li>
<li>容器镜像要尽可能的小。</li>
</ul>
<p>更多最佳实践可以看这里：<br><a href="https://yeasy.gitbooks.io/docker_practice/content/appendix/best_practices.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/appendix/best_practices.html</a></p>
<p>接下来以 Redis 的 Dockerfile 来聊一聊实际如何编写。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释信息</span></span><br><span class="line"><span class="keyword">LABEL</span> maintainer="HeLei &lt;dayugog@gmail.com&gt;"</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> REDIS_VERSION=<span class="number">3.2</span>.<span class="number">11</span> \</span><br><span class="line">    SRC_DIR=/home/work/src \</span><br><span class="line">    DATA_DIR=/home/work/app/redis/data \</span><br><span class="line">    CONF_DIR=/home/work/app/redis/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置系统时区</span></span><br><span class="line"><span class="keyword">RUN</span> ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> src/ $SRC_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译文件</span></span><br><span class="line"><span class="keyword">RUN</span> set -ex; \</span><br><span class="line">    \</span><br><span class="line">    addgroup -S work &amp;&amp; adduser -S -G work work; \</span><br><span class="line">    apk add --no-cache --virtual .build-deps \</span><br><span class="line">            coreutils \</span><br><span class="line">            gcc \</span><br><span class="line">            jemalloc-dev \</span><br><span class="line">            linux-headers \</span><br><span class="line">            make \</span><br><span class="line">            musl-dev \</span><br><span class="line">        ; \</span><br><span class="line">    \</span><br><span class="line">    cd $SRC_DIR; \</span><br><span class="line">    tar xvzf redis-$REDIS_VERSION.tar.gz; \</span><br><span class="line">    cd redis-$REDIS_VERSION; \</span><br><span class="line">    make &amp;&amp; make install; \</span><br><span class="line">    apk del .build-deps; \</span><br><span class="line">    \</span><br><span class="line">    mkdir -p $DATA_DIR &amp;&amp; mkdir -p $CONF_DIR; \</span><br><span class="line">    chown -R work:work /home; \</span><br><span class="line">    rm -rf $SRC_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝配置文件</span></span><br><span class="line"><span class="keyword">COPY</span> conf/ /home/work/app/redis/conf</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> docker-entrypoint.sh /usr/local/bin/</span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["docker-entrypoint.sh"]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"><span class="comment"># 启动redis</span></span><br><span class="line">CMD [<span class="string">"redis-server"</span>]</span><br></pre></td></tr></table></figure></p>
<p>第一行 <strong>FROM</strong> 用来指定基础镜像。也就是你要在什么镜像上进行定制，我这里选择的是 alpine，这是一个提供的基础空白对象非常小。只是它上面的包管理是 <code>apk</code> ，使用时需要掌握下它的一些参数。</p>
<p><strong>LABEL</strong>可以理解成添加一些说明、描述信息。我这里仅添加了自己的联系方式。可以通过反斜线 <code>\</code> 来进行换行。</p>
<p><strong>ENV</strong>用来设置环境变量，例如：定义一些系统版本、路径的环境变量，在后续RUN中可以使用（当然不仅仅是RUN中可用），也可以用改写原有的环境变量，例如：PATH。</p>
<p><strong>RUN</strong>这是一个非常重要的命令，它是用来执行命令行的命令。就像上面看到的用 yum 安装更新软件，make编译代码等。可以通过反斜线 <code>\</code> 来进行换行。</p>
<p><strong>COPY</strong>它是将宿主机的内容复制到容器中指定的路径。</p>
<p><strong>EXPOSE</strong>指令用于指定容器将要监听的端口。一般设置为应用程序使用常见的端口，例如Redis设置为：<code>6379</code></p>
<p>现在重点说下 <strong>CMD</strong> 与 <strong>ENTRYPOINT</strong> 两个命令。如果Dockerfile中没有 <strong>ENTRYPOINT</strong> 选项，<strong>CMD</strong> 的内容就相当于直接执行某个命令。但是当存在时就是另外一回事。以上面的为例：<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span> docker-entrypoint.sh /usr/local/bin/</span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["docker-entrypoint.sh"]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis</span></span><br><span class="line"><span class="keyword">CMD</span> ["redis-server"]</span><br></pre></td></tr></table></figure></p>
<p>这里设置了一个 <strong>ENTRYPOINT</strong> ，像上面这种情况的时候如果直接启动一个容器时，相当于最后应用启动执行的命令是：<code>./docker-entrypoint.sh redis-server</code>。</p>
<p>根据这个特性，<code>docker-entrypoint.sh</code> 内部可以根据相关参数进行特殊处理。来看下我的 <code>docker-entrypoint.sh</code> 脚本内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">cd `dirname $0`</span><br><span class="line"></span><br><span class="line"># 对文件夹进行权限修改</span><br><span class="line">if [ &quot;$1&quot; = &apos;redis-server&apos; -a &quot;$(id -u)&quot; = &apos;0&apos; ]; then</span><br><span class="line">	chown -R work:work /home</span><br><span class="line">  exec redis-server /home/work/app/redis/conf/redis.conf</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure></p>
<p>可以看到如果脚本后面带的参数是<code>redis-server</code>则会先进行相关目录授权，然后启动redis。如果不是就会直接执行，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/dockerEnv &gt;docker run -it --rm redis:3.2.11 redis-cli -v</span><br><span class="line">redis-cli 3.2.11</span><br></pre></td></tr></table></figure></p>
<p>会直接执行后面这个命令，你可以看到redis客户端的版本信息。这也就是表示，可以把镜像当成一个命令来使用了。</p>
<p>有了 <strong>ENTRYPOINT</strong> 这个功能，可以用它在服务启动时，做更多操作 。例如可以结合 docker-compose.yml 中设置的环境变量做更多事情。可以查看官方的MySQL的 <code>docker-entrypoint.sh</code> 文件内容。</p>
<h1 id="依据Dockerfile启动容器"><a href="#依据Dockerfile启动容器" class="headerlink" title="依据Dockerfile启动容器"></a>依据Dockerfile启动容器</h1><p>Dockerfile 已经写好了，通过下面的命令即可创建镜像启动容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/dockerEnv &gt;docker build -t lei_redis:3.2.11 .</span><br></pre></td></tr></table></figure></p>
<p>在 redis/ 目录下执行上面的命令，他会先获取基础镜像，然后根据命令逐条执行，完成redis的编译、安装以及相关清理工作。</p>
<p>编译完成后可用通过<code>docker image ls</code>查看当前的镜像列表数据。</p>
<p>然后通过 <code>docker run -it -p 6379:6379 -d lei_redis:3.2.11</code> 启动一个容器。</p>
<p>启动完成后，大家可以用redis客户端链接查看redis已经正常启动。</p>
<p>当然还有 PHP/Nginx 的镜像定制，以及每个服务的配置，大家可以在github上查看详情，这里就不再赘述了，剩下再介绍下这个过程中遇的到的几个错误。</p>
<h1 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h1><ol>
<li><strong>在宿主机中无法连接Redis</strong><br>这是由于bind的问题。以前在 vagrant 中安装redis也遇到过， 通过将配置修改为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>宿主机能够连接到服务器上。这样设置的含义是，让容器中的Redis监听容器ip的所有端口。这样设置而不是指定ip是因为每个镜像可以启动多个容器，而每个容器的ip地址是不确定的。</p>
<ol>
<li><strong>镜像创建时报错</strong><br>报错信息如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: for dockerenv_dev.php-fpm.srv_1  Cannot start service dev.php-fpm.srv: OCI runtime create failed: container_linux.go:348: starting container process caused &quot;exec: \&quot;docker-entrypoint.sh\&quot;: executable file not found in $PATH&quot;: unknown</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个问题主要是：我的 <code>docker-entrypoint.sh</code> 文件没有可执行权限，因此在镜像创建完后，执行<strong>ENTRYPOINT</strong>指定的脚本时导致错误，解决办法当然很简单，直接执行：<code>chmod +x docker-entrypoint.sh</code>。然后需要重新创建镜像。</p>
<ol>
<li><strong>Nginx 无法连接php-fpm</strong><br>这个错误其实与宿主机无法连接Redis很像，错误信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018/06/13 11:13:26 [error] 5#0: *8 connect() failed (111: Connection refused) while connecting to upstream, client: 172.18.0.1, server: localhost, request: &quot;GET / HTTP/1.1&quot;, upstream: &quot;fastcgi://172.18.0.2:9000&quot;, host: &quot;localhost&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>修改 php-fpm 的监听地址为：<strong>0.0.0.0:9000</strong>，Nginx可正常启动。</p>
<ol>
<li><strong>访问php文件时找不到文件</strong><br>执行动态文件时，出现了文件找不到的提示，具体错误信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018/06/13 11:21:20 [error] 5#0: *10 FastCGI sent in stderr: &quot;Primary script unknown&quot; while reading response header from upstream, client: 172.18.0.1, server: localhost, request: &quot;GET / HTTP/1.1&quot;, upstream: &quot;fastcgi://172.18.0.2:9000&quot;, host: &quot;localhost&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由于Nginx与PHP没有部署在同一个容器中，相关的项目文件只与Nginx进行了共享，而没有与PHP的容器进行共享。因此当访问静态文件时，Nginx直接在自己的容器中完成操作，而访问php文件时信息传到了PHP所在的容器，容器内部无法找到对应的php文件而导致的错误。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过2天的折腾，算是基本把环境搭建起来了。不过还有一些其他问题需要思考该如何进行：</p>
<ul>
<li>如果我的PHP需要新的扩展，该如何去编译这个扩展包？</li>
<li>如何去监控docker中的应用的状态？比如：Redis/Nginx等服务的状态。</li>
</ul>
<p>后续会继续摸索分享自己的经验。</p>
<p>项目地址：<br><a href="https://github.com/helei112g/docker-env" target="_blank" rel="external">https://github.com/helei112g/docker-env</a></p>
<p>微信公众号：<br><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="pub"></p>
<p>参考资料：</p>
<ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/</a></li>
<li><a href="https://docs.lvrui.io/2017/06/09/%E7%BC%96%E5%86%99docker-entrypoint-sh%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6/" target="_blank" rel="external">https://docs.lvrui.io/2017/06/09/%E7%BC%96%E5%86%99docker-entrypoint-sh%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6/</a></li>
<li><a href="https://pkgs.alpinelinux.org/packages" target="_blank" rel="external">https://pkgs.alpinelinux.org/packages</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dockerfile 与 Compose 环境搭建学习笔记（一）]]></title>
      <url>https://helei112g.github.io/2018/06/25/Dockerfile-%E4%B8%8E-Compose-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>大家都用docker了，我先把自己的开发环境换了吧~_~<br><a id="more"></a></p>
<p>以前一直使用 <strong>Vagrant</strong> 作为自己的开发环境，并且在上家公司也推行大家采用 Vagrant 作为开发环境，保障公司使用的是同一套开发环境。随着docker的流行，越来越多的人在docker上运行自己的项目，利用docker也非常方便模拟各种线上集群，相比虚拟机效率会更高，不管是搭建还是运行。</p>
<p>网络上关于docker搭建环境的资料非常之多了，但自己一直没有进行过实践。纸上得来终觉浅，只有自己动过手之后，才能对相关的概念更熟悉。花了将近2天时间折腾，终于算是把docker的开发环境搭建好了，对他的很多概念也又了更深入的认识。整理一下整个过程，方便以后查漏补缺。</p>
<p>下面就来开启docker之旅吧，打算利用docker完成以下任务：</p>
<ul>
<li>基础的环境搭建：MySQL、Redis、Nginx；</li>
<li>搭建PHP、Golang的开发环境；</li>
<li>搭建MySQL、Redis的主从；</li>
<li>探索一下如何监控docker中的进程。</li>
</ul>
<h1 id="涉及的命令介绍"><a href="#涉及的命令介绍" class="headerlink" title="涉及的命令介绍"></a>涉及的命令介绍</h1><p>这仅仅是操作笔记，不涉及 <strong>Docker</strong> 原理什么之类的知识，重点是如何应用。为了后续理解方便，先把用到的相关命令在这里进行整体介绍。</p>
<h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker search mysql</span><br></pre></td></tr></table></figure>
<p>上面这个命令就是查找 mysql 镜像。对应的可以将 mysql 替换成其它想要查找的镜像名称。该命令常用选项是： <code>-s</code>。可以设置搜索条件：多少个start以上的镜像。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker search -s 100 mysql</span><br></pre></td></tr></table></figure>
<p>搜索有100个以上start的 mysql 镜像。</p>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos7</span><br></pre></td></tr></table></figure>
<p>这个命令会把镜像克隆到本地，就像：<code>git clone</code> 一样的效果。关于什么是镜像、容器之类的概念不在我的讲解范畴了。</p>
<h2 id="查看与删除镜像"><a href="#查看与删除镜像" class="headerlink" title="查看与删除镜像"></a>查看与删除镜像</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker image ls</span><br></pre></td></tr></table></figure>
<p>会列出当前所有的本地安装了的镜像。看到了有哪些镜像，有时候一个镜像我们用不到了，想把它干掉，为硬盘腾腾位置，可以用下面的命令：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker rmi 0d16d0a97dd1 <span class="comment"># 编号是 image id</span></span><br></pre></td></tr></table></figure>
<h2 id="创建镜像-Dockerfile"><a href="#创建镜像-Dockerfile" class="headerlink" title="创建镜像 - Dockerfile"></a>创建镜像 - Dockerfile</h2><p>docker的镜像可以从官方直接拉取，也可也通过 Dockerfile 进行定制，写好 Dockerfile 文件后，可以执行下面的命令运行镜像。<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker build -t nginx:1.14.0 .</span><br></pre></td></tr></table></figure></p>
<p>这里的结尾有个 <code>.</code> 它表示上下文，而不是说 Dockerfile 的路径。举例来说，在 Dockerfile 中常常用 Copy 指令，它拷贝的文件必须要在这个上下文中。</p>
<p>Dockerfile的主要作用是：自己根据基础镜像，重新定制镜像，而不是直接从官方仓库拿现成的使用。</p>
<p>具体含义可以看这里：<a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a></p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker <span class="keyword">run</span> -it --rm php:7 bash</span><br></pre></td></tr></table></figure>
<p>上面的命令会启动一个容器，并且分配一个伪终端，退出后容器就会被删除。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker <span class="keyword">run</span> -d -p 9000:9000 php:7</span><br></pre></td></tr></table></figure>
<p>这个命令会在后台运行一个容器，此容器不会因为退出就被删除，可以重复进行start、stop操作。</p>
<p>上面两种容器启动的操作方式，在我的文章中其实不会出现，我的环境是基于docker-compose + Dockerfile 来搭建的。因为根据最佳实践：一个容器内部只包含一个进程，像上面我需要安装：PHP/Golang/Redis/Nginx/Mysql等，就算不算主从也需要启动5个容器，每次这样启动都要累死，还不说需要管理容器之间的互联。因此我使用Compose来定义和运行多个 Docker 容器的应用。</p>
<h2 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker inspect a49dfb2e6f45 <span class="comment"># image id</span></span><br></pre></td></tr></table></figure>
<p>通过该命令可以看到容器的完整信息，我用这个命令主要是在进行容器互联的时候，检查容器的网络与IP相关的情况。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker exec -it e8d740a6ac7a bash <span class="comment"># image id</span></span><br></pre></td></tr></table></figure>
<p>上面的命令可以进入容器，让你感觉像是 ssh 到了远程机器一样的感觉。</p>
<h2 id="停止、启动"><a href="#停止、启动" class="headerlink" title="停止、启动"></a>停止、启动</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker stop a49dfb2e6f45 <span class="comment"># image id</span></span><br></pre></td></tr></table></figure>
<p>如果容器是在后台启动，可以通过该方式停止容器。停止后可以使用下面的命令启动容器：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker start a49dfb2e6f45 <span class="comment"># image id</span></span><br></pre></td></tr></table></figure>
<h2 id="查看与删除容器"><a href="#查看与删除容器" class="headerlink" title="查看与删除容器"></a>查看与删除容器</h2><p>容器也可以像镜像一样进行查看<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker ps</span><br></pre></td></tr></table></figure></p>
<p>上面的命令只会显示启动了的镜像，如果要查看所有镜像，可以添加 <code>-a</code> 选项。<br>如果某个容器不需要了，可以使用下面的命令进行删除：<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker rm 0d848bc87fe7  <span class="comment"># image id</span></span><br></pre></td></tr></table></figure></p>
<p>容器的删除并不会影响镜像，镜像可以继续用来启动新的容器。并且如果依赖某个镜像创建的容器没有被删除，该镜像是不能直接删除的，需要先删除容器后才能继续删除镜像。</p>
<h2 id="Compose-中的启动与停止"><a href="#Compose-中的启动与停止" class="headerlink" title="Compose 中的启动与停止"></a>Compose 中的启动与停止</h2><p>针对docker compose启动与停止用到下面的命令，个人感觉这就是批量操作，毕竟容器太多，一个一个操作太麻烦，容易遗漏等等问题。</p>
<p>批量启动：<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker-compose up -d</span><br></pre></td></tr></table></figure></p>
<p>虽然该命令并不是单纯的启动容器，它非常强大，将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<p>如果已经创建完了，也可以用下面的命令来启动已经创建的容器。<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker-compose start</span><br></pre></td></tr></table></figure></p>
<p>如果想要停止容器可以使用下面的命令：<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker-compose stop</span><br></pre></td></tr></table></figure></p>
<p>当然这些命令的运行，要在 <code>docker-compose.yml</code> 文件所在的目录下运行，否则它也不知道该启动或关闭哪些容器。</p>
<p>基本用到的命令大概就是上面这些，接下来先说说 <code>docker-compose.yml</code> 文件的编写。</p>
<h1 id="Docker-Compose构建环境"><a href="#Docker-Compose构建环境" class="headerlink" title="Docker Compose构建环境"></a>Docker Compose构建环境</h1><p>Docker Compose 可以把多个容器方便的管理起来，也就是所谓的编排技术。</p>
<p>编排技术的核心是 <code>docker-compose.yml</code> 这个模版文件。它定义了容器集群里每一个容器的镜像、数据卷挂载路径、端口、网络等。</p>
<p>以接下来要构建的环境来说明下，下面我将要搭建一个php7的开发环境，需要Nginx/PHP-FPM/MySQL/Redis进行配合。那么需要启动4个容器。对应的也需要4个镜像。整个环境的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── logs</span><br><span class="line">│   └── nginx</span><br><span class="line">├── mysql</span><br><span class="line">│   ├── conf</span><br><span class="line">│   └── data</span><br><span class="line">├── nginx</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── conf</span><br><span class="line">│   └── src</span><br><span class="line">├── php7</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── docker-compose.yml</span><br><span class="line">│   ├── etc</span><br><span class="line">│   ├── extensions</span><br><span class="line">│   └── src</span><br><span class="line">├── redis</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── data</span><br><span class="line">│   └── src</span><br><span class="line">├── start.sh</span><br><span class="line">├── stop.sh</span><br><span class="line">└── www</span><br><span class="line">    └── abc</span><br></pre></td></tr></table></figure>
<p>我的MySQL是直接使用的官方提供的镜像资源，而Redis/Nginx/PHP为了做定制化，我采用Dockerfile进行自定义。接下来按照每一个独立的服务分别进行一下说明。</p>
<h2 id="MySQL服务"><a href="#MySQL服务" class="headerlink" title="MySQL服务"></a>MySQL服务</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dev.mysql.srv:</span><br><span class="line">	image: mysql:<span class="number">5.7</span><span class="number">.22</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line">		- ./mysql/data:/var/lib/mysql</span><br><span class="line"><span class="bullet">      -</span> ./mysql/conf:/etc/mysql/conf.d</span><br><span class="line">	ports:</span><br><span class="line">		- <span class="string">"3307:3306"</span></span><br><span class="line">	restart: always</span><br><span class="line">	environment:</span><br><span class="line">		MYSQL_ROOT_PASSWORD: <span class="number">123123</span></span><br><span class="line">	networks:</span><br><span class="line">		- default</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>image：</strong>是制定依赖的镜像，这里是Docker提供的镜像资源；</li>
<li><strong>volumes：</strong>数据卷所挂载路径设置，主要是MySQL的数据保存的路径设置与配置文件的设置。它的主要作用是持久化数据，避免容器销毁后内部数据丢失；</li>
<li><strong>ports：</strong>暴露到宿主机的端口。这个没什么太多说的，就是为了可以在宿主机访问到容器内部的服务；</li>
<li><strong>restart：</strong>该命令是设置容器如果在某种情况下（非认为）退出了，容器重启的策略；</li>
<li><strong>environment：</strong>设置镜像的环境变量，你可以进入镜像通过：<code>echo $MYSQL_ROOT_PASSWORD</code>查看其值；</li>
<li><strong>networks:</strong>设置网络，让所有的容器在一个网络中，方便容器互联互通。</li>
</ul>
<p>这里还有一个点需要注意，<code>dev.mysql.srv</code> ，是我为mysql服务取的名字。取一个好的名字，非常便于后续容器互联的使用，比如这个名字，如果php代码需要填写mysql的host。我则可以直接使用它。</p>
<h2 id="其它服务"><a href="#其它服务" class="headerlink" title="其它服务"></a>其它服务</h2><p>剩下的三种服务配置方式基本上大同小异。我放在一起说明。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">dev.nginx.srv:</span><br><span class="line">	image: lei_nginx:<span class="number">1.14</span><span class="number">.0</span></span><br><span class="line">	build: ./nginx</span><br><span class="line">	volumes:</span><br><span class="line">		- ./nginx/conf:/home/work/app/nginx/conf</span><br><span class="line"><span class="bullet">      -</span> ./www:/home/work/www</span><br><span class="line">	ports:</span><br><span class="line">		- <span class="string">"80:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"443:443"</span></span><br><span class="line">	restart: always</span><br><span class="line">	networks:</span><br><span class="line">		- default</span><br><span class="line">	depends_on:</span><br><span class="line"><span class="bullet">      -</span> dev.php-fpm.srv</span><br><span class="line">dev.redis.srv:</span><br><span class="line">	image: lei_redis:<span class="number">3.2</span><span class="number">.11</span></span><br><span class="line">	build: ./redis</span><br><span class="line">	volumes:</span><br><span class="line">		- ./redis/conf:/home/work/app/redis/conf</span><br><span class="line"><span class="bullet">      -</span> ./redis/data:/home/work/app/redis/data</span><br><span class="line">	ports:</span><br><span class="line"><span class="bullet">      -</span> <span class="string">"6379:6379"</span></span><br><span class="line">	restart: always</span><br><span class="line">	networks:</span><br><span class="line"><span class="bullet">      -</span> default</span><br><span class="line">dev.php-fpm.srv:</span><br><span class="line">	image: lei_php:<span class="number">7.2</span><span class="number">.6</span></span><br><span class="line">	build: ./php7</span><br><span class="line">	volumes:</span><br><span class="line">		- ./php7/etc:/home/work/app/php/etc</span><br><span class="line">		- ./www:/home/work/www</span><br><span class="line">	ports:</span><br><span class="line">		- <span class="string">"9000:9000"</span></span><br><span class="line">	restart: always</span><br><span class="line">	networks:</span><br><span class="line">		- default</span><br></pre></td></tr></table></figure></p>
<p>这里与MySQL最大的一个区别是多了一个 build 选项。这就是上面说到的这三个镜像都是我用Dockerfile定制的有关。你可以在对应的 build 指定的目录下看到 <code>Dockerfile</code> 这个文件。</p>
<p>另外一个需要注意的地方是Nginx中配置的 <code>depends_on</code> 选项，他的作用是指定依赖，因为Nginx中我配置了php-fpm。所以它启动前要确保php-fpm已经启动后，他才能正常的启动。</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>为了减少太多概念的东西，你可以先直接从github拉取这部分配置，然后运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;./start.sh</span><br><span class="line">Starting dockerenv_dev.php-fpm.srv_1 ... done</span><br><span class="line">Starting dockerenv_dev.redis.srv_1   ... done</span><br><span class="line">Starting dockerenv_dev.mysql.srv_1   ... done</span><br><span class="line">Creating dockerenv_dev.nginx.srv_1   ... done</span><br></pre></td></tr></table></figure>
<p>如果你是第一次运行 <code>start.sh</code> ，他还会去docker hub上拉取镜像，以及根据Dockerfile来定制镜像。所以会有非常多的输出信息。</p>
<p> 然后访问：<a href="http://localhost" target="_blank" rel="external">http://localhost</a> 。应该就能够看到 phpinfo() 输出的信息。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过自己的熟悉，对基本的docker命令，以及docker的三个基础概念：仓库、镜像、容器有了充分的认识。利用 docker compose 搭建一个环境后，对于容器的互联也有了更深刻的体会，并且经过这种一个容器运行一个进程的方式，对系统也有了一些更深的认识。在利用Dockerfile定制镜像的过程中，通过反复的 build 镜像，对理解容器的分层、如何确保镜像体积更小方面有了相当多的实践，特别是在<strong>ENTRYPOINT</strong>的设置上，认识到了docker的启动流程。</p>
<p>由于篇幅限制，把 Dockerfile 的内容在拆出一篇来进行说明，以及把遇到的一些问题也进行一些整理。</p>
<p>我的docker环境：<a href="https://github.com/helei112g/docker-env" target="_blank" rel="external">https://github.com/helei112g/docker-env</a></p>
<p><em>以后换机装换机，再也不担心了</em></p>
<p>微信公众号：<br><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="pub"></p>
<p>参考资料：</p>
<ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Golang中函数传参存在引用传递吗？]]></title>
      <url>https://helei112g.github.io/2018/06/11/Golang%E4%B8%AD%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E5%AD%98%E5%9C%A8%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%90%97%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>Go的函数传递详解，一篇文章搞明白Golang的值传递。<br><a id="more"></a></p>
<p>继上篇文章后，继续来探讨下面的几个问题:</p>
<ol>
<li>函数传参中值传递、指针传递与引用传递到底有什么不一样？</li>
<li>为什么说 <strong>slice</strong>、<strong>map</strong>、<strong>channel</strong> 是引用类型？</li>
<li>Go中 <strong>slice</strong> 在传入函数时到底是不是引用传递？如果不是，在函数内为什么能修改其值？</li>
</ol>
<blockquote>
<p>In a function call, the function value and arguments are evaluated in the usual order. After they are evaluated, the parameters of the call are <strong>passed by value</strong> to the function and the called function begins execution.<br>文档地址：<a href="https://golang.org/ref/spec#Calls" target="_blank" rel="external">https://golang.org/ref/spec#Calls</a></p>
</blockquote>
<p>官方文档已经明确说明：<strong>Go里边函数传参只有值传递一种方式</strong>，为了加强自己的理解，再来把每种传参方式进行一次梳理。</p>
<h1 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h1><blockquote>
<p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
</blockquote>
<p>概念总给人一种教科书的感觉，写点代码验证下。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, &amp;a) <span class="comment">// (*int)(0xc420018080)</span></span><br><span class="line">	vFoo(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vFoo</span><span class="params">(b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, &amp;b) <span class="comment">// (*int)(0xc420018090)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>注释内容是我机器的输出，你如果运行会得到不一样的输出</em></p>
<p>根据代码来解释下，所谓的值传递就是：实参 <strong>a</strong> 在传递给函数 <strong>vFoo</strong> 的形参 <strong>b</strong> 后，在 <strong>vFoo</strong> 的内部，<strong>b</strong> 会被当作局部变量在栈上分配空间，并且完全拷贝 <strong>a</strong> 的值。</p>
<p>代码执行后，我们看到的结果便是：a、b拥有完全不同的内存地址， 说明他们虽然值相同（b拷贝的a，值肯定一样），但是分别在内存中不同的地方，也因此在函数 <strong>vFoo</strong> 内部如果改变 <strong>b</strong> 的值，<strong>a</strong> 是不会受到影响的。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/funcCall1.png" alt="funcCall"></p>
<p>图中左侧是还未调用时，内存的分配，右侧是调用函数后内存分别分配的变量。这里需要注意，就算vFoo的参数名字是a，实参与形参也分别有自己的内存空间，因为参数的名字仅仅是给程序员看的，上篇文章已经说清楚了。</p>
<h1 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h1><blockquote>
<p>形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</p>
</blockquote>
<p>是不是云里雾里的？还是通过代码结合来分析所谓的指针传递。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	pa := &amp;a</span><br><span class="line">	fmt.Printf(<span class="string">"value: %#v\n"</span>, pa) <span class="comment">// value: (*int)(0xc420080008)</span></span><br><span class="line">	fmt.Printf(<span class="string">"addr: %#v\n"</span>, &amp;pa) <span class="comment">// addr: (**int)(0xc420088018)</span></span><br><span class="line">	pFoo(pa)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pFoo</span><span class="params">(p * <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"value: %#v\n"</span>, p) <span class="comment">// value: (*int)(0xc420080008)</span></span><br><span class="line">	fmt.Printf(<span class="string">"addr: %#v\n"</span>, &amp;p) <span class="comment">// addr: (**int)(0xc420088028)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义了一个变量 a，并把地址保存在指针变量 pa 里边了。按照我们定的结论，<strong>Go中只有值传递</strong>，那么指针变量pa传给函数的形参p后，形参将会是它在栈上的一份拷贝，他们本身将各自拥有不同的地址，但是二者的值是一样的（都是变量a的地址）。上面的注释部分是我程序运行后的结果，pa 与 p 的地址各自互不相关，说明在参数传递中发生了值拷贝。</p>
<p>在函数 <strong>pFoo</strong> 中，形参 p 的地址与实参 pa 的地址并不一样，但是他们在内存中的值都是变量 a 的地址，因此可以通过指针相关的操作来改变a的值。<br><img src="http://ol59nqr1i.bkt.clouddn.com/funcCall2.png" alt="funcCall"></p>
<p><em>图中 &amp;a 表示a的地址，值为： 0xc420080008</em></p>
<h1 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h1><blockquote>
<p>所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
</blockquote>
<p>由于 Go 里边并不存在引用传递，我们常常看到说 Go 中的引用传递也是针对：<strong>Slice</strong>、<strong>Map</strong>、<strong>Channel</strong> 这几种类型（这是个错误观点），因此为了解释清楚引用传递，先劳烦大家看一段 C++ 的代码（当然非常简单）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rFoo</span><span class="params">(<span class="keyword">int</span> &amp; ref)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;ref);<span class="comment">// 0x7ffee5aef768</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);<span class="comment">// 0x7ffee7307768</span></span><br><span class="line">    <span class="keyword">int</span> &amp; b = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;b);<span class="comment">// 0x7ffee5aef768</span></span><br><span class="line">    rFoo(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就是简单的在main中定义一个引用，然后传给函数 <strong>rFoo</strong>，那么来看看正统的引用传递是什么样的？</p>
<p>这里 b 是 a 的别名（引用，不清楚的可以看我上篇文章），因此a、b必定具备相同的地址。那么按照引用传递的定义，实参 b 传给形参 ref 之后，ref 将是 b 的别名（也即a、b、ref都是同一个变量），他们将拥有相同地址。通过在 <strong>rFoo</strong> 函数中的打印信息，可以看到三者具有完全形同的地址，这是所谓的引用传递。</p>
<h1 id="Go中没有引用传递"><a href="#Go中没有引用传递" class="headerlink" title="Go中没有引用传递"></a>Go中没有引用传递</h1><p>Go中函数调用只有值传递，但是类型引用有引用类型，他们是：<strong>slice</strong>、<strong>map</strong>、<strong>channel</strong>。来看看官方的说法：</p>
<blockquote>
<p>There’s a lot of history on that topic. Early on, maps and channels were syntactically pointers and it was impossible to declare or use a non-pointer instance. Also, we struggled with how arrays should work. Eventually we decided that the strict separation of pointers and values made the language harder to use.  <strong>Changing these types to act as references to the associated, shared data structures resolved these issues</strong>. This change added some regrettable complexity to the language but had a large effect on usability: Go became a more productive, comfortable language when it was introduced.</p>
</blockquote>
<p>大概意思是说：最开始用的是指针语法，由于种种原因改成了引用，但是这个引用与C++的引用是不同的，它是共享关联数据的结构。关于这个问题的深入讨论我会放到 <strong>slice</strong> 相关文章中进行讨论，现在回到今天讨论的主题。</p>
<p>那么Go的引用传递源起何处？我觉得让大家误解的是，map、slice、channel这类引用类型在传递到函数内部，可以在函数内部对它的值进行修改而引起的误会。</p>
<p>针对这种三种类型是 <strong>by value</strong> 传递，我们用 slice 来进行验证。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"addr:%p\n"</span>, &amp;arr)<span class="comment">// addr:0xc42001a1e0</span></span><br><span class="line">	s1 := arr[:]</span><br><span class="line">	fmt.Printf(<span class="string">"addr:%p\n"</span>, &amp;s1)<span class="comment">// addr:0xc42000a060</span></span><br><span class="line"></span><br><span class="line">	changeSlice(s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"addr:%p\n"</span>, &amp;s)<span class="comment">// addr:0xc42000a080</span></span><br><span class="line">	fmt.Printf(<span class="string">"addr:%p\n"</span>, &amp;s[<span class="number">0</span>])<span class="comment">// addr:0xc42001a1e0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中定义了一个数组 <strong>arr</strong>，然后用它生成了一个slice。如果go中存在引用传递，形参 s 的地址应该与实参 s1 一样（上面c++的证明），通过实际的情况我们发现它们具备完全不同的地址，也就是传参依然发生了拷贝——值传递。</p>
<p>但是这里有个奇怪的现象，大家看到了 <strong>arr</strong> 的地址与 <strong>s[0]</strong> 有相同的地址，这也就是为什么我们在函数内部能够修改 slice 的原因，因为当它作为参数传入函数时，虽然 slice 本身是值拷贝，但是它内部引用了对应数组的结构，因此 <strong>s[0]</strong> 就是 <strong>arr[0]</strong> 的引用，这也就是能够进行修改的原因。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/funcCall3.png" alt="funcCall"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>Go 中函数传参仅有值传递一种方式；</li>
<li><strong>slice</strong>、<strong>map</strong>、<strong>channel</strong>都是引用类型，但是跟c++的不同；</li>
<li><strong>slice</strong>能够通过函数传参后，修改对应的数组值，是因为 slice 内部保存了引用数组的指针，并不是因为引用传递。</li>
</ul>
<p>接下来的文章尝试解析下：<br>slice 为什么一定要用 make 进行初始话，它初始化做了哪些事情？它每次动态扩展容量的时候进行了什么操作？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[指针、引用的理解]]></title>
      <url>https://helei112g.github.io/2018/06/06/%E6%8C%87%E9%92%88%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3-md/</url>
      <content type="html"><![CDATA[<p>指针与引用常常被混淆，他们为什么总被人理解错误？<br><a id="more"></a></p>
<p>最近在学习Golang的过程中，发现一个有意思的事情，有的文章说函数调用传参时 <strong>slice</strong> 是引用传递，有的说是值传递。为什么同一个东西大家会不同认识？为了搞清楚其本质，我进行了以下内容的研究：</p>
<ol>
<li>变量的变量名、变量值、变量地址在内存中是怎么样的？</li>
<li>指针的定义是什么？引用的定义是什么？二者有什么关系？</li>
<li>函数传参中值传递、指针传递与引用传递到底有什么不一样？</li>
<li>Go中 <strong>slice</strong> 在传入函数时到底是不是引用传递？如果不是，在函数内为什么能修改其值？</li>
</ol>
<p>为了避免文章写的过长，看了想瞌睡，分成两篇文章来解释这个问题，本文先解决问题1跟2，下一篇说明余下的问题。</p>
<h1 id="变量名程序员给地址取的外号"><a href="#变量名程序员给地址取的外号" class="headerlink" title="变量名程序员给地址取的外号"></a>变量名程序员给地址取的外号</h1><p>上学的时候，老师讲变量是存在内存中的，内存就像一排排抽屉组成的，每个抽屉上面有个编号，我们定义一个变量，就是把想放的东西放到这个对应编号的抽屉里。比如： int a = 10，用图来表示下：<br><img src="http://ol59nqr1i.bkt.clouddn.com/ref1.png" alt=""></p>
<p>这里：变量的名字叫 <strong>a</strong> ，变量的值是：<strong>10</strong>，变量的地址是：<strong>0x 00000001</strong>。<br>那么问题来了，变量的值我们知道是放在了抽屉里（内存中），每个抽屉有编号（地址），但是变量的名字 <strong>a</strong> 存放在哪里呢？或者说它会存在于内存中吗？</p>
<p>大家想一个问题，如果变量的名字要存放在内存中，那么肯定分配一个空间给他，保存它的空间有个地址，这个地址是不是又得有个地方存起来程序才能找到？如果真是这样设计，那么代码根本没发写、无法运行了。</p>
<p>其实变量名仅仅是写给程序员看的，让我们写代码的时候知道这个变量有什么用，能够通过名字调用变量的值。因为如果直接给你一个地址 0x 23004123，你知道这是要干嘛吗？代码经过编译后，最终都会转换成机器码，我们定义的变量名就都不存在了，存在的只有地址跟值。</p>
<h1 id="指针其实很普通"><a href="#指针其实很普通" class="headerlink" title="指针其实很普通"></a>指针其实很普通</h1><p>有了上面的理解，再来一个特殊的变量：指针变量。什么叫指针变量呢？其实就是这个变量里边存放的是一个变量的地址，通过这个地址，机器可以找到对应变量的值，例如：int <em> pa = &amp;a，就表示变量 <strong>pa</strong> 抽屉里放的是 <strong>a</strong> 的地址，它的类型是：int</em>，继续看图：<br><img src="http://ol59nqr1i.bkt.clouddn.com/ref2.png" alt=""></p>
<p><strong>这里需要重要说明的是：指针pa与a的关系是：a抽屉里边放的是变量值10，pa放的是变量的地址：0x00000001</strong>，这里一定要记住，下面说引用的时候才更容易理解。</p>
<h1 id="引用就是变量的另一名字"><a href="#引用就是变量的另一名字" class="headerlink" title="引用就是变量的另一名字"></a>引用就是变量的另一名字</h1><p>继续谈引用，引用与指针我们经常傻傻分不清，因为它们的行为确实非常诡异，看起来效果非常相似，看代码：</p>
<blockquote>
<p>由于引用的概念是在 c++ 中引入的，因此下面的代码使用c++，仅仅是一些打印而已，放心看下去  </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">// 变量</span></span><br><span class="line">    <span class="keyword">int</span> * pa = &amp;a; <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">int</span> &amp; b = a; <span class="comment">// 引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a: %d\n"</span>, a);<span class="comment">// a: 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*pa: %d\n"</span>, *pa);<span class="comment">// *pa: 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b: %d\n"</span>, b);<span class="comment">// b: 10</span></span><br><span class="line"></span><br><span class="line">    *pa = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a: %d\n"</span>, a);<span class="comment">// a: 20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*pa: %d\n"</span>, *pa);<span class="comment">// *pa: 20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b: %d\n"</span>, b);<span class="comment">// b: 20</span></span><br><span class="line"></span><br><span class="line">    b = <span class="number">30</span>;</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">"a: %d\n"</span>, a);<span class="comment">// a: 30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*pa: %d\n"</span>, *pa);<span class="comment">// *pa: 30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b: %d\n"</span>, b);<span class="comment">// b: 30</span></span><br><span class="line"></span><br><span class="line">	  a = <span class="number">40</span>;</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">"a: %d\n"</span>, a);<span class="comment">// a: 40</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*pa: %d\n"</span>, *pa);<span class="comment">// *pa: 40</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b: %d\n"</span>, b);<span class="comment">// b: 40</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们发现，指针与引用都能达到一个效果：都有能力修改a的值，指针前面讲过了，因为它保存了a的地址，通过解引用操作后，实际上就是打开了a的抽屉，因此可以进行修改。那么引用又是怎么办到的？这里注意一个细节：<em>pa = 20； c = 30；a = 40。我们看到操作c的时候与操作a是一样的方式：直接使用变量名，但是pa要想改变a的值，必须进行 </em>pa 操作（解引用），如果直接 pa=20，这仅仅是改变的pa的值，让他指向了另外一个地址。</p>
<p>为什么引用与变量是一样的操作方式？先来看一下引用的定义：</p>
<blockquote>
<p>引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。  </p>
</blockquote>
<p>那么别名是什么意思呢？继续看图，一看就懂<br><img src="http://ol59nqr1i.bkt.clouddn.com/ref3.png" alt=""><br>看到了吧？a就是b，b就是a。系统并不会为引用额外分配空间进行存储，甚至可以简单理解为：这个别名仅仅是为了给程序员看的，到机器码层面的时候，他们都会变成地址：0x 00000001。</p>
<h1 id="有码为证"><a href="#有码为证" class="headerlink" title="有码为证"></a>有码为证</h1><p>通过上面的分析不知道你理解了几分？或者你是不是对指针与引用还是半信半疑？没关系，写点代码证明一下即可，我们要证明的是：</p>
<ul>
<li>引用是变量的别名，那么它的地址应该与变量一致；</li>
<li>指针保存的是变量的地址，那么它的值是变量的地址，它自身的地址与变量不同。</li>
</ul>
<p>为了证明，程序设计如下：定义一个变量，分别赋值给指针、引用，然后检查他们对应的值与地址。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"~~~~~~~~~~~~~~\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> * b = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"~~~~~~~~~~~~~~\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> &amp; c = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>获得输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10 // 变量a的值</span><br><span class="line">0x7ffee3c7a768 // 变量a的地址</span><br><span class="line">~~~~~~~~~~~~~~</span><br><span class="line">0x7ffee3c7a768 // 指针的值，是变量a的地址</span><br><span class="line">0x7ffee3c7a760 // 指针变量自己的地址</span><br><span class="line">~~~~~~~~~~~~~~</span><br><span class="line">10 // 变量a的值</span><br><span class="line">0x7ffee3c7a768 // 引用变量c的地址，与变量a的地址完全一样</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在上面如果指针想要打印变量a的值，需要解引用操作：printf(“%d\n”, *b);  </p>
</blockquote>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>变量由三分部分构成：变量名、变量值、变量地址；</li>
<li>变量名实际上只是给程序员看的，编译后的代码中并不存在变量名；</li>
<li>指针变量就是一个变量存储了另外一个变量的地址，系统也会为他分配内存空间来存储这个地址；</li>
<li>引用实际是变量的别名，他跟变量有相同的地址。</li>
</ul>
<p><strong>下次预告：</strong></p>
<ol>
<li>函数传参中值传递、指针传递与引用传递到底有什么不一样？</li>
<li>为什么说 <strong>slice</strong> 是引用类型？</li>
<li>Go中 <strong>slice</strong> 在传入函数时到底是不是引用传递？如果不是，在函数内为什么能修改其值？</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一个程序员对架构的认识]]></title>
      <url>https://helei112g.github.io/2018/05/27/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AF%B9%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%A4%E8%AF%86-md/</url>
      <content type="html"><![CDATA[<p>架构是一个系统的草图（逻辑+物理角度），它是有生命的，随着业务的变化会不断演进。没有完美的架构只有合适的架构。<br><a id="more"></a></p>
<p>最近订阅了一些架构方面的资料，阅读后获益匪浅，想着整理一些自己的体会与思考，形成架构方面的读书笔记，一来与大家交流，二来通过文字的形式检查自己到底收获多少！</p>
<p>“我们系统是MVC架构的”</p>
<p>“淘宝的架构好屌”</p>
<p>“最近在学习MySQL的架构”</p>
<p>“这个系统开发我们要用MVC框架来进行开发”</p>
<hr>
<p>我们常常听到上面关于架构的各种描述，那么架构到底是指什么？系统、框架、架构三者之间是一个什么样的关系？下面让我们结合实际的例子一起来探究下。</p>
<h1 id="架构的含义"><a href="#架构的含义" class="headerlink" title="架构的含义"></a>架构的含义</h1><p>小石最近加入了一家生鲜电商公司。公司现在的首要任务是把电商系统给做出来，让用户能够通过PC、App购买公司的生鲜产品。</p>
<blockquote>
<p>关键词：<strong>系统</strong>，所谓系统可以简单理解为我们平时所说的应用，当然系统可以包含多个小系统，这里为了简单起见，我们就先假设只开发这样一个单体应用，包含了用户下单购买的基本功能。  </p>
</blockquote>
<p>小石通过分析其他电商系统，知道至少需要 <strong>用户注册登录模块</strong>、<strong>用户信息模块</strong>、<strong>商品模块</strong>、<strong>订单模块</strong> 系统才能够进行运转。</p>
<p>系统的功能确定了，该选择用什么样的语言进行开发呢？选择什么样的方式进行开发呢？与大家一起讨论后，大家认为现在阶段的首要目标是快速做出系统来，因此大家决定采用PHP来开发，并决定使用 <strong>Yii2</strong> 框架，数据库方面使用 MySQL，WebService使用Nginx。</p>
<blockquote>
<p>关键词：<strong>框架</strong>，为了快速完成系统的开发，我们会采用一些已被业内实践确认的规范来进行，比如这里采用 YII2 框架，也就是采用了业内的 MVC 规范。所以可以认为所谓的框架就是确定了一些业内规范，从某种程度上对大家形成约束或者形成都能理解的规定。  </p>
</blockquote>
<p>从开始到现在，还没有写一行代码，一直在进行设计与讨论，讨论需要哪些功能，设计采用什么 <strong>结构</strong>，而这里的结构主要包括了两方面：逻辑的结构与物理的结构。所谓逻辑结构就是指系统是按照什么样的流程来运转，需要哪些功能来支持。所谓物理，就是当编码完成所有的逻辑后，系统采用什么形式来部署运行。</p>
<p>那么到底什么是架构呢？我理解的架构：在系统诞生之初，对系统进行的逻辑设计与物理设计。他是系统的草图，可以类比为建筑领域的设计图。这张图需要确定：</p>
<ul>
<li>业务需要的功能模块划分（建筑设计需要划分区域功能）</li>
<li>技术选型，用什么框架、什么存储、什么缓存（建筑领域也要确认框架结构还是框剪结构）</li>
</ul>
<h1 id="架构是进化的"><a href="#架构是进化的" class="headerlink" title="架构是进化的"></a>架构是进化的</h1><p>一个架构的0.1版本绝对不会是完美的，世界上也不存在完美的架构。像上面的小故事，我们采用最简单的架构，如下图（物理角度）：<br><img src="http://ol59nqr1i.bkt.clouddn.com/jg2.jpeg" alt="架构"></p>
<p>我们把所有的功能写在一份代码里，所有的数据存在一个库里，所有的代码部署在同一个Nginx上，甚至还可能我们的Nginx、MySQL都部署在同一台机器上。</p>
<p>公司业务得以发展，人员得以增加，系统变得更加复杂。这个时候原来的架构，一无法满足业务快速发展，二无法让多人开发变得愉快。因为几十个人在同一份代码里进行编码，想一下都是头大。文件冲突、功能依赖、bug排查、测试功能，这些都无法愉快的解决。这时就得根据新的情况重新设计架构。</p>
<p>我们将代码功能进行拆分，将以前的模块拆分成独立的系统，将MySQL进行主从设计，利用Nginx做负载等等。</p>
<p>那么为什么不一上来就进行拆分呢？因为一开始人手不足，拆分过细，开发周期慢，业务也不需要如此细致的划分。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>架构是一个系统的草图（逻辑+物理角度），它是有生命的，随着业务的变化会不断演进。没有完美的架构只有合适的架构。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Go初始化变量的招式]]></title>
      <url>https://helei112g.github.io/2018/05/26/Go%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F%E7%9A%84%E6%8B%9B%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>乱立Flag害死人<br><a id="more"></a></p>
<p>年初的立的各种Flag，已经被我抛到九霄云外去了。2018年已经过去了一半，终于开始了第三篇文章，距离全年30篇的输出计划，仅剩27本，我很有“信心完成”剩下的部分。</p>
<p>2018年伊始，开始从PHP转到Go的开发方向，虽然说学习路线并不是非常陡峭，但是过程中遇到不少坑以及有意思的地方，忍不住想总结分享给大家。今天先来聊一聊Go中初始化变量的几种方式。</p>
<h1 id="Go中初始化值类型的招式"><a href="#Go中初始化值类型的招式" class="headerlink" title="Go中初始化值类型的招式"></a>Go中初始化值类型的招式</h1><p>Golang的数据类型可以分为：<strong>值类型</strong> 与 <strong>引用类型</strong>，我先来总结一下Go中值类型（以 <strong>string</strong> 为例）的初始化方式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"a1: %#v \n"</span>, a1) <span class="comment">// a1: ""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a2 *<span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"a2: %#v \n"</span>, a2) <span class="comment">// a2: (*string)(nil)</span></span><br><span class="line"><span class="comment">// panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line"><span class="comment">//fmt.Printf(**"a2: %#v \n"**, *a2)</span></span><br><span class="line"></span><br><span class="line">a3 := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line">fmt.Printf(<span class="string">"a3: %#v \n"</span>, a3) <span class="comment">// a3: (*string)(0xc42000e200)</span></span><br><span class="line">fmt.Printf(**<span class="string">"a3: %#v \n"</span>**, *a3) <span class="comment">// a3: ""</span></span><br><span class="line"></span><br><span class="line">a4 := <span class="string">"hello"</span></span><br><span class="line">fmt.Printf(<span class="string">"a4: %#v \n"</span>, a4) <span class="comment">// a4: "hello"</span></span><br><span class="line"></span><br><span class="line">a5 := <span class="keyword">string</span>(<span class="string">"hello"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"a5: %#v \n"</span>, a5) <span class="comment">// a5: "hello"</span></span><br><span class="line"></span><br><span class="line">a6 := &amp;a5</span><br><span class="line">fmt.Printf(<span class="string">"a6: %#v \n"</span>, a6) <span class="comment">// a6: (*string)(0xc42000e1e0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，cannot make type string</span></span><br><span class="line"><span class="comment">//a7 := make(string, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，cannot take the address of string("hello")</span></span><br><span class="line"><span class="comment">//a8 := &amp;string("hello")</span></span><br></pre></td></tr></table></figure></p>
<p>注释部分是输出的信息，可以看到有的结果打出来是个值，有的是一个指针。这一部分重点我只想说明两个点：</p>
<ol>
<li>Go会自动将申明变量初始化为0值，所谓的0值是：int就是0，string就是空字符，bool就是false等</li>
<li>对于通过new创建的变量，是一个指针，它与var声明的变量是不同的，var声明的变量仅是一个nil。而new(string) 为string分配一片内存，初始化为 0。通过上面注释的报错信息大家可以理解。</li>
</ol>
<h1 id="Go中初始化引用类型的招式"><a href="#Go中初始化引用类型的招式" class="headerlink" title="Go中初始化引用类型的招式"></a>Go中初始化引用类型的招式</h1><p>这是我想说的重点，Go中的引用类型仅有三种：::map:: ::slice:: ::channel::，这里举例就用slice来进行。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"s1: %#v\n"</span>, s1) <span class="comment">// s1: []string(nil)</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="string">"hello"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"s1: %#v\n"</span>, s1) <span class="comment">// s1: []string&#123;"hello"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 *[]<span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"s2: %#v\n"</span>, s2) <span class="comment">// s2: (*[]string)(nil)</span></span><br><span class="line"></span><br><span class="line">s3 := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"s3: %#v\n"</span>, s3) <span class="comment">// s3: []string&#123;"a", "b", "c"&#125;</span></span><br><span class="line"></span><br><span class="line">s4 := &amp;[]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"s4: %#v\n"</span>, s4) <span class="comment">// s4: &amp;[]string&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">s5 := &amp;s3</span><br><span class="line">fmt.Printf(<span class="string">"s5: %#v\n"</span>, s5) <span class="comment">// s5: &amp;[]string&#123;"a", "b", "c"&#125;</span></span><br><span class="line"></span><br><span class="line">s6 := <span class="built_in">new</span>([]<span class="keyword">string</span>)</span><br><span class="line">fmt.Printf(<span class="string">"s6: %#v\n"</span>, s6) <span class="comment">// s6: &amp;[]string(nil)</span></span><br><span class="line"><span class="comment">// first argument to append must be slice; have *[]string</span></span><br><span class="line"><span class="comment">//s6 = append(s6, "hello") // 这是一个空引用的指针，所以报错</span></span><br><span class="line"></span><br><span class="line">s7 := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"s7: %#v\n"</span>, s7) <span class="comment">// s7: []string&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有毛病才用这种方式</span></span><br><span class="line">s8 := <span class="built_in">new</span>([]<span class="keyword">string</span>)</span><br><span class="line">*s8 = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"s8: %#v\n"</span>, s8) <span class="comment">// s8: &amp;[]string&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">arr := [<span class="number">5</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">s9 := arr[:]</span><br><span class="line">fmt.Printf(<span class="string">"s9: %#v\n"</span>, s9) <span class="comment">// s9: []string&#123;"a", "b", "c", "", ""&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里我重点分析一下s6、s7、s8这三种初始化方式。先说s6，使用的是new。</p>
<blockquote>
<p>new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针<br>这里所谓的值为0，并不是数值0，而是go的默认0值，对应 ::slice:: 就是nil。</p>
</blockquote>
<p>在Go中绝对不会采用这种方式来初始化 ::slice:: 的，原因是为什么呢？我这里先简单说一下，是因为Go中::slice::是如下定义的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果用 new 因为返回的是 <em>T 的内存地址，无法完成对 ::slice::的初始化，无法让slice正常使用，想要让他可以正常使用，就得像s8的处理方式一样，再用make对应  </em>T 进行一次初始化。如果这么干，你说是不是有毛病才用的方式？</p>
<blockquote>
<p>slice 的初始化需要初始化 len、cap的值，让 array 指向一个数组的指针。完成这些初始化后，slice才能正常使用。  </p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于自定义结构的初始化与上面string的初始化一样，map、channel与slice一样。大家可以自己写点代码试试</p>
<ul>
<li>记住make只用于map，slice和channel，并且不返回指针。</li>
<li>要获得一个显式的指针，使用new进行分配，或者显式地使用一个变量的地址。</li>
</ul>
<p>接下来计划分享的内容：</p>
<ol>
<li>Go中值、引用、指针方面的知识，重点是函数参数的传参方式</li>
<li>Go中::slice::与::array::的亲密关系</li>
<li>Go中接口的知识，从::sort::的源代码角度来介绍</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Go语言中的Interface]]></title>
      <url>https://helei112g.github.io/2018/02/13/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84Interface/</url>
      <content type="html"><![CDATA[<p>文章摘要，作者太懒了，没写……<br><a id="more"></a></p>
<p><strong>先给大家拜个早年：狗年旺旺旺</strong></p>
<p>最近在看Go语言的面向对象的知识点时，发现它的面向对象能力全靠 interface 撑着，而且它的 interface 还与我们以前知道的 interface 完全不同。故而整个过程不断的思考为什么要如此设计？这样设计给我们带来了什么影响？</p>
<h1 id="interface-我不懂你"><a href="#interface-我不懂你" class="headerlink" title="interface 我不懂你"></a>interface 我不懂你</h1><p>Rob Pike 曾说：</p>
<blockquote>
<p>如果只能选择一个Go语言的特 性移植到其他语言中，他会选择接口</p>
</blockquote>
<p>被Go语言设计者如此看重，想来 interface 一定是资质不凡，颜值爆表。但是说实话，当我第一次读这部分内容的时候，我产生了以下三个问题：</p>
<ol>
<li>原来的 <code>implement</code> 方式产生了什么问题，我用的不好好的吗？</li>
<li>如果不通过 <code>implement</code> 把接口与实现类强制关联起来，它怎么知道我实现的哪个接口？</li>
<li>这么干为实际编码带来了什么影响或者说好处？</li>
</ol>
<p>带着这些问题我进行了一些比较与分析，<code>Rob Pike</code> 如此说，不可能是想骗我们都去用 Go，毕竟大家都是上过小学的，骗不了你们。</p>
<h1 id="侵入式与非侵入式"><a href="#侵入式与非侵入式" class="headerlink" title="侵入式与非侵入式"></a>侵入式与非侵入式</h1><p>在诸多的资料中，大家都提到 <strong>侵入式</strong> 与 <strong>非侵入式</strong> 这样的概念，我用代码来解释下这两个概念。</p>
<p><strong>PHP 中的侵入式：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> $name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAge</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Go 中的非侵入式</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetAge() <span class="keyword">int</span></span><br><span class="line">	GetName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person= Student&#123;<span class="number">20</span>, <span class="string">"Elon"</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"This person name is"</span>, p.GetName())</span><br><span class="line">	fmt.Println(<span class="string">"This person age is"</span>, p.GetAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码我总结了以下问题：</p>
<ol>
<li>侵入式通过 <code>implements</code> 把实现类与具体接口绑定起来了，因此有了强耦合;</li>
<li>如果我修改了接口，比如改了接口方法，则实现类必须改动；</li>
<li>如果我希望实现类再实现一个接口，实现类也必须进行改动；</li>
<li>后续跟进者，必须了解相关的接口。</li>
</ol>
<p>这几个问题是开发中经常遇到的问题，而 Go 非侵入式的方式完美解决了这几个问题。他只要实现了与接口定义相同的方法，就算实现了某个接口，最重要的，随着代码的增加，你的类结构不会像 Java 那样发生爆炸。因为你根本不用关心你实现了什么接口，你只需要关心你的类有什么方法，方法有什么功能。在实现类的时候也不需要像 Java、PHP 一样引入各种接口，有可能你定义类的时候，某个接口还不存在，接下来我单独说说该方式的意义。</p>
<h1 id="interface-意义非凡"><a href="#interface-意义非凡" class="headerlink" title="interface 意义非凡"></a>interface 意义非凡</h1><p>在我没有理解之前，我觉得Go的接口很变扭，以前的码代码的思路都是：先设计好接口，再去做具体的实现。现在一个类你可能根本分不清他实现了那个接口。还是上面的例子，稍微改一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetAge() <span class="keyword">int</span></span><br><span class="line">	GetName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetAge() <span class="keyword">int</span></span><br><span class="line">	GetName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个接口 <code>Person</code>、<code>Car</code> 他们有相同的方法，而 <code>Student</code> 实现了这两个方法，在 Go 里边就可以说他同时实现了这两个接口，不信你试试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person= Student&#123;<span class="number">20</span>, <span class="string">"Elon"</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"This person name is"</span>, p.GetName())</span><br><span class="line">	fmt.Println(<span class="string">"This person age is"</span>, p.GetAge())</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> c Car= Student&#123;<span class="number">1</span>, <span class="string">"BMW"</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"This car name is"</span>, c.GetName())</span><br><span class="line">	fmt.Println(<span class="string">"This car age is"</span>, c.GetAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是为了说明问题，名字上看起来有点诡异(Student 竟然可以是车？上车就是上 Student？)</p>
<p>这种能力带来的真正让人吃惊的地方是什么？从此以后我可以先写类了，我先根据实际情况把类的功能做好，在某个我具体需要使用的地方，我再定义接口。说的专业点：也就是接口是由使用方根据自己真实需求来定义，并且不用关心是否有其它使用方定义过。</p>
<p>这样子到底解决了什么开发中的问题？举个例子：我们一个大团队在开发一个商城系统，m端、app端、pc端都有购物车的需求，底层根据不同的需求已经实现了一个Cart类，通过该类可以获取购物车价格、数量等。例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cart <span class="keyword">struct</span> &#123;</span><br><span class="line">	price <span class="keyword">float32</span></span><br><span class="line">	num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cart)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cart)</span> <span class="title">GetNum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候前端要进行调用了，他们可以自由定义接口名称用于接受，只需要关心自己的接口需要什么方法，Cart 是否全部实现了需要的方法，每一个端完全可以自己定义一个接口，接口名称、定义的方法顺序都可以不同。</p>
<p>我觉得这才是真正做到了：<code>依赖于接口而不是实现，优先使用组合而不是继承</code></p>
<hr>
<p>欢迎指正交流</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP的引用，你知道多少]]></title>
      <url>https://helei112g.github.io/2017/12/15/PHP%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91/</url>
      <content type="html"><![CDATA[<p>除了学到引用知识，文末还给你带来了一家2018年上海最值得加入的公司。<br><a id="more"></a></p>
<p>真的是变懒了，一个月一篇的节凑都很难保证了。</p>
<p>最近面试他人的过程中，问了一些关于PHP引用的知识，发现很多同学对这方面知之甚少，还有很多工作中基本没有使用过。甚至有人告诉我要少用引用，引用会带来一些诡异的问题。我心里默默说，避免诡异的问题是要去理解引用而不是少用引用。今天一起来解析解析。</p>
<h1 id="场景假设"><a href="#场景假设" class="headerlink" title="场景假设"></a>场景假设</h1><p>先从一个引用的所谓诡异问题开始。假设我们有这个场景：我们从数据库中读取了一组订单数据，需要把订单的每条数据单独做些处理。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$list = [</span><br><span class="line">    [<span class="string">'orderid'</span> =&gt; <span class="string">'123'</span>, <span class="string">'total_fee'</span> =&gt; <span class="number">10</span>, <span class="string">'name'</span> =&gt; <span class="string">'zhangsan'</span>],</span><br><span class="line">    [<span class="string">'orderid'</span> =&gt; <span class="string">'456'</span>, <span class="string">'total_fee'</span> =&gt; <span class="number">17</span>, <span class="string">'name'</span> =&gt; <span class="string">'lisi'</span>],</span><br><span class="line">    [<span class="string">'orderid'</span> =&gt; <span class="string">'789'</span>, <span class="string">'total_fee'</span> =&gt; <span class="number">14</span>, <span class="string">'name'</span> =&gt; <span class="string">'wangwu'</span>],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> &amp;$item) &#123;</span><br><span class="line">    <span class="comment">// 对订单做了些什么处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了一些其它操作</span></span><br><span class="line"></span><br><span class="line">$result = [];<span class="comment">// 需要返回的结果</span></span><br><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> $item) &#123;<span class="comment">// 重新映射名字</span></span><br><span class="line">    $result[] = [</span><br><span class="line">        <span class="string">'order_id'</span> =&gt; $item[<span class="string">'orderid'</span>],</span><br><span class="line">        <span class="string">'amount'</span> =&gt; $item[<span class="string">'total_fee'</span>],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序会输出如下结果：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var_dump($result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="number">0</span>]=&gt;</span><br><span class="line">  <span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    [<span class="string">"order_id"</span>]=&gt;</span><br><span class="line">    string(<span class="number">3</span>) <span class="string">"123"</span></span><br><span class="line">    [<span class="string">"total_fee"</span>]=&gt;</span><br><span class="line">    int(<span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="number">1</span>]=&gt;</span><br><span class="line">  <span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    [<span class="string">"order_id"</span>]=&gt;</span><br><span class="line">    string(<span class="number">3</span>) <span class="string">"456"</span></span><br><span class="line">    [<span class="string">"total_fee"</span>]=&gt;</span><br><span class="line">    int(<span class="number">17</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="number">2</span>]=&gt;</span><br><span class="line">  <span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    [<span class="string">"order_id"</span>]=&gt;</span><br><span class="line">    string(<span class="number">3</span>) <span class="string">"456"</span></span><br><span class="line">    [<span class="string">"total_fee"</span>]=&gt;</span><br><span class="line">    int(<span class="number">17</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是经常遇到的一种所谓的诡异问题，先用引用循环处理数据，后面又用了与引用相同的临时变量继续处理数据。这里就是：<code>$item</code>。很多同学说预防这种问题，就要少用引用。这种态度太消极了，引用在很多地方带来了代码书写的简洁，并且针对大数组使用引用能够节省大量的内存。</p>
<h1 id="诡异问题解析"><a href="#诡异问题解析" class="headerlink" title="诡异问题解析"></a>诡异问题解析</h1><p>现在我们来分析下上面问题出现的原因。先来看引用的定义</p>
<blockquote>
<p>引用意味着用不同的名字访问同一个变量内容。</p>
</blockquote>
<p>那么在这部分代码中</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> &amp;$item) &#123;</span><br><span class="line">    <span class="comment">// 对订单做了些什么处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>$item</code> 最后跟 <code>$orders[2]</code> 指向了同一个变量内容。并且在 <code>foreach</code> 循环完后，<code>$item</code> 并没有被销毁，因此在后续如果同名的话，会继续生效。图示如下：<br><img src="http://ol59nqr1i.bkt.clouddn.com/1.jpeg" alt="image"></p>
<p>那么再接下来的的另一个循环中。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> $item) &#123;<span class="comment">// 重新映射名字</span></span><br><span class="line">    $result[] = [</span><br><span class="line">        <span class="string">'order_id'</span> =&gt; $item[<span class="string">'orderid'</span>],</span><br><span class="line">        <span class="string">'amount'</span> =&gt; $item[<span class="string">'total_fee'</span>],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每当 <code>$orders</code> 把变量赋值给 <code>$item</code> 的时候，都同时改变了 <code>$orders[2]</code> 的值。因此才会出现上面诡异的情况。我来逐步给大家演示下：</p>
<ul>
<li>第一次循环 <code>$orders[0]</code>，<code>$item</code> 指向 <code>orderid=123</code> 的订单，由于 <code>$item</code> 是 <code>$orders[2]</code> 的引用，此时导致 <code>$orders[2]</code> 也指向了 <code>orderid=123</code> 的订单；</li>
<li>第二次循环 <code>$orders[1]</code>, <code>$item</code> 指向 <code>orderid=456</code> 的订单，因此 <code>$orders[2]</code> 也指向了 <code>orderid=456</code>；</li>
<li>第三次循环 <code>$orders[2]</code>的时候，明显其值已经变成了 <code>orderid=456</code> 的订单。</li>
</ul>
<p>通过上面的分析，我相信大家对引用所谓的诡异有了了解。那么又该如何避免这种情况出现呢？其实很简单，每次使用完引用后，记得 <code>unset</code> 调引用。在后面便可毫无顾忌的继续使用了。具体到本例子就是：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> &amp;$item) &#123;</span><br><span class="line">    <span class="comment">// 对订单做了些什么处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unset</span>($item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了一些其它操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> $item) &#123;<span class="comment">// 重新映射名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="引用的妙用"><a href="#引用的妙用" class="headerlink" title="引用的妙用"></a>引用的妙用</h1><p>前面我说过，引用可以写出简洁的代码。无限级分类的使用便是一个使用场景。比如说我们有个分类的数据：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$catList = [</span><br><span class="line">    <span class="string">'1'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">1</span>, <span class="string">'name'</span> =&gt; <span class="string">'颜色'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">    <span class="string">'2'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">2</span>, <span class="string">'name'</span> =&gt; <span class="string">'规格'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">    <span class="string">'3'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">3</span>, <span class="string">'name'</span> =&gt; <span class="string">'白色'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">    <span class="string">'4'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">4</span>, <span class="string">'name'</span> =&gt; <span class="string">'黑色'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">    <span class="string">'5'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">5</span>, <span class="string">'name'</span> =&gt; <span class="string">'大'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">2</span>],</span><br><span class="line">    <span class="string">'6'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">6</span>, <span class="string">'name'</span> =&gt; <span class="string">'小'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">2</span>],</span><br><span class="line">    <span class="string">'7'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">7</span>, <span class="string">'name'</span> =&gt; <span class="string">'黄色'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>如果我想得到下面这种形式<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$result = [</span><br><span class="line">    [<span class="string">'id'</span> =&gt; <span class="number">1</span>, <span class="string">'name'</span> =&gt; <span class="string">'颜色'</span>, <span class="string">'children'</span> =&gt; [</span><br><span class="line">        [<span class="string">'id'</span> =&gt; <span class="number">3</span>, <span class="string">'name'</span> =&gt; <span class="string">'白色'</span>],</span><br><span class="line">        [<span class="string">'id'</span> =&gt; <span class="number">4</span>, <span class="string">'name'</span> =&gt; <span class="string">'黑色'</span>],</span><br><span class="line">        [<span class="string">'id'</span> =&gt; <span class="number">7</span>, <span class="string">'name'</span> =&gt; <span class="string">'黄色'</span>]</span><br><span class="line">    ]],</span><br><span class="line">    [<span class="string">'id'</span> =&gt; <span class="number">2</span>, <span class="string">'name'</span> =&gt; <span class="string">'规格'</span>, <span class="string">'children'</span> =&gt; [</span><br><span class="line">        [<span class="string">'id'</span> =&gt; <span class="number">5</span>, <span class="string">'name'</span> =&gt; <span class="string">'大'</span>],</span><br><span class="line">        [<span class="string">'id'</span> =&gt; <span class="number">6</span>, <span class="string">'name'</span> =&gt; <span class="string">'小'</span>]</span><br><span class="line">    ]]</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>如果使用引用，可以非常简单的得出结果。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$treeData = [];<span class="comment">// 保存结果</span></span><br><span class="line"><span class="keyword">foreach</span> ($catList <span class="keyword">as</span> $item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>($catList[$item[<span class="string">'parent_id'</span>]]) &amp;&amp; ! <span class="keyword">empty</span>($catList[$item[<span class="string">'parent_id'</span>]])) &#123;<span class="comment">// 肯定是子分类</span></span><br><span class="line">        $catList[$item[<span class="string">'parent_id'</span>]][<span class="string">'children'</span>][] = &amp;$catList[$item[<span class="string">'id'</span>]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 肯定是一级分类</span></span><br><span class="line">        $treeData[] = &amp;$catList[$item[<span class="string">'id'</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家可以试试不用引用的方式，把无限级实现出来试试，比较下代码。</p>
<hr>
<p>年底了。没钱给大家发红包，给大家推荐一家上海的好公司。为大家跳槽助力。<br><img src="http://ol59nqr1i.bkt.clouddn.com/yimishiji-1.jpg" alt="image"><br><img src="http://ol59nqr1i.bkt.clouddn.com/yimishiji-2.jpg" alt="image"></p>
<p>公司网站：<a href="https://www.yimishiji.com/" target="_blank" rel="external">https://www.yimishiji.com/</a></p>
<p>手机网站：<a href="https://m.yimishiji.com/" target="_blank" rel="external">https://m.yimishiji.com/</a></p>
<p>公司目前正在招聘高级PHP工程师，要求：</p>
<ul>
<li>2-5年的PHP开发经验；</li>
<li>本科学历；</li>
<li>至少熟悉Laravel、Yii2框架中的一种；</li>
<li>有电商、生鲜相关的经验加分；</li>
<li>有博客、GitHub的加分。</li>
</ul>
<p>待遇优厚：五险一金；每日内购零农残、有机食材水果；薪资15k-30k。</p>
<p>公司使用的是PHP7语法，对新技术是保持激进的态度。对于上海的小伙伴或者想去上海的小伙伴，强烈建议去看看。</p>
<ul>
<li>公司地址：上海市长宁区天山西路789号中山国际广场B座一米市集</li>
<li>CTO邮箱：alex.chang@yimishiji.com</li>
</ul>
<hr>
<p>如果你对我的内容感兴趣，请关注我的微信公众号：</p>
<p>公众号：<code>icanfo</code></p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
<p>GitHub：<a href="https://github.com/helei112g" target="_blank" rel="external">https://github.com/helei112g</a></p>
<p><strong>我在github开源了支付宝支付、微信支付、招商一网通支付的php sdk。希望能够帮助你提升项目开发的效率。<a href="https://github.com/helei112g/payment" target="_blank" rel="external">项目地址</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我想成为一个真的程序员]]></title>
      <url>https://helei112g.github.io/2017/10/25/%E6%88%91%E6%83%B3%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%9C%9F%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98/</url>
      <content type="html"><![CDATA[<p>是的，当了4年假程序员，我想要变成真的<br><a id="more"></a></p>
<p>最近看了 <code>左耳朵耗子</code> 写的一段话：</p>
<blockquote>
<p>所以，我和一些人开玩笑说，我们可能都是在写一样的 for(int i=0; i&lt;n; i++) 语句，但是，你写在那个地方一文不值，而我写在这个地方，这行代码就值 2000 元。不要误会，我只是想用这种“鲜明的方式”来加强我的观点。</p>
</blockquote>
<p>读到时，脑袋一阵晕眩。为了让你往后的日子不被嫌弃，现在自己必须抓紧时间沉下来。</p>
<p>编程时间越久，越觉得需要回头看，啃基础。写业务的时间再久，天花板的高度也不会被你撑高。</p>
<p>业务的编码，为我带来的一些成长是：如何更好的代码复用；如何将具体的业务进行拆分成代码模块；如何组织项目的结构，方便快速开发与维护；如何进行日常的运维；如何配置相关的系统、环境等等。</p>
<p>那么这些技巧学会之后，该如何往深入走？特别是当前云技术的发展，让很多基础的运维工作变得相当简单。如果仅仅是掌握了基础的编码工作，随着时间的增长，5年、10年程序员的竞争力如何体现？每当想起这些，不能不让人焦虑。</p>
<p>但是过份的焦虑，会让人丧失学习能力。我们需要在认识到自己局限的同时，脚踏实地的耕耘自己这一方水土。不要想着速成，现在知识付费很流行，但是你花钱买别人嚼过的东西，提高不了自己。问渠那得清如许？为有源头活水来。特别是做为程序员我觉得更应该自己去研究、去尝试、去思考。<br>社会并不会嫌弃变老变慢的程序员，而是会嫌弃哪些年龄变老了，技能却依然没有变化的人。</p>
<h1 id="程序员"><a href="#程序员" class="headerlink" title="程序员"></a>程序员</h1><p>当别人问我的职业时，我会骄傲的说：程序员。可是仔细想想感觉自己不是程序员。为什么？并不是仅仅因为月薪没上5万，而是：</p>
<blockquote>
<p>程序 = 数据结构 + 算法</p>
</blockquote>
<p>我在想我写的代码中，哪些包含了数据结构，哪些又包含了算法呢？都不好意思继续往下想了，我一定是个假的程序员。</p>
<p>为了让自己成为一个真正的程序员，不是薪水上而是能力上的。需要改变自己的学习、工作策略。多去学习需要不断练习与思考的技能，特别是需要思考的东西。因为大部分人不愿意思考，多思考一份就比别人多一份优势。将重复性的工作最大程度自动化，不要浪费自己宝贵的时间。</p>
<h1 id="学习，需要先找到目标"><a href="#学习，需要先找到目标" class="headerlink" title="学习，需要先找到目标"></a>学习，需要先找到目标</h1><p>学习需要具有目标性，要不然就是芝麻西瓜都在捡。当前很多公司都在强调全栈工程师，但是根据个人发现，真正的全栈一定是某个方面很牛，其它方面则比较平均。而很多公司要全栈的原因（特别是小公司），仅仅是为了要一个什么都能够做点的工程师，让你今天做做h5，明天搞搞小程序，后天再写个api。</p>
<p>上面的情况不会让你发展成为全栈，会让你发展成为三不像，没有自己的核心能力区。现在的技术不管是前端还是后端，都变得越来越细致，都需要投入大量的时间才可能成为专家。</p>
<p>你是想在某个领域成为专家，还是成为爱好者，会让结果千差万别。在开始前，先定位自己当前所处位置以及目标。找出二者之间的差距进行弥补。</p>
<p>我一边觉得庆幸自己在现在意识到了这一切，另一方面又对自己以前的种种无知表示后悔。知识应该由点极面的逐步展开。用php来讲，我肯定第一步是写好php代码，学好面向对象与设计模式，这一部分工作在业务阶段可以很好掌握，那么之后php相关的性能问题、扩展开发问题就需要逐步去深入了解，这就需要去学数据结构、算法、c语言等等知识。这是由php带来的深入方向，对于横向的，就需要去了解linux、mysql、nginx相关的知识点。这样一步步下来完成自己的深度与广度。</p>
<p><strong>好的知识与技能都不可能短时间学成。让自己变得具有专业性、稀缺性很重要。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[飞跃绝境长城]]></title>
      <url>https://helei112g.github.io/2017/09/13/%E9%A3%9E%E8%B7%83%E7%BB%9D%E5%A2%83%E9%95%BF%E5%9F%8E/</url>
      <content type="html"><![CDATA[<p>首发微信公众号，结果被删除了。所以博客还是得坚持<br><a id="more"></a></p>
<p>《冰与火之歌》中有一道绝境长成保护着七国子民。我们也有一道绝境长成，给我们打造良好健康的信息环境。</p>
<p>不过我们程序员想用github快一点，google查询资料全一点，怎么破？我今天将把走出绝境长成的地图交给你们。</p>
<blockquote>
<p>记得收藏保存，万一被删了呢。</p>
</blockquote>
<h1 id="免费方案"><a href="#免费方案" class="headerlink" title="免费方案"></a>免费方案</h1><p>用的最多的就是蓝灯，下载地址：<a href="https://github.com/getlantern/forum" target="_blank" rel="external">https://github.com/getlantern/forum</a></p>
<p>另外还有个集合大全：<a href="https://github.com/bannedbook/fanqiang/wiki" target="_blank" rel="external">https://github.com/bannedbook/fanqiang/wiki</a></p>
<p>下面开始我要开始进行openvpn的翻墙技术交流了，通过 openvpn 实现的穿越长城。</p>
<h1 id="OpenVPN"><a href="#OpenVPN" class="headerlink" title="OpenVPN"></a>OpenVPN</h1><blockquote>
<p>OpenVPN 是一个用于创建虚拟专用网络加密通道的软件包，最早由James Yonan编写。OpenVPN允许创建的VPN使用公开密钥、电子证书、或者用户名／密码来进行身份验证。</p>
<p>它大量使用了OpenSSL加密库中的SSLv3/TLSv1协议函数库。</p>
</blockquote>
<p>OpenVPN 实现翻墙的原理是它虚拟了一张网卡，客户端所有的请求通过这张网卡的包装进行重新的请求与接受。从而完成翻墙。下面来看具体的操作。</p>
<h2 id="安装-OpenVPN"><a href="#安装-OpenVPN" class="headerlink" title="安装 OpenVPN"></a>安装 OpenVPN</h2><p>为了详细说明每一个软件的安装原因，我将会按照依次顺序进行，每一个可能的错误尽可能展示。</p>
<p>安装的环境:</p>
<ul>
<li>CentOS: 6.8 64位</li>
<li>1核  1G内存</li>
<li>服务器位置：香港</li>
</ul>
<p><strong>下载：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://swupdate.openvpn.org/community/releases/openvpn-2.4.3.tar.gz</span><br></pre></td></tr></table></figure></p>
<p><strong>解压：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf openvpn-2.4.3.tar.gz &amp;&amp; cd openvpn-2.4.3</span><br></pre></td></tr></table></figure></p>
<p><strong>生成Makefile，为编译做准备：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/openvpn</span><br></pre></td></tr></table></figure></p>
<p>第一个报错：</p>
<blockquote>
<p>checking for SSL_CTX_new… no</p>
<p>configure: error: openssl check failed</p>
</blockquote>
<p><strong>错误原因：</strong> 没有 <code>openssl</code> 服务，安装： <code>yum install openssl openssl-devel -y</code></p>
<p>第二次执行： <code>./configure --prefix=/usr/local/openvpn</code></p>
<p>第二个报错：</p>
<blockquote>
<p>configure: error: lzo enabled but missing</p>
</blockquote>
<p>因为 openvpn 会用到 <code>lzo</code> 压缩算法。安装：<code>yum install lzo lzo-devel -y</code></p>
<p>第三次执行：<code>./configure --prefix=/usr/local/openvpn</code></p>
<p>第三个报错：</p>
<blockquote>
<p>configure: error: libpam required but missing</p>
</blockquote>
<p>根据提示安装 <code>yum install pam pam-devel -y</code></p>
<p>再次执行：<code>./configure --prefix=/usr/local/openvpn</code></p>
<p>成功运行，生成了编译需要的 Makefile，进行编译安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p><strong>备注：在安装 openall lzo pam 的时候，我们同时安装了 *-devel 包。该包是开发库，一般编译软件的时候都需要。大家也可以试试看不安装是否报错，报错的时候在装上去</strong></p>
<h2 id="加密证书生成"><a href="#加密证书生成" class="headerlink" title="加密证书生成"></a>加密证书生成</h2><p>为了确保数据交互的安全，在客户端与服务端交互时，需要进行加密，签名等操作。在进行这一步前我们需要生成供客户端、服务端使用的相关证书。证书生成工具 <code>easy-rsa</code></p>
<p><strong>准备工作</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/OpenVPN/easy-rsa.git</span><br><span class="line">cd /easy-rsa/easyrsa3/</span><br><span class="line">cp vars.example vars</span><br></pre></td></tr></table></figure></p>
<p>然后修改以下信息，主要是跟自己组织相关的信息，自己随意改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim vars</span><br><span class="line"></span><br><span class="line">// 这些组织信息，根据自己的实际情况进行修改</span><br><span class="line">set_var EASYRSA_REQ_COUNTRY     &quot;CN&quot;</span><br><span class="line">set_var EASYRSA_REQ_PROVINCE    &quot;Beijing&quot;</span><br><span class="line">set_var EASYRSA_REQ_CITY        &quot;Zhao Yang&quot;</span><br><span class="line">set_var EASYRSA_REQ_ORG &quot;Ai Zhong Guo&quot;</span><br><span class="line">set_var EASYRSA_REQ_EMAIL       &quot;foo@aiguo.com&quot;</span><br><span class="line">set_var EASYRSA_REQ_OU          &quot;aiguo Openvpn&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>创建 ca 证书</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa init-pki</span><br><span class="line">./easyrsa build-ca</span><br></pre></td></tr></table></figure></p>
<p>这个过程需要输入密码，与 ca 证书的名称； 请记住这个密码，后面签名服务端与客户端密钥的时候需要。<br>假设我这里是：</p>
<ul>
<li>名称: aiguoca</li>
<li>密码：123456</li>
</ul>
<p><strong>创建服务端证书</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa gen-req server-aiguo nopass</span><br></pre></td></tr></table></figure></p>
<p>又需要一个名字，不能跟之前的ca冲突: aiguoserver</p>
<p>对服务端证书签名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa sign server server-aliguo</span><br></pre></td></tr></table></figure></p>
<p>根据提示输入：<code>yes</code>  以及ca证书的密码：<code>123456</code></p>
<p><strong>创建Diffie-Hellman证书</strong></p>
<blockquote>
<p>该证书主要作用是确保共享KEY安全穿越不安全网络</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa gen-dh</span><br></pre></td></tr></table></figure>
<p>这一步时间有点久。可以倒杯水在过来继续</p>
<p><strong>创建客户端证书</strong><br>有的教程这里又 init 了一个 pki环境。其实完全没有必要。直接继续在原先的基础上继续即可。</p>
<p>跟着我的姿势继续往下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa gen-req client-aiguo nopass</span><br></pre></td></tr></table></figure></p>
<p>客户端创建证书的命令是不是跟服务端创建命令很像？仅仅是取了个不同名字。当然名字还是不要跟上面用过的名字冲突就好: aiguoclient</p>
<p>紧接着对它签名，步骤跟服务端一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa sign client client-ssl</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意呃,签名的 sign 后面 server 换成了 client 。也正是基于此，才能够知晓那个是服务端证书，那个是客户端证书。签名过程中还是需要输入 <code>yes</code> 以及ca证书的密码 <code>123456</code>。</p>
<p>至此证书生成完毕。现在开始相关配置。</p>
<h1 id="OpenVPN-服务端配置"><a href="#OpenVPN-服务端配置" class="headerlink" title="OpenVPN 服务端配置"></a>OpenVPN 服务端配置</h1><p>准备工作已经搞定，现在来做服务端的配置，以及让他运行起来。</p>
<p>由于我们是通过编译安装的，在 /etc/ 下面并没有 openvpn 这个目录。手动创建该目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/openvpn/</span><br></pre></td></tr></table></figure></p>
<p>拷贝 <code>openvpn</code> 提供的样板配置文件进去<br><code>cp sample-config-files/server.conf /etc/openvpn/</code></p>
<p>然后把服务端需要的证书，也全部拷贝进去<br><code>cp pki/ca.crt pki/issued/server-aiguo.crt pki/private/server-aiguo.key pki/dh.pemy /etc/openvpn/</code><br>这里千万不要选错了目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ll /etc/openvpn/ </span><br><span class="line"></span><br><span class="line"># 完成后，该目录有以下文件</span><br><span class="line">-rw------- 1 root root  1159 Sep  7 13:27 ca.crt</span><br><span class="line">-rw-r--r-- 1 root root 10782 Sep  7 13:25 server.conf</span><br><span class="line">-rw------- 1 root root  4547 Sep  7 13:27 server-aiguo.crt</span><br><span class="line">-rw------- 1 root root  1708 Sep  7 13:27 server-aiguo.key</span><br></pre></td></tr></table></figure>
<p><strong>server.conf 文件的配置</strong></p>
<p>该文件配置项含义中文翻译，看这里： <a href="https://my.oschina.net/liucao/blog/863112" target="_blank" rel="external">https://my.oschina.net/liucao/blog/863112</a></p>
<p>这里只讲诉几个关键配置。其他未说明的默认即可。<br>首先修改协议，建议使用 <code>tcp</code> 协议。网络上讲 <code>udp</code> 在高延时的情况下会存在很多丢包现象。</p>
<p>配置证书路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ca /etc/openvpn/ca.crt</span><br><span class="line">cert /etc/openvpn/server-ssl.crt</span><br><span class="line">key /etc/openvpn/server-ssl.key</span><br><span class="line">dh /etc/openvpn/dh.pem</span><br></pre></td></tr></table></figure></p>
<p>这里的文件路径，自己根据实际情况调整</p>
<p>注释掉： ;tls-auth ta.key 0 。因为我们并没有生存该key文件。</p>
<p>打开 comp-lzo 压缩</p>
<p>日志开启到 verb 6 ，方便后续调试</p>
<p>;explicit-exit-notify 1  注释掉，仅有 udp 才可使用</p>
<p>设置dns<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push &quot;dhcp-option DNS 8.8.8.8&quot;</span><br><span class="line">push &quot;dhcp-option DNS 8.8.4.4&quot;</span><br></pre></td></tr></table></figure></p>
<p>打开 <code>duplicate-cn</code> 项，默认是关闭状态。</p>
<p>注释 <code>explicit-exit-notify 1</code> 默认是关闭。</p>
<p>到这一步，配置全部完成。保存退出。</p>
<p><strong>启动服务端</strong></p>
<p>先检查一下，可以在前台运行 openvpn 服务，检查错误以及调试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/openvpn/sbin/openvpn --config /etc/openvpn/server.conf</span><br></pre></td></tr></table></figure></p>
<p>以守护进行运行的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/openvpn/sbin/openvpn --daemon --config /etc/openvpn/server.conf</span><br></pre></td></tr></table></figure></p>
<p>这里两个命令的使用，是因为以下原因：</p>
<ul>
<li>本教程安装路径是 /usr/local/openvpn</li>
<li>本教程配置都是放在 /etc/openvpn 中。</li>
</ul>
<p>情况不同者，根据实际情况设置即可</p>
<h1 id="防火墙与路由转发"><a href="#防火墙与路由转发" class="headerlink" title="防火墙与路由转发"></a>防火墙与路由转发</h1><p><strong>！！！如果你用的是 CentOS7 以上的操作系统，下面部分不适合你</strong></p>
<p>首先关闭SELinux：<code>SELINUX=disabled</code></p>
<p>配置防火墙，准许 <code>1194</code> 端口通过，如果你修改了默认端口，这里记得修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 1194 -m comment --comment &quot;openvpn&quot; -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>允许vpn客户端所在网段流量转发到其它网卡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I FORWARD -s 10.8.0.0/24 -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>将 vpn 流量转到eth0网卡上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j  MASQUERADE</span><br></pre></td></tr></table></figure></p>
<p>保存配置结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/iptables save</span><br></pre></td></tr></table></figure></p>
<p>开启路由转发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &apos;/net.ipv4.ip_forward/s/0/1/&apos; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>sysctl -p 是查看修改后的结果，如果你看到 net.ipv4.ip_forward = 1 ，说明配置正确</p>
</blockquote>
<p>至此，服务器上的事情，全部搞定。下面列举一个android手机客户端的配置。其它端也是大同小异。</p>
<h1 id="客户端-Android-的配置"><a href="#客户端-Android-的配置" class="headerlink" title="客户端 Android 的配置"></a>客户端 Android 的配置</h1><p>当我们有了服务端，它已经可以进行工作了，如果再有一个客户端，那就能够天下我有了。这里就仅以android为代表说明一下客户端配置，其它端大同小异。</p>
<p><strong>下载开源的android客户端</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://f-droid.org/repo/de.blinkt.openvpn_153.apk</span><br></pre></td></tr></table></figure></p>
<p>客户端的主要作用，就是用来连接上我们的服务器。</p>
<p>将服务器上面的客户端证书拷贝到本地，我选用的是scp。任何能够完成该项任务的手段都可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp root@192.168.11.11:/home/easy-rsa/easyrsa3/pki/private/client-aiguo.key ./</span><br><span class="line">scp root@192.168.11.11:/home/easy-rsa/easyrsa3/pki/issued/client-aiguo.key ./</span><br><span class="line">scp root@192.168.11.11:/home/easy-rsa/easyrsa3/pki/ca.crt ./</span><br></pre></td></tr></table></figure></p>
<p>唯一需要注意的是，不要搞错了文件路径，这个路径根据每个人设置是不同的，不要完全进行拷贝。</p>
<p>在完成上面步骤后，可以通过qq或者手机助手之类的，将文件发送到自己的手机，请记得文件路径位置。下面会用到。</p>
<p>打开客户端app，新建一个配置文件。名字任意取（最好别用中文）。下面开始说需要配置的项目，未提到的项目默认即可，不需要设置。</p>
<h2 id="BASIC-项目配置"><a href="#BASIC-项目配置" class="headerlink" title="BASIC 项目配置"></a>BASIC 项目配置</h2><p><img src="http://ol59nqr1i.bkt.clouddn.com/vpn-basic.png" alt="image"></p>
<p>注意图中标红的地方。类型一定要选择 <strong>用户名／密码 + 证书</strong> 的类型。</p>
<ul>
<li>ca证书 找到刚刚拷贝到手机上的 <code>ca.crt</code> 文件</li>
<li>客户端证书 找到刚刚拷贝到手机上的 <code>client-aiguo.crt</code> 文件</li>
<li>客户端证书密钥 找到刚刚拷贝到手机上的 <code>client-aiguo.crt</code> 文件</li>
</ul>
<p>另外，这里一定要启用 lzo 压缩算法。</p>
<p>在底部的用户与密钥。用户随便填写接口，密码留空（在本教程中，我们没有为用户分配用户名与密码，因此可以这样操作）</p>
<h2 id="服务器列表-项目配置"><a href="#服务器列表-项目配置" class="headerlink" title="服务器列表 项目配置"></a>服务器列表 项目配置</h2><p><img src="http://ol59nqr1i.bkt.clouddn.com/vpn-serlist.png" alt="image"></p>
<p>这一比较简单，主要就是两个配置。其一是：<br>服务器的地址，填写你购买的服务器外网地址。端口如果没有修改过，请默认</p>
<p>其二是将协议修改为：tcp</p>
<h2 id="AUTHENTICATION-ENCRYPTION-项目配置"><a href="#AUTHENTICATION-ENCRYPTION-项目配置" class="headerlink" title="AUTHENTICATION/ENCRYPTION 项目配置"></a>AUTHENTICATION/ENCRYPTION 项目配置</h2><p>该项配置很简单，将默认所有打勾的选项，全部取消即可。</p>
<hr>
<p>至此，配置全部完成，篇幅虽然长，但是并没有什么难点。现在可以回到首页，你会看到刚配置的文件名称，点击它即可连接。</p>
<p>本教程的目的仅仅是技术交流，希望大家翻跃长城后技术实力更上一层楼。</p>
<hr>
<p>如果你对我的内容感兴趣，请关注我的微信公众号：</p>
<p>公众号：<code>icanfo</code></p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
<p>GitHub：<a href="https://github.com/helei112g" target="_blank" rel="external">https://github.com/helei112g</a></p>
<p><strong>我在github开源了支付宝支付、微信支付、招商一网通支付的php sdk。希望能够帮助你提升项目开发的效率。<a href="https://github.com/helei112g/payment" target="_blank" rel="external">项目地址</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP中static与yield关键字的思考]]></title>
      <url>https://helei112g.github.io/2017/09/10/PHP%E4%B8%ADstatic%E4%B8%8Eyield%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>语言的本身，远远重要于其它。<br><a id="more"></a></p>
<p>你以为你知道了一切，只是你以为而已。知识的美妙就在于，一生的时光在它面前显得多么的短暂。</p>
<p>嗯嗯，扯远了，我今天只想说说：<strong>static</strong> 与 <strong>yield</strong>。</p>
<p>先来说说 <code>static</code> 关键字。本篇只讲静态方法的使用与后期绑定的知识点。</p>
<h1 id="static-什么时候用来修饰方法"><a href="#static-什么时候用来修饰方法" class="headerlink" title="static 什么时候用来修饰方法"></a>static 什么时候用来修饰方法</h1><p><code>static</code> 关键字大家都知道是用来修饰方法与属性的。 那么大家在项目中会在哪些场景下使用它？</p>
<p>我遇到过几个项目，要求所有的方法全部 <code>static</code> 化，当然控制器方法不能这么干。原因之一就是：静态方法执行效率高？那么我们基于此来分析一下。</p>
<p>首先执行效率高我是没有意见的。哪么是不是因为它效率高，就该毫无节制的使用在项目中？讨论这个问题先来回顾下编程语言的历史。在早一点的时候，还没有面向对象，采用的都是结构化编程，当时基本上所有的方法都是 <strong>静态方法</strong>，然后有了面向对象，产生了实例化的概念。</p>
<p>从上面简短的发展过程可以看出，如果仅仅为了性能，哪么面向对象好像没有存在的必要。那么这些大师为了要在 <code>c++</code> <code>java</code> 这些语言中引入面向对象、引入实例化的感念呢？我觉得是因为伴随发展，项目越来越大，需要更好的组织代码方式与编程思维。</p>
<p>再回过头来看 <code>static</code> ，它定义的静态方法，效率确实高，但是会持续占用内存，只有在程序退出时才结束生命周期，期间无法进行销毁等副作用是其一；其二从设计模式上来说，它具有强耦合性，外部可修改 static 属性；其三static定义的方法没有办法override来重写，ioc di等概念无用武之地；其四在进行单元测试时，静态方法让人头痛。</p>
<p>那么通过上面所说，感觉以后还是别用 <strong>static</strong> 方法了，老老实实的实例化然后调用方法？咱们得理性，不能极端到什么地方都用，也不能一丁点都不用。一句话：学会面向对象的方式来思考。我们写代码的第一考虑点我觉得是：可扩展性（应对业务快速变化），可维护性（线上问题及时修复）。高效率应该是最后再来考虑（因为优化效率的手段非常之多，并不一定非要给每个方法加个: static）。如果从面向对象的角度出发，这个方法完全独立跟类属性无关，那么就用 <strong>static</strong> 吧。</p>
<p>总之是站在面向对象的角度，软件设计的层次来考虑语法的使用，而不是为了效率破坏掉代码的美。</p>
<h1 id="static-后期静态绑定"><a href="#static-后期静态绑定" class="headerlink" title="static 后期静态绑定"></a>static 后期静态绑定</h1><p>这一点php的文档做了详细的介绍，但是我以前一直很少关注这个地方，基本上都是使用 <code>self::</code> 的方式进行静态方法与属性的调用。</p>
<p>我觉得后期绑定某种程度上，像是静态方法的重载。这里贴出 php 文档中的例子来进行一下讲述<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>::who();</span><br><span class="line">        <span class="keyword">static</span>::who();<span class="comment">// 后期静态绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test();</span><br></pre></td></tr></table></figure></p>
<p>如果是 <code>self::who()</code> 调用，会输出：<strong>A</strong>。如果是 <code>static::who()</code> 会输出 <strong>B</strong></p>
<p>这样来看，是不是相当于 class B重写了父类 A 的 <code>who()</code> 方法？那么如果灵活使用这个特性，可以让 static 具备更强的灵活性。充分发挥其性能优势，又能解决扩展性差的问题。当然还是一样，要从面向对象的角度出发，一切适可而止。</p>
<h1 id="PHP-中-yield-的使用场景"><a href="#PHP-中-yield-的使用场景" class="headerlink" title="PHP 中 yield 的使用场景"></a>PHP 中 yield 的使用场景</h1><p>说实话，很长一段时间我并不知道 <code>php</code> 还有这么个语法。直到有一天我在 js 中遇到了这个关键字，感觉这么不明觉厉的东西，世界上最好的语言怎么没有？回头看文档，真有，不愧为世界上最好的语言。</p>
<p>那么 <strong>yield</strong> 的使用场景是什么？刚好最近有人 sg 上面问道我，借此整理一下。希望大家能够将它更多的结合自己的业务进行使用。这里不会进行 <code>yield</code> 与 <code>Iterator</code> 的比较。相信看完后，你能够明了二者的谁更简介。</p>
<p>先说它的使用场景，还是得先回顾历史，在没有 yield 之前，我们要生成一个数组，只能一次性把所有内容全部读入内存（当然也可以通过实现 <code>Iterator</code>接口实现一个迭代）。有了 <code>yield</code> 之后，我们可以通过一个简单的 <code>yield</code> 关键字，完成一个数组的生成，并且是用到的时候才会产生值，相对而言内存占用肯定会下降。空口无凭，咱们下面通过代码实际检验一下上面的结论。</p>
<p><strong>先来看普通模式</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateData</span><span class="params">($max)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    $arr = [];</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt;= $max; $i++) &#123;</span><br><span class="line">        $arr[] = $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'开始前内存占用：'</span> . memory_get_usage() . PHP_EOL;</span><br><span class="line">$data = generateData(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'生成完数组后内存占用：'</span> . memory_get_usage() . PHP_EOL;</span><br><span class="line"><span class="keyword">unset</span>($data);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'释放后的内存占用：'</span> . memory_get_usage() . PHP_EOL;</span><br></pre></td></tr></table></figure></p>
<p>运行得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始前内存占用：231528</span><br><span class="line">生成完数组后内存占用：231712</span><br><span class="line">释放后的内存占用：231576</span><br></pre></td></tr></table></figure></p>
<p>前后的差值是：<strong>184</strong></p>
<hr>
<p><strong>使用yield后的效果</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateData</span><span class="params">($max)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt;= $max; $i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> $i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'开始前内存占用：'</span> . memory_get_usage() . PHP_EOL;</span><br><span class="line">$data = generateData(<span class="number">100000</span>);<span class="comment">// 这里实际上得到的是一个迭代器</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'生成完数组后内存占用：'</span> . memory_get_usage() . PHP_EOL;</span><br><span class="line"><span class="keyword">unset</span>($data);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'释放后的内存占用：'</span> . memory_get_usage() . PHP_EOL;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始前内存占用：228968</span><br><span class="line">生成完数组后内存占用：229824</span><br><span class="line">释放后的内存占用：229016</span><br></pre></td></tr></table></figure></p>
<p>前后的差值是：<strong>856</strong></p>
<p>奇怪，使用了 <strong>yield</strong> 后，内存占用反而上升了，这是什么鬼？别急。上面我们参数传入的是 <strong>1,000,00</strong>，我现在将传入参数改成改成 <strong>1,000,000</strong>试试。</p>
<p>第一个方法得到的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始前内存占用：231528</span><br><span class="line"></span><br><span class="line">Fatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 32 bytes) in /test/yield.php on line 6</span><br></pre></td></tr></table></figure></p>
<p>看了吧，一百万次的循环时，一次性载入内存，超出了限制。那么再来看 yield 的执行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始前内存占用：228968</span><br><span class="line">生成完数组后内存占用：229824</span><br><span class="line">释放后的内存占用：229016</span><br></pre></td></tr></table></figure></p>
<p>前后的差值依然是：<strong>856</strong></p>
<p>好了到这里，应该看出来了，<strong>yield</strong>无论数组大小，占用均是 <strong>856</strong> ，这是因为它自身，它在你进行迭代的时候才会产生真实数据。</p>
<p>所以如果你的数据来源非常大，那么用 yield 吧。如果数据来源很小，当然选择一次载入内存。</p>
<hr>
<p>如果你对我的内容感兴趣，请关注我的微信公众号：</p>
<p>公众号：<code>icanfo</code></p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
<p>GitHub：<a href="https://github.com/helei112g" target="_blank" rel="external">https://github.com/helei112g</a></p>
<p><strong>我在github开源了支付宝支付、微信支付、招商一网通支付的php sdk。希望能够帮助你提升项目开发的效率。<a href="https://github.com/helei112g/payment" target="_blank" rel="external">项目地址</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Web开发中说高并发的时候，我们在说什么]]></title>
      <url>https://helei112g.github.io/2017/08/25/Web%E5%BC%80%E5%8F%91%E4%B8%AD%E8%AF%B4%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<p>概念背后的实质，才值得我们真正去畅谈与思考。<br><a id="more"></a></p>
<p>这并不是一个回答的问题的文章，而是由此引发的一个思考。</p>
<p><strong>大家心里仔细想想，当你们听到高并发网站时，心里对这个网站是个什么概念？首先想到的是淘宝吗？带着问题，我们一起思考技术</strong></p>
<p>写这个话题是因为我对搜索引擎给我的答案很不满意，然后决定把思考的一些东西分享出来，希望可以大家彼此讨论下。</p>
<p>我们经常在面试的时候，被问到有没有高并发的经验？先不说哪些考高并发的公司（我觉得很多时候是面试官想装逼）。我思考的是什么才算是高并发？你一天几个pv肯定高不了。首先在网上查找一下，并未找到明确的标准定义。那么什么是并发呢？</p>
<blockquote>
<p>并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p>
</blockquote>
<p><em>摘自百度百科</em></p>
<h1 id="我们说的高并发是什么？"><a href="#我们说的高并发是什么？" class="headerlink" title="我们说的高并发是什么？"></a>我们说的高并发是什么？</h1><p>上面的定义明显不是我们通常所言的并发，在互联网时代，所讲的并发、高并发，通常是指并发访问。也就是在某个时间点，有多少个访问同时到来。</p>
<p>我看到有人给高并发下了类似的定义：</p>
<blockquote>
<p>高并发通常是指我们提供的系统服务能够同时并行处理很多请求。</p>
</blockquote>
<p>来看看这个定义，这里首先把并发给混淆到并行了。关于<a href="https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/" target="_blank" rel="external">并发并行的区别看这里</a>，我就不多说，继续探讨并发。</p>
<p>然后定义又说很多请求？什么叫很多请求？做为中国人，这个词让我想象力一发不可收拾……好了，拉回来，继续本文。</p>
<p>那么从上面的分析，可以看出来高并发在网络上业界也没有明确的定义。但根据我搜索情况，一般都是pv在千万级别以上的公司才会涉及到这个概念。所以我得出一个自定义概念：如果某个系统的日pv在千万级别以上，他就可能是一个高并发的系统。</p>
<p>为什么说是可能？那是因为有的公司完全不走技术路线，全靠机器堆，这不在我们的讨论范围。</p>
<h1 id="高并发的问题，我们具体该关心什么？"><a href="#高并发的问题，我们具体该关心什么？" class="headerlink" title="高并发的问题，我们具体该关心什么？"></a>高并发的问题，我们具体该关心什么？</h1><p>讲真话，高并发是个比较抽象的概念。很难有一个统一的可衡量的标准。哪么有一些其它维度的标准指标来衡量系统的性能吗？搬出以前计算机课程里边的一些指标来跟大家聊聊。</p>
<p>先声明几个概念，别打瞌睡。</p>
<ul>
<li>QPS（TPS）：每秒钟 request/事务 数量，在互联网领域，指每秒响应请求数（指http请求）；</li>
<li>吞吐量：单位时间内处理的请求数量（通常由QPS与并发数决定）；</li>
<li>响应时间：系统对一个请求做出响应的平均时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间（我认为这里应该仅包含处理时间，网络传输时间忽略）。</li>
</ul>
<p><strong>这里一定要注意呃，QPS ≠ 并发数</strong></p>
<p>并发是指，某个时刻有多少个访问同时到来。QPS是指秒钟响应的请求数量。那么这里就肯容易推算出一个公式：</p>
<p>QPS = 并发数 / 平均响应时间</p>
<p>后面我们的分析都是围绕这个公示来进行展开，没明白的再回味一下。</p>
<p>现在我们来假设一个场景：既然QPS是每秒钟处理的http请求数量。那么1s = 1000ms。假设我们当前一个http请求服务器处理完成需要100ms（即那么 <strong>平均响应时间 = 100ms </strong>）。那么它1s钟可以处理10个请求。也就是说 <strong>qps = 10</strong>。推算出 <strong>并发数 = 10</strong></p>
<p>常常我们被问到高并发的问题，其实从某种程度上来说是怎么提高现有程序的性能。现在我们基于上面的假设，来进行分析。假设现在有个系统性能上就是我们上面的假设，它每天有 300万pv，运行在单机上（当然经常宕机），按照上面的系统性能数据，给出优化解决方案。</p>
<h1 id="提高并发能力"><a href="#提高并发能力" class="headerlink" title="提高并发能力"></a>提高并发能力</h1><p>通过上面的分析，要提升并发能力，我们就需要提升我们的qps（<em>其实这里并不完全正确，为了说明问题，我们先放弃一部分正确性</em>）</p>
<p>最快速解决方案，就是增加机器。我们根据以上情况来实际计算一下。</p>
<ul>
<li>访问量：200w pv</li>
<li>QPS：10</li>
</ul>
<p>根据日常经验，80% 的访问量集中在 20%的时间，算一下这 200w pv实际需要机器达到多少qps才能满足。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qps = (200w * 0.8) / (24 * 3600 * 0.3)</span><br><span class="line"></span><br><span class="line">qps = 61.7</span><br></pre></td></tr></table></figure>
<p>实际上如果在单机上，要求我们每秒钟处理请求必须达到 61.7 以上才行，而实际上我们当前系统的qps是 <code>10</code>。那么怎么解决？</p>
<p><strong>方案一：上机器</strong></p>
<p>个人的能力是有限的，团队的力量是无穷的。既然一台机器搞不定，我们就多上几台机器。这就涉及到db主从、读写分离、负载均衡等技术。</p>
<p>它的原理就是分流，把以前集中的压力分散开来。改方案见效快，灵活，实践起来也更快。</p>
<p><strong>方案二：增加单机性能</strong></p>
<p>单机到底性能能够增加到一个什么程度，这取决于你的机器配置，也取决于你的服务到底有多复杂。</p>
<blockquote>
<p>ps： 写到这里突然有点能够理解为什网上对高并发都是讲很多请求，没有具体数据了，因为这真的只能针对业务来讲，100个并发对静态网页来说根本没有的事儿，但是对于某些密集计算型的估计…</p>
</blockquote>
<p>那么常见的单机如何提升性能？比如：增加不常变化数据的缓存，开启php的opcache，优化代码（如：n+1问题、多重嵌套循环、深层递归等），db表优化等等。由于这些每一个点拿出来都够写一本书了。咋就不继续下去。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于笔者自己也是没有实际经历过kw级别pv场景，很多东西讲的不一定对，本文也是理清自己的一点思路。希望能够与更多朋友进行讨论。</p>
<p>也希望本文能够解决你的一点疑惑，让我们能够从高大上的概念落实到实际问题中去。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/" target="_blank" rel="external">并发和并行的区别</a></li>
<li><a href="http://www.ha97.com/5095.html" target="_blank" rel="external">系统性能测试想个概念</a></li>
</ul>
<hr>
<p>如果你对我的内容感兴趣，请关注我的微信公众号：</p>
<p>公众号：<code>icanfo</code></p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
<p>GitHub：<a href="https://github.com/helei112g" target="_blank" rel="external">https://github.com/helei112g</a></p>
<p><strong>我在github开源了支付宝支付、微信支付、招商一网通支付的php sdk。希望能够帮助你提升项目开发的效率。<a href="https://github.com/helei112g/payment" target="_blank" rel="external">项目地址</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP后端该如何组织项目结构]]></title>
      <url>https://helei112g.github.io/2017/08/07/PHP%E5%90%8E%E7%AB%AF%E8%AF%A5%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>全栈系列后端项目结构的思考，不夸夸其谈，只想写好代码。<br><a id="more"></a></p>
<p>这是 <strong>后端开发者从零做一个移动应用</strong> 的后端部分第二篇。介绍下一个新项目，后端该如何从零去搭建。我们先假设这个项目由两部组成</p>
<ul>
<li>提供给wap站点、app使用的api；</li>
<li>提供给运营人员使用的管理后台。</li>
</ul>
<p>整个项目采用 Phalcon，项目的demo可以 <a href="https://github.com/helei112g/x-api" target="_blank" rel="external">点这里</a> 参阅</p>
<p><em>备注：跟随文章进度，项目持续更新，最后会与配套的wap app形成一个整体</em></p>
<p>项目最终至少会包含以下内容：</p>
<ul>
<li>小米消息推送</li>
<li>支付集成（支付宝、招商、微信）</li>
<li>基于 Codeception 的api测试</li>
<li>登陆api（这部分采用oauth2，会基于 ‘bshaffer/oauth2-server-php’ 做）</li>
</ul>
<h1 id="项目结构回顾"><a href="#项目结构回顾" class="headerlink" title="项目结构回顾"></a>项目结构回顾</h1><p>后端系统一般都是采用 MVC 结构（这里均以PHP为例），M 代表模型，V 代表视图，C 代表控制器。我在啰嗦几句</p>
<blockquote>
<p>Model指的是数据模型，这个数据模型包括你的Mysql中的表结构，或者redis的缓存对象结构都可以。它代表一个数据操作单元。</p>
<p>View指的展示给用户浏览、直接操作的界面，这个大家都懂，不多说</p>
<p>Controller 控制器，主要是为了隔离 View 与 Model 直接打交道，他做为一个中间人，两头传递小纸条。</p>
</blockquote>
<p>在我过往的项目中，我主要的困惑在于，业务逻辑是放在 C 还是放在 M。</p>
<p>从对象角度出发，业务逻辑无非就是操作数据，要么读取，要么修改，那么应该放在M层，因为一个对象应该有自己的属性与方法。</p>
<h2 id="业务放在M中"><a href="#业务放在M中" class="headerlink" title="业务放在M中"></a>业务放在M中</h2><p>实际工作中我们常常有这样的场景，比如：读取一个游戏列表数据，数据包括游戏的详情以及游戏的版本信息以及下载信息。因为游戏app会存在升级，因此一个游戏会对应多个包。那么这里至少存在两个model</p>
<ul>
<li>游戏详情model，包括游戏的名称，logo等基本信息</li>
<li>游戏的包信息model，包括包所属平台，大小，下载地址，版本信息等</li>
</ul>
<p>那么这个动作的方法应该封装在哪里呢？以前的做法是，分别封装对应的操作到对应的model，然后在控制器中分别调用。说回到这里，游戏model封装了查询游戏列表的method，然后包model封装了根据游戏id查询包信息的method。</p>
<p>然后我们在控制器中分别调用这个两个方法，然后再进行组装，把游戏对应的包设置到对应的游戏中。</p>
<p>那么有一个问题，假设我们在游戏详情这个控制器方法中，需要返回一个相关游戏的集合，难道又重复一次上面的操作？<br><em>有人会说把处理游戏部分抽离成一个公共方法，那么假设是要在新闻详情里边调用呢？这根本不该在同一个控制器里边啊！</em></p>
<h2 id="业务放在C中"><a href="#业务放在C中" class="headerlink" title="业务放在C中"></a>业务放在C中</h2><p>上面我们把方法放在model中遇到了复用的小麻烦，那么继续看看放到controller中会怎样？</p>
<p>这个时候的一个好处是：我们可以使用连接查询，将刚刚的2次查询，通过连接查询1次完成，对于mysql的时间减少了，程序性能提升，然后对查询结果啪啪啪处理完成。</p>
<p>好吧，不往后面说了，相信大家已经发现了，这个查询过程还是不可复用。自然而然的，我们这里应该想到，将它提炼成一个方法，无法满足其他控制器使用（一个控制器调用另外一个控制器的想法想都别想啊）。那么只能提炼成一个类了，这个类来封装所有的业务。</p>
<p>这样之后，任何需要游戏列表数据的地方，直接调用这个GameServer（假设封装的业务逻辑都放在xxxServer中）就可以获得相同的数据，然后如果业务变动，我们也只需要改动这一处，所有地方得到的数据也将会是一致的。</p>
<p>因此通过回顾，我们得出我们的后端项目需要一个server的层次，来存放业务逻辑。</p>
<h2 id="Server层存在的意义"><a href="#Server层存在的意义" class="headerlink" title="Server层存在的意义"></a>Server层存在的意义</h2><p>分离出来的这一层，集中涵盖了所有的业务功能，极大的提高了代码的复用性，除了不同控制器不同方法的直接使用，还包括了不同模块之间的复用。</p>
<p>但是在不同模块之前服用，server层也需要考虑一些额外的东西，比如我们有一个app api模块，有一个后台管理模块。那么都是获取列表数据，可能给app api模块可能不需要某些字段，但是后台管理需要知悉全部内容，以及后台用户权限上的一些问题。这些部分可以继续进行拆分，与server组合。需要结合自己的业务来进行管理。</p>
<p>我个人实践过程中代码的另外一个好处是，server层从某种层度上让C层变得简单，这让团队中的新人能够快速上手接触代码。比如小明是团队新人，那么在他熟悉所使用框架的前提下，他可以立刻在C层开始做事情，因为这里没有业务，有的只是验证客户端传过来的数据，以及对server层的调用返回。通过这个过程可以加速其融入团队的进程。</p>
<h1 id="统一的返回格式"><a href="#统一的返回格式" class="headerlink" title="统一的返回格式"></a>统一的返回格式</h1><p>约定api返回的数据格式，这基本上是系统开发开始的第一步，原先常用的方式就是在每个控制器中通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">return json_encode([</span><br><span class="line">    &apos;msg&apos; =&gt; &apos;ok&apos;,// 携带的信息，可以用来前端 alert 提示用户</span><br><span class="line">    &apos;data&apos; =&gt; [// 具体数据</span><br><span class="line">        ... ...</span><br><span class="line">    ],</span><br><span class="line">    &apos;code&apos; =&gt; &apos;0&apos;, // 0表示成功，其他表示对应错误</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<p>那么这里首先遇到的第一个问题，为了简化前端对类型的判断，基本上所有的字段值，都是返回字符串形式。那么 data 里边的内容就需要在每个控制器中进行处理字符串、utf-8编码等问题。要重复代码，就算你抽离成一个方法，也需要面对该问题。好点的解决方案是在返回数据的拦截器（每一个框架都有类似的概念）内进行统一的处理。</p>
<p>像上面这样的代码写法，带来的额外问题可能有，字段名称打错，比如： code 写成 cdoe ，data 写成 date。为程序代码额外的风险（尤其是bug修复时最容易出现该情况）</p>
<p>那么一种解决办法就该由此想到，采用对象的方式来规范化返回的数据结构。比如我们定义一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class ResultData &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 返回的信息提示</span><br><span class="line">     * @var string $msg</span><br><span class="line">     */</span><br><span class="line">    private $msg;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回的数据结构</span><br><span class="line">     * @var array|object|string</span><br><span class="line">     */</span><br><span class="line">    private $data;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * api 状态码</span><br><span class="line">     * @var int $apiCode</span><br><span class="line">     * @see ApiCode</span><br><span class="line">     */</span><br><span class="line">    private $apiCode;</span><br><span class="line">    </span><br><span class="line">    public function __construct(int $apiCode, string $msg = &apos;ok&apos;, $data = null)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;apiCode = strval($apiCode);</span><br><span class="line">        $this-&gt;msg = trim(strval($msg));</span><br><span class="line">        $this-&gt;data = $data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获取数据结果</span><br><span class="line">     * @return array</span><br><span class="line">     */</span><br><span class="line">    public function getRetData()</span><br><span class="line">    &#123;</span><br><span class="line">        if (! is_array($this-&gt;data) &amp;&amp; is_object($this-&gt;data) &amp;&amp; method_exists($this-&gt;data, &apos;toArray&apos;)) &#123;</span><br><span class="line">            $this-&gt;data = $this-&gt;data-&gt;toArray();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // valueToString 将data的value转化为 string 并且做utf-8转码</span><br><span class="line">        $result = [</span><br><span class="line">            &apos;code&apos; =&gt; $this-&gt;apiCode,</span><br><span class="line">            &apos;msg&apos; =&gt; $this-&gt;msg,</span><br><span class="line">            &apos;data&apos; =&gt; $this-&gt;data ? ArrayUtil::valueToString($this-&gt;data) : [],</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        if (! APP_ENV_PROD) &#123;// 测试环境显示 api 的处理时间信息 方便优化</span><br><span class="line">            $result[&apos;use_time&apos;] = microtime(true) - $_SERVER[&apos;REQUEST_TIME_FLOAT&apos;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了上面这个类，我们所有的服务层或者controller都应该用它作为返回值。然后在拦截器中统一进行json encode即可。这样子即减少了犯错的可能性，同时对统一处理数据的地方做了统一管理集中到 ResultData 中，那么以后有什么特殊变动，调整一处，处处生效。</p>
<h1 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h1><p>另外还有关于 oauth2 如何集成到项目中等等问题，这部分均放到 x-api 项目中进行说明，纸上说来终觉浅嘛。</p>
<p>日志的记录也是系统开发非常重要的部分，这部分没什么太多说的，用规范的格式，存储指定的数据（介质可以是：db、file）。</p>
<p>系统开发中应该拒绝使用 <code>var_dump</code>、<code>echo</code> 这些方式进行调试，另外建议采用：PhpStorm IDE来进行系统开发。</p>
<h1 id="后续分享"><a href="#后续分享" class="headerlink" title="后续分享"></a>后续分享</h1><p>接下来会完善一个 <code>x-api</code> 的基本结构，以及php自动化测试部分文档教程，然后后端部分就告一段落。（本系列的分享主要集中在代码层面，不涉及相关系统部署问题）</p>
<hr>
<p>如果你对我的内容感兴趣，请关注我的微信公众号：</p>
<p>公众号：<code>icanfo</code></p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
<p>个人博客：<a href="https://helei112g.github.io/">https://helei112g.github.io/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[后端开发者从零做一个移动应用（后端篇）]]></title>
      <url>https://helei112g.github.io/2017/07/16/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E4%BB%8E%E9%9B%B6%E5%81%9A%E4%B8%80%E4%B8%AA%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%EF%BC%88%E5%90%8E%E7%AB%AF%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>后端开发，不手摸手，也不嘴对嘴。只想写好代码<br><a id="more"></a></p>
<p>先来上一张前端页面的效果图（Vue + Vux + Vuex + Vue-Router）。<br><img src="http://ol59nqr1i.bkt.clouddn.com/x-app-1.gif" alt="image"></p>
<p><strong> 第一次做gif 没什么经验，太大了。加载慢 </strong></p>
<p>项目地址： <code>http://m.jiasux.com</code>  ，大家可以自行手机打开查看效果。</p>
<hr>
<p>好了，废话少说，来聊聊后端</p>
<p>后端写些什么，什么东西写出来对我是更好的总结，也是对大家更好的帮助？在准备写的时候，我思考了很久。</p>
<p>之前准备了 <code>手摸手，嘴对嘴</code> 教程。想一想这样子没什么意思，如果是一步步做的教程还不如看视频去，就想也许通过总结后端结构（注意是结构不是架构）设计、代码组织、模块划分对大家更有帮助。</p>
<h1 id="后端开发的疑惑"><a href="#后端开发的疑惑" class="headerlink" title="后端开发的疑惑"></a>后端开发的疑惑</h1><p>后端开发最常面对的一个问题：性能、高并发等等。但是这不在本文的讨论范围，我们只讲基本的怎么把代码写好，如何把业务模块划分好。</p>
<p>性能、高并发的解决方案， 大部分是在代码之外的扩展。</p>
<p>那么站在纯粹的 <code>写代码</code> 角度，如何写好后端的代码呢？我以前的疑惑常常有：Controller 层到底放哪些代码？Model 又可以做哪些事情？自己的一些扩展、工具类，该如何组织？</p>
<p><em>发现现在能够想起的疑惑变少了，如果你有什么疑惑，欢迎留言我们一起学习讨论</em></p>
<p>虽然代码主要是实现业务逻辑，但是选择一款好的框架，非常有助于提升团队作业能力，让代码层面的性能无忧。</p>
<h1 id="框架的选择"><a href="#框架的选择" class="headerlink" title="框架的选择"></a>框架的选择</h1><p>说实话，自感 <code>php7</code> 出来后，代码层面的性能，已经到了一个非常高的层度。基本上在百万级别左右的系统，在语言层面没有什么顾虑了。</p>
<p>框架方面，自己用过的php框架包括（时间先后）：<code>ThinkPHP</code> <code>Laravel</code> <code>非著名自造框架</code> <code>Yii</code> <code>Phalcon</code></p>
<p>本文所有代码结构设计与组织设计基于 <code>Phalcon</code> ，其它除了 <code>自造框架</code> 都是非常优秀的框架，不过框架层面的性能，就自身而言，是逐步升高。但是通过一些整合，也可以逐步提升其自身性能，如：<code>Laravel</code> <code>Yii</code>与<code>Swoole</code>结合，也可达到 <code>Phalcon</code> 的程度。</p>
<p>php的版本是：7.1（如果你是一个新项目，一定要用php7）</p>
<h1 id="后端要做些什么"><a href="#后端要做些什么" class="headerlink" title="后端要做些什么"></a>后端要做些什么</h1><p>当然肯定需要先把db设计好，不过这不在我们讨论范围，假设已经完成了这一步。</p>
<p>我们的代码需要提供以下几部分能力：命令行脚本、api版本、后台管理这三部分。当然这三部分也可以拆分成三个项目，不过小公司、小项目没有必要（放在一个项目，加强了代码的复用性）</p>
<p>这三个是大的模块，然后再一个个接下来分析。</p>
<h2 id="命令行脚本"><a href="#命令行脚本" class="headerlink" title="命令行脚本"></a>命令行脚本</h2><p>先说 <strong>命令行脚本</strong> 它是比较独立的部分，不需要用户调用，主要用来完成一些定时任务等。现代一点的框架，都提供这个模块。<br>Phalcon提供了一个 <a href="https://docs.phalconphp.com/zh/3.2/application-cli" target="_blank" rel="external"><code>CLI</code></a> 模块，可以方便的完成这部分能力。他的代码写起来还是 mvc 的结构，只不过访问是通过命令行来进行。</p>
<p>比如一个最简单的 cli<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainTask</span> <span class="keyword">extends</span> <span class="title">Task</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">mainAction</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fwrite(\STDOUT, <span class="string">'hello task!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="api模块"><a href="#api模块" class="headerlink" title="api模块"></a>api模块</h2><p>我在最早接触api概念的时候，很懵逼，觉得很高大上。现在我对它的理解就是：前后端纯数据通信的一种方式。以前做web开发，我们不提供api，直接后段把数据渲染在页面上，用户直接在渲染的界面上操作，然后通过按钮或者什么触发一个请求到后端。</p>
<p>而到了api时代，在web方面有了前后端分离概念；移动app后端更是无力渲染（天然前后端分离）。所以要后台需要把数据发给前端，前端根据数据的描述把数据用用户看得懂的方式展现出来。比如一个商品的api可能结构如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 1,</span><br><span class="line">    msg: 'query ok',</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: '最凉快的空调',</span><br><span class="line">        price: '9999.00',</span><br><span class="line">        img: 'xxx.webp',</span><br><span class="line">        stock: '10'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式让前后端的开发彼此独立，大家专注做自己的事情。但是这也带来另外一个问题：前端有了所谓的版本，后端必须兼顾所有使用的版本。如果我们永远只使用一个api地址。那么代码可能会相当难看。</p>
<p>比如现在有了一个新的需求，以前 空调 只有一张图片。现在空调展示的时候有多张图片。那么有两种办法，一种是增加字段，一种是将原字段 <code>img</code> 变为一个数组。</p>
<p>如果是增加字段不会带来兼容性的问题。但是如果是粗暴的将img类型变更为数组，之前的版本将无法解析这个类型，因此要想变为数组，只能是api的整体升级（一般不会因为这个问题就进行升级）。</p>
<p>那么api做版本有哪些办法呢？我采用了Phalcon的模块来做api的版本控制。以前还尝试过控制器版本。比如：<br><code>ApiV1Controller</code> 表示这是v1版本。<code>ApiV2Controller</code>表示是v2版本。Phalcon的模块为版本提供了非常大的便利，直接新开一个模块，取名 <code>v1</code>，如果之后要升级，新开一个模块叫做 <code>v2</code>。对于不需要修改的功能，可以简单的让v2控制器继承v1中的控制器。</p>
<p>api的版本方面，我们就可以简单通过url的方式完成，比如：</p>
<ul>
<li><a href="https://api.xxx.com/v1/user/123" target="_blank" rel="external">https://api.xxx.com/v1/user/123</a></li>
<li><a href="https://api.xxx.com/v2/user/123" target="_blank" rel="external">https://api.xxx.com/v2/user/123</a><br>版本信息就非常的一目了然。</li>
</ul>
<h2 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h2><p>绝大部分系统，都需要一个cms来上传、修改相关资料。以加速侠为例：需要上传游戏，需要编辑一些游戏合辑等。你可以单独成一个项目，也可以还是用模块来进行开发（我推荐，极大程度的提供了代码复用）。</p>
<p>我最不能接受的一句话是：后台顺便弄一下，反正给公司内部用的。</p>
<p>做为一个有追求的程序员，我们必须要有底线，我们的目标是：让大家工作起来更便捷，更轻松，最后让大家没有工作（哈哈哈）。所以后台我也建议采用前后端分离，通过Vue来进行开发。</p>
<p>当前的后台使用了 Vue + Element UI + Vuex + Vue-Roter来进行开发。参考了，网络上的： <a href="https://segmentfault.com/a/1190000009275424" target="_blank" rel="external">手摸手，带你用vue撸后台</a>，写的真不错，为我学习省了很多弯路，特别是前端在权限控制上这一部分，他的方式让我眼前一亮。我的后台现在才刚刚搭建完基本的部分（路由规划、一些自己扩展的vue插件）<br><img src="http://ol59nqr1i.bkt.clouddn.com/vue-control.jpeg" alt="image"></p>
<p>前后端分离后，后段其实也可以归结到api的开发部分。并且这样带来的一个好处是：如果以后后段要做移动版的一些功能，api都是现成的。</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>写代码越久，越发现语言层面的东西，只要多动手，很快就能达到一个水平。但是业务代码写的再多，也不能让你再技术领域走的更远。因此如果你有幸在大公司，有机会接触大型项目（百万、千万用户级）的，一定好好观察为了这个项目这么多人开发，还能够很好的运作？他是如何解耦业务逻辑与系统架构？如果是在小的公司，那么就尽可能自己尝试去做一些系统的搭建，让大家在这个基础上进行业务开发，而不需要关心一些底层的东西，一个新手也能很快上手写业务。</p>
<p>后面可能还会有两篇到四篇讲后端部分。主要包括，后端项目结构的划分（这个结构我已经尝试过在3、4个项目中使用，目前都运行的很好），后端登陆控制（会开源一个Phalcon的oauth2的代码），后段api的自动化测试。</p>
<p>相关代码我将会陆续放在github上面。所有的代码就叫 <code>x-</code> 吧。x 从小学数学给我留下了深刻印象。</p>
<ul>
<li>x-api  是php的后端项目</li>
<li>x-control 是vue写的后端管理系统</li>
<li>x-client 是vue系的客户端界面</li>
</ul>
<hr>
<p>如果你对我的内容感兴趣，请关注我的微信公众号：</p>
<p>公众号：<code>icanfo</code></p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
<p>个人博客：<a href="https://helei112g.github.io/">https://helei112g.github.io/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[后端开发者从零做一个移动应用（一）]]></title>
      <url>https://helei112g.github.io/2017/06/24/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E4%BB%8E%E9%9B%B6%E5%81%9A%E4%B8%80%E4%B8%AA%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>移动互联网时代，我不想只当一个后端工程师<br><a id="more"></a></p>
<p>是时候学习一些新的东西了！</p>
<p>一直以来想要学习一些前端的知识，扩宽自己的技术栈，但是一直以来对前端都是进行了解，没有用一个产品把这些东西给展示出来。最近终于痛定思痛，做了一个 android应用，目前的产品确实很一般，但决定以此为起步，逐步完善、逐步提高。</p>
<p><a href="http://m.jiasux.com/#/share" target="_blank" rel="external">android 1.0版本：欢迎围观</a> </p>
<p>今后一段时间内，博客、公众号的主要内容将会是该产品涉及的技术分享，包括：我的开发思路、技术选择、技术学习等。内容至少保证一月一篇的进度（因为初期还有很多知识需要学习，精力有限）。一来对自己是一个总结，二来是希望可以对打通任督二脉的同学起到一定的帮助。</p>
<h1 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h1><p>先简单介绍一下做的是一个什么产品，大家之后看的时候，做到心中有数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是以提供游戏下载、游戏礼包发放为核心的移动端应用。可以简单理解成一个游戏的应用市场。</span><br></pre></td></tr></table></figure>
<p>当然除了普通的游戏下载外，还提供由我制作的加速游戏下载，是个什么意思呢？这里的加速并不是说优化手机环境，让游戏运行更流畅。而是进入游戏后，可以加速游戏进程，别人通过这个剧情需要10分钟，你只需要5分钟（所有加速的游戏均以取得对方授权）</p>
<p>这个产品也将会以真实的形态进行运营。</p>
<h1 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h1><p>作为一个想要成为 <code>跨端工程师</code> 的我，想以此为契机找到了学习新技术、运用新技术的支撑点。<br>为了完成这个app，最开始想全部采用原生，但这样会遗漏掉 混合应用 的学习，所以决定改为混合应用的方式进行开发。</p>
<ul>
<li>服务端：phalcon + nginx + mysql</li>
<li>前端技术：android + vue + vux（提供 app 与 手机网站）</li>
<li>后台界面：vue + iviewui</li>
</ul>
<p>为了完成上面的任务，服务端方面只需要看一下 <code>phalcon</code> 这个php框架，这对于我还是很容易上手的。一周时间做完了服务端的内容。后面的分享也先从它开始。</p>
<p>在写后端的时候，产出了一个基于 <code>phalcon</code> 的 oauth2 授权的lib。当时本来想找个开源的，没找到。之后也会开源到github上。借鉴了 <a href="https://github.com/Filsh/yii2-oauth2-server" target="_blank" rel="external">Filsh/yii2-oauth2-server</a> 项目。</p>
<p>后端做完后，需要前端展示出来，于是先学了android的一些基础知识（以前有java web开发经历），然后重点了解：<code>Fragment</code> <code>RecyclerView</code> <code>WebView</code>，然后途中了解到 Rxjava，又对它进行了解学习并使用。</p>
<p>这年代学习js，<code>npm</code>，<code>webpack</code>都是必知必会的。</p>
<p>js框架方面，选择目前最火也最好用的 <code>Vue</code>，这部分知识还是学习中，产出的唯一成果就是<a href="http://m.jiasux.com/#/share" target="_blank" rel="external">这个页面</a> <code>http://m.jiasux.com/#/share</code></p>
<p>当然css的布局样式，怎么也没有办法绕过去了（我以前最讨厌的东西，各种浮动让我烦躁）。还好现在工作几年有了耐心，然后又出现了 <code>flex</code> 这种新的布局方案。<br>现在css的写法也是种类繁多，我学习了其中一种<code>less</code>，因为使用的开源项目中采用了该技术。</p>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>最近有些朋友一直再问我，<code>Payment</code> 项目的文档什么时候补全，放心，不会弃坑的。目前已经全部介入支付宝的新版本支付接口。</p>
<p>后期会先从后段开始写，然后写前端。之后逐步记录每一次迭代时就按照开发顺序来进行。也希望大家能够持续关注这个产品，给我提出更好的意见。</p>
<p>如果你对我的内容感兴趣，请关注我的微信公众号：</p>
<p>公众号：<code>icanfo</code></p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
<p>个人博客：<a href="https://helei112g.github.io/">https://helei112g.github.io/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[推荐三款我常备开发辅助神器]]></title>
      <url>https://helei112g.github.io/2017/05/02/%E6%8E%A8%E8%8D%90%E4%B8%89%E6%AC%BE%E6%88%91%E5%B8%B8%E5%A4%87%E5%BC%80%E5%8F%91%E8%BE%85%E5%8A%A9%E7%A5%9E%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>好的工具不但提升我们的开发效率，也为工作带来乐趣。这三款工具你绝对值得拥有。<br><a id="more"></a></p>
<p>五一假期过完了，大家都去哪些地方浪了？上班第一天是不是倍感无趣？哈哈，不要紧，今天我来给大家推荐几个神器，让你明天神清气爽，这可是程序员开发必备之良品呀。</p>
<hr>
<h1 id="Api-与-Postman-的不离不弃"><a href="#Api-与-Postman-的不离不弃" class="headerlink" title="Api 与 Postman 的不离不弃"></a>Api 与 Postman 的不离不弃</h1><p>自从有了前后端的分离概念，我就一致在寻找着这样一款工具，我需要把我的接口如何使用告诉前端人员，我需要自己方便的测试api有没有问题，我需要能够自动化完整的测试一下我的接口运行流程有没有问题。当然它还是不能替代代码级别的自动化测试。</p>
<p>期间试过 <code>swagger</code> ，说实话也不错，界面也很漂亮，这是以前写过<a href="http://blog.csdn.net/hel12he/article/details/46547863" target="_blank" rel="external">关于 swagger ui</a> 的一篇文章，感兴趣的可以看看。当我找到 <code>Postman</code> 之后，就果断放弃了 <code>swagger</code> ，为什么呢？</p>
<p><code>swagger</code> 我是通过注解的方式来自动生成文档，所以就导致代码里边又很多文档注释，本来代码只需要10行，结果为了注释，整个文件变成了30行，看代码的时候给人一种很不清爽的感觉；<br>团队作战的时候，改动很频繁，因为文档内置在代码里边，更容易出现冲突的问题；注解的格式需要额外的学习成本。</p>
<p>反观 <code>Postman</code> 是一个独立的应用，提供团队协作（需要购买）；通过google帐号登陆，在任何地方登陆后可以获取到同步的数据；支持所有的http请求方法；能够自动化测试api接口；配合 <code>Postman Interceptor</code> chrome 浏览器插件，方便 phpstrome 进行debug。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/postman.jpeg" alt="image"></p>
<ul>
<li>大家注意看截图，<code>postman</code> 的 collections 功能，方便不同模块的分类；</li>
<li>其中标记为<code>1</code>圈红的地方，可以添加api的详细说明，比如干什么的，字段含义；</li>
<li>标记<code>2</code>的地方，保存了各种情况的返回结果，可以不需要网络就查看各种情况的返回数据；</li>
<li>标记<code>3</code>的地方，可以配置各种环境变量，方便切换。</li>
</ul>
<p>我这里配置了常用的：dev:开发环境，test:测试环境，prod:线上环境。</p>
<blockquote>
<p>postman如果团队开发需要购买，才能方便的同步看到更新的信息。价格还挺贵，我们小公司没钱，我用了一个偷懒的办法：share link 方法。</p>
</blockquote>
<p>同类的工具还有 atom，不过没怎么用过，大家可以比较下。</p>
<h1 id="charles-在我眼前没有秘密"><a href="#charles-在我眼前没有秘密" class="headerlink" title="charles 在我眼前没有秘密"></a>charles 在我眼前没有秘密</h1><p>程序员喜欢把自己的东西加密加密再加密，而面对别人的东西，总喜欢能够看的一清二楚，然后从中学习一些经验。</p>
<p>比如通过观察别人的app请求流程，可以看一下返回什么样的数据？一些基本的参数有哪些？有些接口如何组织请求流程等。</p>
<p>要完成上面的任务， <code>charles</code> 真的是不二之选。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/charles.jpeg" alt="image"></p>
<p>截图我是监控到的某电商的请求数据，左边部分显示的是请求接口，右边是响应的结果。</p>
<p>我就通过这款工具学习过如何对api进行版本维护，如何有效组织首页数据的返回（到底是一个接口搞定所有还是多个接口，前端多次调用？）</p>
<p>当然上面仅仅是它的一个作用。另外一个效果就是，自己的应用出了问题，可以方便的通过它看到请求的数据，以此来进行一些判断，修复bug。特别是强烈推荐测试人员使用，有很多bug是有前后的因果关系，需要看到数据开发人员更容易进行修正。</p>
<blockquote>
<p>如果想要查看 https 请求的数据，需要安装ssl证书到设备上，大家到官网看一下就知道。</p>
</blockquote>
<h1 id="图片压缩，我用-tinypng"><a href="#图片压缩，我用-tinypng" class="headerlink" title="图片压缩，我用 tinypng"></a>图片压缩，我用 tinypng</h1><p>今天推荐的最后一个工具<code>tinypng</code>。我之前再博客也推荐过 google 新的图片压缩算法 <code>guetzli</code>，这个算法真的非常牛逼。但是目前没有好用的客户端，只有命令行。</p>
<p>关于它没有太多的说的，就是压缩图片嘛。支持批量，压缩比率高，效果强。就是好用，把它分享给你的ui妹子，她会对你喜笑颜开。</p>
<p>下载地址：<a href="https://github.com/kyleduo/TinyPNG4Mac" target="_blank" rel="external">https://github.com/kyleduo/TinyPNG4Mac</a></p>
<h1 id="额外赠品"><a href="#额外赠品" class="headerlink" title="额外赠品"></a>额外赠品</h1><p>最后推荐一个集成第三方支付的开源项目：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>目前已经集成：支付宝支付、微信支付、招商一网通支付。如果你在开发中被各个第三方支付提供的demo搞得焦头烂额，我相信它能够帮助到你。</p>
<hr>
<p>本文写作时间：3小时（这效率……我也是醉了!）</p>
<p>我是：何磊，主要分享技术、生活。公众号：<code>icanfo</code>。个人博客：<a href="https://helei112g.github.io/">https://helei112g.github.io/</a></p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：支付的回调统一处理]]></title>
      <url>https://helei112g.github.io/2017/05/01/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>有20天没有更新了，主要原因有二：其一这期间对自己的职业规划做了一些调整；其二生了一场小病。所以大家一定要保重身体，平时得多锻炼锻炼了。<br><a id="more"></a></p>
<p>根据大家反馈，大家对 <code>Payment</code> 还是很认同，这让我很开心。五一花了两天时间把招商一网通集成进来了。希望能够帮助到更多的人。</p>
<hr>
<p><strong>Payment使用文档</strong>：<a href="https://helei112g.github.io/categories/payment-3/">https://helei112g.github.io/categories/payment-3/</a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>言归正传，这篇拖了很久了，借着五一假期的最后一天，搞定它！先上一个支付的一般流程图。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/pay_path.jpg" alt="image"><br><em>图片来源：支付宝</em></p>
<h1 id="异步与同步"><a href="#异步与同步" class="headerlink" title="异步与同步"></a>异步与同步</h1><p>在我们完成支付后，要确认用户是否真的支付了这笔钱，以及这笔钱支付的金额是否符合预期。怎么知道这些事情呢？</p>
<p>用户告诉我们？我们肯定不能确认是否真假。比较恰当的方式是，第三方（支付宝、微信、招商一网通等）收到用户付款后，他来告诉我们。所以这里就引出了通知这个概念。</p>
<p>通知的方式又有两种：同步通知，异步通知。同步通知的概念存在于网站支付或者H5支付中，因为只有在浏览器中才可以通过url进行跳转。那么我们应该使用同步通知作为支付成功的依据还是使用异步通知呢？</p>
<p>我的答案是：同步通知不做服务端的更新，可用于客户端的显示，异步收到通知时才做相关的更新处理。原因有三：</p>
<ol>
<li>并不是所有的支付模块都有同步通知这个概念；</li>
<li>同步通知的参数在url中，就算采用https协议，也存在更大被篡改的风险；</li>
<li>异步通知提供完整的失败重发机制，更值得信耐。</li>
</ol>
<h1 id="异步通知处理"><a href="#异步通知处理" class="headerlink" title="异步通知处理"></a>异步通知处理</h1><p>所以在 Payment 中只针对异步通知到达的数据进行了签名相关处理。下面我们来看看代码。</p>
<p>不管你是支付宝的异步通知，还是微信的异步通知或者招商一网通的异步通知，<code>Payment</code> 都提供了统一的异步处理接口，并且调用者完全不必去关心如何验证签名，如何核实数据，只需要专注自己的业务逻辑即可。</p>
<p>回调使用了一个开发的小技巧：依赖注入，我先上代码，后面稍微解释下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$callback = new TestNotify();</span><br><span class="line"></span><br><span class="line">$type = &apos;ali_charge&apos;;// ali_charge wx_charge  cmb_charge</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    // 获取第三方的原始数据，未进行签名检查，根据自己需要决定是否需要该步骤</span><br><span class="line">    //$retData = Notify::getNotifyData($type, $config);</span><br><span class="line"></span><br><span class="line">    $ret = Notify::run($type, $config, $callback);// 处理回调，内部进行了签名检查</span><br><span class="line">&#125; catch (PayException $e) &#123;</span><br><span class="line">    echo $e-&gt;errorMessage();</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return $ret;</span><br></pre></td></tr></table></figure></p>
<p>回调 的代码就这么简单，其中 <code>Notify::getNotifyData($type, $config);</code> 可以获取到第三方的回调数据，sdk仅仅是解析成数组返回，没有做签名检查，不能直接用来进行回调处理。</p>
<p><code>Notify::run($type, $config, $callback);</code> 则是进行回调相关的处理，它返回的值，是需要返回给第三方支付机构的，第三方机构通过返回值来识别商户是否正确处理了回调通知，并且以此来处理是否需要重发。</p>
<p>这里的重点就是 <code>$callback</code>，注意看上面的代码 <code>$callback = new TestNotify();</code>，</p>
<p>大家的重点就是创建这个 <code>TestNotify</code> 这个类，我们就叫它：商户回调业务处理类，名字大家随便取，根据自己的需要。看一下我示例中 <code>TestNotify.php</code> 的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">use Payment\Notify\PayNotifyInterface;</span><br><span class="line">use Payment\Config;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 客户端需要继承该接口，并实现这个方法，在其中实现对应的业务逻辑</span><br><span class="line"> * Class TestNotify</span><br><span class="line"> * anthor helei</span><br><span class="line"> */</span><br><span class="line">class TestNotify implements PayNotifyInterface</span><br><span class="line">&#123;</span><br><span class="line">    public function notifyProcess(array $data)</span><br><span class="line">    &#123;</span><br><span class="line">        $channel = $data[&apos;channel&apos;];</span><br><span class="line">        if ($channel === Config::ALI_CHARGE) &#123;// 支付宝支付</span><br><span class="line"></span><br><span class="line">        &#125; elseif ($channel === Config::WX_CHARGE) &#123;// 微信支付</span><br><span class="line"></span><br><span class="line">        &#125; elseif ($channel === Config::CMB_CHARGE) &#123;// 招商支付</span><br><span class="line"></span><br><span class="line">        &#125; elseif ($channel === Config::CMB_BIND) &#123;// 招商签约</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其它类型的通知</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 执行业务逻辑，成功后返回true</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的核心就是，客户端创建的 <code>商户回调业务处理类</code> 一定要实现 <code>PayNotifyInterface</code> 这个接口，并且实现 <code>notifyProcess</code> 这个方法，在这个方法中完成自己的商户逻辑。然后根据处理结果返回布尔值。</p>
<p>这里要重点说明的是 <code>TestNotify::notifyProcess(array $data)</code> 这个方法的参数 <code>$data</code>，它是通过sdk内部传过来的，它返回的信息与配置文件 <code>return_raw</code>的设置有关系。</p>
<p>如果 <code>return_raw = false</code> 返回的是我映射的结果，这里需要小心，如果你的php报错级别设置的太高，可能会出现报错，因为内部有很多 <code>Undefined index</code>  错误，因为我并未进行检查，当前可能暂时也不打算修复这个问题。<br>如果  <code>return_raw = true</code> 则返回的是第三方支付机构的原始数据。</p>
<p>不管是设置成什么，该参数里边都有一个 <code>channel</code> 参数，大家可以根据这个参数区分回调属于那一个类别。像上面的示例一样。</p>
<h1 id="PayNotifyInterface-接口"><a href="#PayNotifyInterface-接口" class="headerlink" title="PayNotifyInterface 接口"></a>PayNotifyInterface 接口</h1><p>最近有很多人在微信中问我，干嘛一定要实现这个接口？我这里举个例子：<br>你出去旅行，到了突然发现ios的手机充电线没带，怎么办？找个便利店买一根好了（因为附近没有苹果店），那么怎么买的充电线确保你手机可以用呢？这个很简单，因为苹果把自己充电线的接口标准公布了，凡事想造苹果手机充电线的按照这个标准造出来的，你都可以用。</p>
<p>所以接口的作用就是制定一个标准；你们都实现我规定的接口，然后返回布尔值给我，我就可以处理了。至于内部你们想怎么做，是你们的事情。</p>
<p>通过这个接口完全将签名与商户业务逻辑进行了分离，以后你的调整只围绕这一个类即可。当然这里涉及到的思想有 ioc/di ，这又是另外一个话题，空的时候我们聊聊。</p>
<h1 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h1><p>我的微信公众号(技术、创业主题)，欢迎订阅 <code>icanfo</code></p>
<p>现在这个公众号名字不太好，想名字真头痛。有谁可以给推荐一个？</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[团队开发Git分支管理策略]]></title>
      <url>https://helei112g.github.io/2017/04/14/%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>开发生涯的前三年都是使用 <code>svn</code>，回首放佛如前世。自从用了 <code>git</code> ，整个人都神经了。<br><a id="more"></a></p>
<p>下面的内容肯定不是什么教你如何用git提交代码，合并分支之类的。现在本人要<strong>从写术的层面提升一下自己文章的品质到道的层面</strong>。</p>
<h1 id="使用git带来的分支疑惑"><a href="#使用git带来的分支疑惑" class="headerlink" title="使用git带来的分支疑惑"></a>使用git带来的分支疑惑</h1><p><code>git</code> 为什么好，为什么要用 <code>git</code>，这不是我本文想要说明的问题。</p>
<p>这里想要给大家分享一下自己使用过程中产生的疑惑，以及解决的这些疑惑的过程。话又说回来，我现在依然充满疑惑。真不知道30岁的时候会不会不惑。</p>
<p>在使用 <code>git</code> 过程中，它的分支功能让我真的欣喜若狂，不过这是把双刃剑，一不小心你会得到这种<code>git</code>路径图：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/git/bg2012070502.png" alt="image"></p>
<p><em>图片来源：阮一峰老师博客</em></p>
<p>我的疑惑：</p>
<ol>
<li>那么团队中我们该使用怎样的分支策略来进行开发协作？</li>
<li>在多人的团队中，我们应该在 <code>master</code> 分支上直接开发吗？</li>
<li>如果线上产生了bug该通过什么样方式的分支去修复？</li>
<li>当有多个分支的时候，测试如何有效的参与进来每一个分支的测试？</li>
</ol>
<h1 id="用成熟的工作流来解决问题"><a href="#用成熟的工作流来解决问题" class="headerlink" title="用成熟的工作流来解决问题"></a>用成熟的工作流来解决问题</h1><p>在解答上面的疑惑前，先介绍几个工作流，然后通过工作流的模式，来进行解答。因为我们必须在某种设定的情景下，才能讨论解决问题的思路。</p>
<p>下面三种工作流方式，都是采用功能驱动开发，也就是先有需求产生，然后诞生对应的分支，然后开发，最后合并回来，完成使命被删除。</p>
<ul>
<li>Git flow</li>
<li>Github flow</li>
<li>Gitlab flow</li>
</ul>
<p>关于这三种工作流的详细介绍，建议看看<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="external">这篇文章-阮一峰</a></p>
<p>我现在采用的是 <code>Git flow</code> ，经过自己的实践，确实好用，解决不少问题。然后如果发现与自己的实际情况有些出入，可以根据需求做出些变动调整。</p>
<h2 id="我的选择"><a href="#我的选择" class="headerlink" title="我的选择"></a>我的选择</h2><p>我选择了 Git flow，它的主要特点是，长期存在两个分支：</p>
<ul>
<li>主分支master</li>
<li>开发分支develop</li>
</ul>
<p>然后，存在三种辅助分支，都是短期的，并且一半情况下只应该存在本地，不要提交到远程库。</p>
<ul>
<li>功能分支（feature branch）</li>
<li>补丁分支（hotfix branch）</li>
<li>预发分支（release branch）<br>在进行上面的分支时，建议的命名规范：feature-xxx、release-xxx、hotfix-xxx</li>
</ul>
<blockquote>
<p>话外：我以前喜欢用下划线，后来发现打中线不需要按 <code>shift</code> ，哈哈，从此开始中线时代。</p>
</blockquote>
<p><strong>什么时候要功能分支？</strong></p>
<p>当你拿到一个需求，或者不是一个立马需求上线的bug修复，那么就应该从 <code>develop</code> 开一个分支出来，完成这部分工作。完成后合并到 <code>develop</code> 分支。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/git/25142846_iM1D.png" alt="image"></p>
<p><strong>什么时候要预发分支？</strong></p>
<p>这个分支是为预发准备的，测试的介入，也只应该在该分支产生时才介入。当我们不管是新功能开发，还是一般的bug修改都差不多了。就应该从<code>develop</code>产生一个<code>release</code>分支，交给测试，如果有bug直接在上面修改。全部完成后，合并回<code>develop</code>，并且合并到<code>master</code>。</p>
<p>关于这个分支我得再多说几句。因为这是非常重要的一步，如果我们使用了 git 钩子，当合并到 <code>master</code> 的时候，会自动发布到线上，所以这是临上线的最后一道屏障。</p>
<p>同时这里也解决了我一个疑惑，测试如何参与到<code>git</code>的每个分支中来？答案是：测试不应该参与到每个分支中来，只应该参与到<code>release</code>分支中去。其它的开发分支，都应该由开发人员自己测试，测试没有问题的时候才准许合并到<code>develop</code>，这就要求每一个开发要提高自己交付的产品质量，如何确保自己交付的产品质量？自动化测试是个不错的选择，好了，打住，这不是咋们今天的主要任务，这个话题改天再聊。</p>
<p><strong>什么时候需要补丁分支？</strong></p>
<p>这种情况越少越好。因为它产生的原因是：线上出了bug，并且必须马上修复，不管你身在何方，当手机响起，拿出电脑改bug吧。</p>
<p>它与<code>release</code> 很像，都需要完成后，同时合并到:<code>master</code>与<code>develop</code>。不同的是，它需要从<code>master</code> 上开一个分支出来。<br><img src="http://ol59nqr1i.bkt.clouddn.com/git/hotfix.png" alt="image"></p>
<p>注意这里没有测试的介入，一半来说都是代码上某一个小的紧急bug，虽然很严重，但是可以很容易改动。当然如果有一些例外情况，应该让测试进行测试后再合并、发布。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>git</code> 开发很好用，但是要按照一定规则合理使用分支。</p>
<p>另外，除了:<code>master</code>与<code>develop</code> 分支，其它分支都不应该出现在远程仓库中。</p>
<p>用<code>git</code>一定要结合它的各种钩子来使用，提升开发效率。这里后面来介绍下。</p>
<p>参考资料:</p>
<ul>
<li>[1]<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="external">Git 工作流程</a></li>
<li>[2]<a href="http://www.oschina.net/translate/a-successful-git-branching-model?lang=chs&amp;page=1" target="_blank" rel="external">介绍一个成功的 Git 分支模型</a></li>
</ul>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>我是何磊，主要工作就是写代码，持续创业者（之所以持续是因为到现在还没有干成功过一件事）。如果你有兴趣欢迎关注我，我会分享技术，还有生活，当然还有我创业的故事（说出我的痛，让你开心一下）。</p>
<p>因为自己的<a href="https://helei112g.github.io/">博客</a>没有留言功能，同时也需要大家记住域名很麻烦，因此我开通了这个公众号，希望在这里遇见你：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：微信支付发起支付请求文档]]></title>
      <url>https://helei112g.github.io/2017/04/10/Payment%EF%BC%9A%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%8F%91%E8%B5%B7%E6%94%AF%E4%BB%98%E8%AF%B7%E6%B1%82%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<p>文档更新太慢，自己都忍不住要抱怨了。可能越来越慢了<br><a id="more"></a></p>
<p><strong><code>Payment 3.0</code></strong> 微信的配置设置文档请 <a href="https://helei112g.github.io/2017/03/28/Payment%EF%BC%9A%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%AF%B4%E6%98%8E/">点击这里</a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>为了调用方便，提供了统一的 <code>Client\Charge</code> 类来发起支付。需要设置的参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>body</td>
<td>boolean</td>
<td>是</td>
<td>商品描述</td>
</tr>
<tr>
<td>subject</td>
<td>string</td>
<td>是</td>
<td>商品名称,该参数最长为128个汉字</td>
</tr>
<tr>
<td>order_no</td>
<td>string</td>
<td>是</td>
<td>商户网站唯一订单号</td>
</tr>
<tr>
<td>timeout_express</td>
<td>string</td>
<td>是</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。</td>
</tr>
<tr>
<td>amount</td>
<td>float</td>
<td>是</td>
<td>该笔订单的资金总额，单位为RMB-Yuan</td>
</tr>
<tr>
<td>return_param</td>
<td>string</td>
<td>是</td>
<td>附加数据，在查询API和支付通知中原样返回</td>
</tr>
<tr>
<td>client_ip</td>
<td>string</td>
<td>是</td>
<td>用户端实际ip</td>
</tr>
<tr>
<td>terminal_id</td>
<td>string</td>
<td>是</td>
<td>自定义参数，可以为终端设备号(门店号或收银设备ID)，PC网页或公众号内支付可以传”WEB”</td>
</tr>
<tr>
<td>product_id</td>
<td>string</td>
<td>否</td>
<td>商品ID</td>
</tr>
<tr>
<td>openid</td>
<td>string</td>
<td>否</td>
<td>此参数为微信用户在商户对应appid下的唯一标识</td>
</tr>
</tbody>
</table>
<p>在上面的参数中，无论微信的哪一种支付都必须提供：</p>
<ul>
<li>body</li>
<li>subject</li>
<li>order_no</li>
<li>timeout_express</li>
<li>amount</li>
<li>return_param</li>
<li>client_ip</li>
<li>terminal_id<br>这几个参数，是必须进行设置的。</li>
</ul>
<h1 id="扫码支付"><a href="#扫码支付" class="headerlink" title="扫码支付"></a>扫码支付</h1><p>用户扫描商户展示在各种场景的二维码进行支付。这里采用的是模式二。</p>
<p>对于扫码支付，必须提供: product_id  参数，该 <code>product_id</code> 是商户自己平台的信息，可用使用sku。</p>
<p>如果扫码支付时，传入了 <code>openid</code>，则扫码时，只能使用对应的微信扫码才能完成支付。这里可以根据自己的需求来决定。<br><a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_5" target="_blank" rel="external">扫码支付，模式二介绍</a></p>
<h1 id="刷卡支付"><a href="#刷卡支付" class="headerlink" title="刷卡支付"></a>刷卡支付</h1><p>刷卡支付，就是用于用户向商户展示二维码，商户通过扫码枪获取二维码或者条码信息，完成收款。与上面的扫码支付相对应。<br><code>auth_code</code> 是必须设置的参数，扫码支付授权码，设备读取用户微信中的条码或者二维码信息</p>
<h1 id="app支付"><a href="#app支付" class="headerlink" title="app支付"></a>app支付</h1><p>适用于商户在移动端APP中集成微信支付功能。<br>商户APP调用微信提供的SDK调用微信支付模块，商户APP会跳转到微信中完成支付，支付完后跳回到商户APP内，最后展示支付结果。<br>目前微信支付支持手机系统有：IOS（苹果）、Android（安卓）和WP（Windows Phone）。</p>
<p>该支付方式，无需额外的参数信息，只需要上面表格中标记的必须参数。</p>
<p><a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5" target="_blank" rel="external">客户端教程</a></p>
<h1 id="公众号支付"><a href="#公众号支付" class="headerlink" title="公众号支付"></a>公众号支付</h1><p>商户已有H5商城网站，用户通过消息或扫描二维码在微信内打开网页时，可以调用微信支付完成下单购买的流程。</p>
<p>这里记住一定时微信内部打开h5页面。</p>
<p><code>openid</code> 是公众号支付必须提供的信息，微信用户在商户对应appid下的唯一标识。openid如何获取，可参考<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_4" target="_blank" rel="external">获取openid</a></p>
<p>这里用到了 openid，也就说明该支付只能由发起支付请求的公众号完成支付。</p>
<p>因此，如果有时候遇到：“下单账号和支付账号不一致”  ，那么肯定是发起支付请求的时候是一个帐号，而进行支付时变成了另外一个微信帐号导致的。</p>
<blockquote>
<p>小程序支付与公众号支付具有相同的请求参数</p>
</blockquote>
<p><a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6" target="_blank" rel="external">公众号调起支付</a><br><a href="https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&amp;index=3" target="_blank" rel="external">小程序调起支付</a></p>
<h1 id="h5支付"><a href="#h5支付" class="headerlink" title="h5支付"></a>h5支付</h1><p>H5支付是指商户在微信客户端外的移动端网页展示商品或服务，用户在前述页面确认使用微信支付时，商户发起本服务呼起微信客户端进行支付。<br>主要用于触屏版的手机浏览器请求微信支付的场景。可以方便的从外部浏览器唤起微信支付</p>
<p>微信这个支付能力，并未完全开放，申请的条件也比较苛刻。不过说实话也不好用。</p>
<p>参数跟app支付一样，不需要添加额外的信息。</p>
<p><a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_4" target="_blank" rel="external">外部网页唤起微信支付</a></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>下面代码实例一下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Client</span>\<span class="title">Charge</span>;</span><br><span class="line"></span><br><span class="line">$config = <span class="keyword">require_once</span>(<span class="string">'./wxconfig.php'</span>);<span class="comment">// 微信的配置信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$channel = <span class="string">'wx_app'</span>;<span class="comment">// wx_app    wx_pub   wx_qr   wx_bar  wx_lite   wx_wap</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$payData = [</span><br><span class="line">    <span class="string">'body'</span> =&gt; <span class="string">'一个苹果'</span>,</span><br><span class="line">    <span class="string">'subject'</span> =&gt; <span class="string">'牛逼公司--付款吧'</span>,</span><br><span class="line">    <span class="string">'order_no'</span> =&gt; <span class="string">'NB12312355'</span>,</span><br><span class="line">    <span class="string">'timeout_express'</span> =&gt; <span class="string">'1489241888'</span>,</span><br><span class="line">    <span class="string">'amount'</span> =&gt; <span class="string">'100'</span>,</span><br><span class="line">    <span class="string">'return_param'</span> =&gt; <span class="string">'buy some'</span>,</span><br><span class="line">    <span class="string">'client_ip'</span> =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">'terminal_id'</span> =&gt; <span class="string">'WEB'</span>,</span><br><span class="line">    <span class="comment">//'product_id' =&gt; '888',</span></span><br><span class="line">    <span class="comment">//'openid' =&gt; 'xxxxxxx',</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">// product_id  openid  参数，并不是每一个支付都需要，具体行为阅读上面文档</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $str = Charge::run($channel, $config, $payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_array($ret)) &#123;</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    header(<span class="string">'Location:'</span> . $ret);</span><br><span class="line">    <span class="keyword">echo</span> htmlspecialchars($ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">exit</span>;</span><br></pre></td></tr></table></figure></p>
<p>关于 <code>channel</code> 的说明：</p>
<table>
<thead>
<tr>
<th>渠道</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>wx_app</td>
<td>代表app支付</td>
</tr>
<tr>
<td>wx_pub</td>
<td>代表公众号支付</td>
</tr>
<tr>
<td>wx_qr</td>
<td>代表扫码支付</td>
</tr>
<tr>
<td>wx_bar</td>
<td>代表刷卡支付</td>
</tr>
<tr>
<td>wx_lite</td>
<td>代表小程序支付</td>
</tr>
<tr>
<td>wx_wap</td>
<td>代表h5支付</td>
</tr>
</tbody>
</table>
<p>关于支付返回的各种数据，以及相关支付方式，如果调起微信支付，请自行查看对应文档。</p>
<p>我的个人公众号(技术、创业主题)，希望在这里遇见你：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[php工程狮感知的前端工作流程]]></title>
      <url>https://helei112g.github.io/2017/04/01/php%E5%B7%A5%E7%A8%8B%E7%8B%AE%E6%84%9F%E7%9F%A5%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>这个时代不懂点前端知识，真的没有办法生存。就算不会写，也得了解它的原理吧！<br><a id="more"></a></p>
<p>最近做了一些总结，之前都是迷迷糊糊，搞不清楚前端之前的相关定位。好好梳理了一下。错误之处请各位指正。</p>
<p>本文主要说的是 JavaScript 工作流程</p>
<hr>
<p>目前前端真的该叫大前端，其越来越细化，越来越复杂。在这种背景下，诞生了很多工具很多前端工作流程。比如热门的：</p>
<ul>
<li>react</li>
<li>vue</li>
<li>webpack</li>
<li>babel</li>
<li>gulp</li>
<li>node.js</li>
<li>npm</li>
<li>nvm</li>
<li>angular</li>
<li>bower<br>… …</li>
</ul>
<p>如果继续写，估计光这个，字数久能够达到1000+<br>这里边有的是前端js框架，有的是一些开发工具，但他们种类这么多，各自能够解决什么问题？互相之间有什么联系？是不是一个项目就必须用上这么多东西？使用时候，如何相互配合？</p>
<p>带着这些疑问，作为一个后端程序员，进行了系列调查，要把我的成果分享出来（可能错误百出）。<br>首先前端开发的三大基础：</p>
<ul>
<li><strong><code>html</code></strong> 这个是最基础的，被称为：超文本标记语言。什么意思？简单来说就是描述一个页面的结构，比如：页面的头部，页面的内容，页面的尾部。也就说，它控制一个页面的结构。浏览器会按照它定义的结构来进行解析，显示不同内容。</li>
<li><strong><code>css</code></strong> 我们对美的追求是无止境的，光有结构，看起来没有色彩，有些地方不突出。就像衣服：原始人用树叶、兽皮，随着进步，我们穿丝绸、破洞牛仔，搭配丝巾、手表等等，所以就是用来控制html的样式，让它变的更好看。</li>
<li><strong><code>JavaScript</code></strong> 这是本文主要阐述的地方，有了html+css，显然还不能满足我们的追求，会html、css的人不能叫做前端工程师、更不能叫程序媛。但是如果你会了 JavaScript，江湖就有你的依稀之地，这也是本文主要介绍的部分。</li>
</ul>
<p>目前我们很多时候常说的前端工程师，其实主要指的就是其 js工程师。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。</p>
<p>功能越强大，责任也越多。现在 js（后面全部使用简称，字太多，不想写）使用的越来越多，早期 js 仅仅用来做一些简单的交互，随着现在移动互联网的发展，各项硬件设备的性能提升。项目越来越复杂，效果越来越酷炫。js 做的事情也更多。</p>
<p>当然今天不讲这么多发展历史（关键是我也没理清呀），总的来说就是 js 开发工作原来比较简单，大家随便写写久搞定工作了，但是现在工作的复杂度越来越高，像以前那么任性的工作，开发麻烦、维护麻烦。还好具备程序员三大美德人，开始构建一些工具。</p>
<p>Perl语言的发明人Larry Wall说，好的程序员有3种美德： 懒惰、急躁和傲慢（Laziness, Impatience and hubris）。</p>
<blockquote>
<p>懒惰：<br>是这样一种品质，它使得你花大力气去避免消耗过多的精力。它敦促你写出节省体力的程序，同时别人也能利用它们。为此你会写出完善的文档，以免别人问你太多问题。<br>急躁：<br>是这样一种愤怒—-当你发现计算机懒洋洋地不给出结果。于是你写出更优秀的代码，能尽快真正的解决问题。至少看上去是这样<br>傲慢：<br>极度的自信，使你有信心写出（或维护）别人挑不出毛病的程序</p>
</blockquote>
<p>先是大家感觉js代码复用是个问题，我们想用别人写的某个功能，只能网上去翻别人写的源码，拷贝下来。后段语言都有自己的包管理工具，比如：java的maven，python的pip，php的composer等。于是在历史的使命召唤中，npm诞生了，js的包管理工具。<br>比如以前要使用 jquery，你的到官网去下载，现在 npm install jquery 就可以了。</p>
<p>npm是运行在node的环境上，它们的关系又是另外一个话题，这里按下暂且不表。<br>像 react、vue都可以通过npm来安装。</p>
<p>包管理的问题解决了，接下来又有另外一个问题，由于 js 是 <code>Brendan Eich</code> 这大哥花了 10 天时间设计的（牛人就是这么屌）。虽然如今广泛应用，也由于时间紧导致留下了很多设计缺陷。</p>
<p>伴随了 <code>ES6</code> 的发布，js越来越规范了，我们程序员肯定都想用好用的简洁的语法来完成任务，好早点下班回家打lol呀。可惜呀，世界上成百上千万的网站，不可能一下子全部升级，浏览器也不可能立马就支持最新语法，怎么办？<code>babel</code> 诞生了，它牛逼在那里？让你可以用es6的语法写代码，然后在现在的环境下可以运行（在这里请自行忽略ie9以下浏览器）。</p>
<p>在你用es6写完代码后，用它转码一下，可以得到es5的代码。不信？来个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转码前</span></span><br><span class="line">input.map(item =&gt; item + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转码后</span></span><br><span class="line">input.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。</p>
<p>另外 babel 其实也是用js写的一个工具，所以它还是可以通过 <code>npm install babel-cli</code> 来安装。</p>
<p>关于它怎么用，自己看官方文档。</p>
<p>好。到目前为止，解决了两个大问题。接着看前端还有什么问题？那么在开发中还有什么问题需要解决？合并文件、压缩代码、检查语法错误、将Sass代码转成CSS代码等等这些都是开发中的重复性任务，以前这些任务都需要单独人工解决，然后为了提高效率，早点下班，就有了:Gulp  Grunt这些task runner。推荐使用gulp来自动化的执行这些任务。</p>
<p>那么到了这里，是不是就截止了？还没有，现在的基本都讲究什么前后端分离，也就是变成了web app的方式，那么就要求页面重新加载要变少，用户交互要变多，也就导致一个页面上js越来越多。这么多的js怎么管理？如何提高浏览器的加在速度？能否将css img html 字体这些资源也当成模块来处理？在这些问题下，产生了很多模块打包工具，毫无疑问：webpack是最耀眼的，也是用起来最爽的。</p>
<p>所以模块打包的问题也解决了，另外说一句，gulp的部分功能可能通过webpack的插件也能解决，但并不意味着不再需要它，一般来说gulp运行在webpack之后。</p>
<p>再次声明，上面所有介绍的东西，都可以通过npm来安装获得。所以说到底它们都是用js写的一个工具。</p>
<p>ok，那么工具基本介绍完了，到底页面怎么呈现给用户？后台传过来的数据怎么绑定到dom里边去？如果向后台发起请求获得数据？等等，这些需要一个js业务框架来完成。所以react、vue就是来解决这些问题的</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>至此前端的一个工作结构介绍至此结束。再瞎逼逼两句，学习是一件持续的事情，在学习某个新东西前，先要对它是干吗的，它解决一个什么样的问题有个认识，然后面对知识你才能在自己的脑海中建立一个体系。</p>
<p>参考了很多资料，贴在这里供参考:</p>
<ul>
<li>[1] <a href="https://chenyiqiao.gitbooks.io/webpack/content/motivation_of_webpack.html" target="_blank" rel="external">我们为什么需要Webpack？</a></li>
<li>[2] <a href="https://cn.vuejs.org/v2/guide/comparison.html" target="_blank" rel="external">Vue 对比其他框架</a></li>
<li>[3] <a href="https://www.zhihu.com/question/37020798" target="_blank" rel="external">Webpack、Browserify和Gulp三者之间到底是怎样的关系？</a></li>
<li>[4] <a href="http://es6.ruanyifeng.com/#docs/intro#Babel-转码器" target="_blank" rel="external">Babel-转码器</a></li>
<li>[5] <a href="http://www.gulpjs.com.cn" target="_blank" rel="external">用自动化构建工具增强你的工作流程！</a></li>
</ul>
<p>想要看看以后写的文章，请扫码关注：<br><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：微信支付配置文件设置说明]]></title>
      <url>https://helei112g.github.io/2017/03/28/Payment%EF%BC%9A%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<p>终于写到微信了。加油干，撸起袖子奔小康。<br><a id="more"></a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>微信支付个人觉得在帐号设置上有些麻烦，帐号太多啦，支付宝目前就是一个应用基本涵盖了所有的接口开发。</p>
<p>可能是由于微信支付的后端是财付通，反正咱们写代码的，也别管那么多。理清楚各配置的关系，然后写出高质量的代码就好。</p>
<p>关于如何申请微信支付，只讲两个问题，服务号支付能力的申请在公众号后后台申请，app应用的支付能力申请在开发者中心申请。其他细节请自行查询。</p>
<hr>
<p>登陆微信商户平台：<a href="https://pay.weixin.qq.com" target="_blank" rel="external">https://pay.weixin.qq.com</a></p>
<p>拿到微信给的商户号后，登陆商户平台，点击【账户中心】进入【API安全】<br>会看到下面的截图：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/pay/set-md5-key.jpeg" alt="image"></p>
<p>微信支付发起请求的数据需要进行签名，签名的密钥就是在这里设置，设置时候请记录一下。等会配置中会需要。</p>
<p>下载微信的安全证书，相关说明<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=4_3" target="_blank" rel="external">看这里</a></p>
<p>配置文件<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'app_id'</span>            =&gt; <span class="string">'应用ID'</span>,</span><br><span class="line">    <span class="string">'mch_id'</span>            =&gt; <span class="string">'商户id'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>           =&gt; <span class="string">'刚刚设置的密钥'</span>,</span><br><span class="line">    <span class="string">'app_cert_pem'</span>      =&gt; <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'app_key_pem'</span>       =&gt; <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">    <span class="string">'sign_type'</span>         =&gt; <span class="string">'MD5'</span>,<span class="comment">// MD5  HMAC-SHA256</span></span><br><span class="line">    <span class="string">'limit_pay'</span>         =&gt; [</span><br><span class="line">        <span class="comment">//'no_credit',</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'fee_type'</span>          =&gt; <span class="string">'CNY'</span>,<span class="comment">// 货币类型  当前仅支持该字段</span></span><br><span class="line">    <span class="string">'notify_url'</span>        =&gt; <span class="string">'https://helei112g.github.io/'</span>,</span><br><span class="line">    <span class="string">'redirect_url'</span>      =&gt; <span class="string">'https://helei112g.github.io/'</span>,</span><br><span class="line">    <span class="string">'return_raw'</span>        =&gt; <span class="keyword">false</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>下面表格中 <strong>是否必须</strong> 列如果标记为 <code>是</code>  ，则该项必须设置，否则sdk将无法得到结果。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>app_id</td>
<td>string</td>
<td>是</td>
<td>应用id，下面会详细解释</td>
</tr>
<tr>
<td>mch_id</td>
<td>string</td>
<td>是</td>
<td>微信支付分配的商户号</td>
</tr>
<tr>
<td>md5_key</td>
<td>string</td>
<td>是</td>
<td>用户在商户中心设置的api密钥</td>
</tr>
<tr>
<td>sign_type</td>
<td>string</td>
<td>是</td>
<td>签名类型，默认为MD5，支持HMAC-SHA256和MD5。</td>
</tr>
<tr>
<td>app_cert_pem</td>
<td>string</td>
<td>是</td>
<td>证书pem格式</td>
</tr>
<tr>
<td>app_key_pem</td>
<td>string</td>
<td>是</td>
<td>证书密钥pem格式</td>
</tr>
<tr>
<td>limit_pay</td>
<td>array</td>
<td>否</td>
<td>上传此参数no_credit–可限制用户不能使用信用卡支付</td>
</tr>
<tr>
<td>fee_type</td>
<td>string</td>
<td>否</td>
<td>默认人民币：CNY</td>
</tr>
<tr>
<td>notify_url</td>
<td>string</td>
<td>是</td>
<td>异步通知的地址</td>
</tr>
<tr>
<td>redirect_url</td>
<td>string</td>
<td>否</td>
<td>回调页面地址</td>
</tr>
<tr>
<td>return_raw</td>
<td>boolean</td>
<td>否</td>
<td>是否返回微信原始数据</td>
</tr>
</tbody>
</table>
<p><strong><code>app_id</code>:</strong> 对于公众号支付，是微信支付分配的公众账号ID，如果是app支付则是微信开放平台审核通过的应用APPID</p>
<p>微信支付接口中，一定要注意区分不同的帐号类别</p>
<ul>
<li>公众号支付，需要对应服务号在公众号后台申请，该帐号无法用来进行app支付</li>
<li>app支付，微信开放平台审核通过的应用APPID，无法用来进行公众号支付</li>
<li>小程序支付也是一个独立的帐号，微信分配的小程序ID</li>
<li>扫码支付，可以使用app支付的帐号，也可使用公众支付的帐号</li>
<li>刷卡支付，两个帐号也可以使用</li>
</ul>
<p>由于我没有小程序的帐号，没办法测它是否可以用于扫码支付与刷卡支付，有测过的朋友请告诉我一下（微信号：<code>helei543345</code>）</p>
<p><strong><code>mch_id</code>:</strong> 商户号，申请商户号成功后，腾讯给你发的邮件里边有</p>
<p><strong><code>md5_key</code>:</strong> 在商户中心自己设置的api密钥，主要用来签名支付数据</p>
<p><strong><code>sign_type</code>:</strong> 签名方式，当前微信支持HMAC-SHA256和MD5，默认使用 MD5</p>
<p><strong><code>app_cert_pem</code>:</strong> 从apiclient_cert.p12中导出证书部分的文件，为pem格式，请妥善保管不要泄漏和被他人复制</p>
<p><strong><code>app_key_pem</code>:</strong> 从apiclient_key.pem中导出密钥部分的文件，为pem格式</p>
<p>关于 <code>app_cert_pem</code> 与 <code>app_key_pem</code> 的详情请看这里 : <a href="https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=4_3" target="_blank" rel="external">https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=4_3</a></p>
<p><strong><code>limit_pay</code>：</strong> no_credit–指定不能使用信用卡支付  ，当前微信仅这一个参数，设置了，支付时，用户无法使用信用卡</p>
<p><strong><code>fee_type</code>:</strong> 货币类型，默认是人民币，其他可选值看这里：<a href="https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=4_2" target="_blank" rel="external">https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=4_2</a></p>
<p><strong><code>notify_url</code>：</strong> 异步接收微信支付结果通知的回调地址，通知url必须为外网可访问的url，不能携带参数。</p>
<p><strong><code>redirect_url</code>:</strong> 只有在使用h5支付时，才需要设置，也可以选择不设置。用来控制在h5中支付成功后，跳转的页面。</p>
<p><strong><code>return_raw</code>：</strong> 是否返回微信的原始数据，默认为false，建议设置为true</p>
<ul>
<li>该参数如果设置为 <code>false</code>，sdk内部会映射一些key，并且把微信的金额处理为元</li>
<li>如果参数值为 <code>true</code> ，则只对异步数据进行签名检查，检查通过，返回一个数据类型的数据（微信原始为xml），其中包含的key是微信本身的，并且金额相关的单位都是分</li>
</ul>
<p>微信的配置文件相对来说比较简单，只是它的帐号体系有点多，大家在使用时，根据自己使用不同支付，读取不同配置，来完成相互间的切换。</p>
<p>另外，如果还需要转账或者发红包，请设置以下图中的信息。<br><img src="http://ol59nqr1i.bkt.clouddn.com/pay/set-other.jpeg" alt="image"></p>
<p>今天晚上公司部署新项目，在等待过程中把微信的配置文档搞定。</p>
<p>最近自己弄了一个微信公众号，想分享一些自己的文章，以及自己写的小工具，比如：图片压缩，短连接在线接口，在线二维码接口等。</p>
<p>感兴趣的朋友可以关注：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Guetzli 图片压缩到底有多牛]]></title>
      <url>https://helei112g.github.io/2017/03/28/Guetzli%20%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E7%89%9B/</url>
      <content type="html"><![CDATA[<p>忙里偷闲，把一张图片用 guetzli 压缩了13次。你要不要来看看结果<br><a id="more"></a></p>
<p>在上一篇文章中，介绍了 guetzli 的安装。伴随 1.0.1 版本移除 gflags ，安装也变的异常简单了。</p>
<p>本篇带领大家看一下他的压缩效果。我下面放几张图。大家可以看看效果。看谁能够识别那张图是压缩了的。</p>
<p>下面全是图片。</p>
<p>图片一：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb01.jpg" alt="image"></p>
<p>图片二：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1.jpg" alt="image"></p>
<p>图片三：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb02.jpg" alt="image"></p>
<p>图片四：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb03.jpg" alt="image"></p>
<p>图片五：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb04.jpg" alt="image"></p>
<p>图片六：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb05.jpg" alt="image"></p>
<p>图片七：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb06.jpg" alt="image"></p>
<p>图片八：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb07.jpg" alt="image"></p>
<p>图片九：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb08.jpg" alt="image"></p>
<p>图片十：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb09.jpg" alt="image"></p>
<p>图片十一：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb10.jpg" alt="image"></p>
<p>图片十二：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb11.jpg" alt="image"></p>
<p>图片十三：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb12.jpg" alt="image"></p>
<p>整个验证过程，我将原图进行了13次压缩。</p>
<p>原始图片是： 1.3M ，压缩到最后只剩下 254KB。这是很高的压缩比，而且很难察觉图片质量是否变低。</p>
<p>但是 guetzili 当前还仅支持单图压缩，而且很慢，希望以后可以改善。自己用python写了一个 批量处理图片的脚本。如果有需要的朋友，关注我的微信公众号，留下的邮箱，我会将脚本发送给你。随便把你猜的答案发给我。</p>
<p>后期计划可能出一个在线api，方便大家使用。</p>
<p><strong>个人微信公众号</strong>：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
<p>另外，最近公司项目比较紧，微信支付的相关文档，4月份开始更新。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何在 CentOs7 中安装guetzli]]></title>
      <url>https://helei112g.github.io/2017/03/21/%E5%A6%82%E4%BD%95%E5%9C%A8-CentOs7-%E4%B8%AD%E5%AE%89%E8%A3%85guetzli/</url>
      <content type="html"><![CDATA[<p>CentOs7 中安装 <code>guetzli</code> 教程，我的承诺，今天兑现。带你上车<br><a id="more"></a></p>
<p>周六的时候收到 36kr 推送的一篇文章： <a href="http://36kr.com/p/5067258.html" target="_blank" rel="external">Google开源新算法，可将JPEG文件缩小35%</a></p>
<p>测试了结果，惊的我目瞪口呆。如果非要我用一个词形容的话：</p>
<p>牛逼</p>
<p>太牛逼</p>
<p>先来教大家如何在 CentOs7 中安装，项目的说明文档没有很好的说明如何完成 redhat 系列的 linux 如何安装。我是踩了不少坑才完成的。</p>
<p>这里边最简单的安装就是 mac 上了，直接通过 <code>brew install guetzli</code> 就ok。ubuntu 上的安装也是满多坑，如果出了问题，也可以借鉴本文。</p>
<p><a href="https://github.com/google/guetzli" target="_blank" rel="external">Guetzli 项目地址</a></p>
<hr>
<p>首先为自己的系统设置epel源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rpm -ivh http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br></pre></td></tr></table></figure></p>
<p>上面这一步并不是必须的。我只是为了讲解后面的错误。</p>
<p>在安装 Guetzli 之前，需要先安装：</p>
<ul>
<li><code>libpng</code> <a href="http://www.libpng.org/pub/png/libpng.html" target="_blank" rel="external">link</a></li>
<li><code>gflags</code> <a href="https://gflags.github.io/gflags/" target="_blank" rel="external">link</a></li>
</ul>
<h1 id="libpng的安装"><a href="#libpng的安装" class="headerlink" title="libpng的安装"></a>libpng的安装</h1><p>先说 <code>libpng</code> 的安装。该库是一款C语言编写的比较底层的读写PNG文件的跨平台的库。</p>
<p>如果搞不懂c语言，你也不用管他，简单说就是 <code>guetzli</code> 内部会使用它，所以需要先把它安装好。否则 <code>guetzli</code> 没办法读取png图片（并且也不能编译通过）</p>
<p>这个库可以直接通过yum来进行安装。安装出来的是 <code>1.5.13</code>  。当前最新的版本是 <code>1.6.29</code><br>由于我的源里边没有最新版，所以这里安装的版本就是：1.5.13</p>
<p>安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libpng-devel</span><br></pre></td></tr></table></figure></p>
<p>这里一定注意，不要直接安装 libpng  。安装 libpng-devel 会依赖安装 <code>libpng</code></p>
<p>ps: <code>libpng-devel</code> 是 用于程序操作PNG图片的开发工具</p>
<blockquote>
<p>The libpng-devel package contains header files and documentation necessary<br>for developing programs using the PNG (Portable Network Graphics) library.<br>If you want to develop programs which will manipulate PNG image format<br>files, you should install libpng-devel.  You’ll also need to install<br>the libpng package.</p>
</blockquote>
<p>如果没有安装依赖成功，请自行手动安装。命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libpng</span><br></pre></td></tr></table></figure></p>
<p>检查是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info libpng libpng-devel</span><br></pre></td></tr></table></figure>
<p>看到如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">已安装的软件包</span><br><span class="line">名称    ：libpng</span><br><span class="line">架构    ：x86_64</span><br><span class="line">时期       ：2</span><br><span class="line">版本    ：1.5.13</span><br><span class="line">发布    ：7.el7_2</span><br><span class="line">大小    ：602 k</span><br><span class="line">源    ：installed</span><br><span class="line">来自源：base</span><br><span class="line">简介    ： A library of functions for manipulating PNG image format files</span><br><span class="line">网址    ：http://www.libpng.org/pub/png/</span><br><span class="line">协议    ： zlib</span><br><span class="line"></span><br><span class="line">名称    ：libpng-devel</span><br><span class="line">架构    ：x86_64</span><br><span class="line">时期       ：2</span><br><span class="line">版本    ：1.5.13</span><br><span class="line">发布    ：7.el7_2</span><br><span class="line">大小    ：211 k</span><br><span class="line">源    ：installed</span><br><span class="line">来自源：base</span><br><span class="line">简介    ： Development tools for programs to manipulate PNG image format files</span><br><span class="line">网址    ：http://www.libpng.org/pub/png/</span><br><span class="line">协议    ： zlib</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>yum info</code> 命令查看已安装的软件选项。如果看到上面的结果说明安装成功。</p>
<h1 id="gflags的错误安装"><a href="#gflags的错误安装" class="headerlink" title="gflags的错误安装"></a>gflags的错误安装</h1><p>为了把他安装好，搞得我神魂颠倒，忘乎所以。真的是太多坑。最后通过 <a href="https://github.com/google/guetzli/issues/86" target="_blank" rel="external">issue</a> 得到了自己想要的答案。下面将给大家重现一下我的错误过程。</p>
<p>记得文章开头让大家设置的 <code>epel</code> 源吗？我用 <code>yum search gflags</code> 找到如下信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@play ~]# yum search gflags</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: centos.nethub.com.hk</span><br><span class="line"> * epel: ftp.jaist.ac.jp</span><br><span class="line"> * extras: mirrors.btte.net</span><br><span class="line"> * updates: mirror.lzu.edu.cn</span><br><span class="line">======================================================= N/S matched: gflags =======================================================</span><br><span class="line">gflags-devel.x86_64 : Development files for gflags</span><br><span class="line">gflags.x86_64 : Library for commandline flag processing</span><br></pre></td></tr></table></figure></p>
<p>因此，直接使用 <code>yum install gflags gflags-devel</code></p>
<p>然后去编译 <code>Guetzli</code> ，出现下面的错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">==== Building guetzli (release) ==== </span><br><span class="line">guetzli.cc &lt;命令行&gt;:0:18: 错误：‘google’不是一个命名空间名 guetzli/guetzli.cc:33:17: 附注：in expansion of macro ‘GFLAGS_NAMESPACE’ using namespace GFLAGS_NAMESPACE;</span><br><span class="line">^ guetzli/guetzli.cc:33:33: 错误：expected namespace-name before ‘;’ token using namespace GFLAGS_NAMESPACE; </span><br><span class="line">^ guetzli/guetzli.cc: 在函数‘int main(int, char**)’中: guetzli/guetzli.cc:194:55: 错误：‘SetUsageMessage’在此作用域中尚未声明 &quot;guetzli [flags] input_filename output_filename&quot;); </span><br><span class="line">^ guetzli/guetzli.cc:194:55: 附注：建议的替代： In file included from guetzli/guetzli.cc:24:0: /usr/include/gflags/gflags.h:331:29: 附注： ‘gflags::SetUsageMessage’ extern GFLAGS_DLL_DECL void SetUsageMessage(const std::string&amp; usage); </span><br><span class="line">^ guetzli/guetzli.cc:195:43: 错误：‘ParseCommandLineFlags’在此作用域中尚未声明 ParseCommandLineFlags(&amp;argc, &amp;argv, true); </span><br><span class="line">^ guetzli/guetzli.cc:195:43: 附注：建议的替代： In file included from guetzli/guetzli.cc:24:0: /usr/include/gflags/gflags.h:346:31: 附注： ‘gflags::ParseCommandLineFlags’ extern GFLAGS_DLL_DECL uint32 ParseCommandLineFlags(int argc, char** argv, bool remove_flags); </span><br><span class="line">^ guetzli/guetzli.cc:198:31: 错误：‘ShowUsageWithFlags’在此作用域中尚未声明 ShowUsageWithFlags(argv[0]); </span><br><span class="line">^ guetzli/guetzli.cc:198:31: 附注：建议的替代： In file included from guetzli/guetzli.cc:24:0: /usr/include/gflags/gflags.h:175:29: 附注： ‘gflags::ShowUsageWithFlags’ extern GFLAGS_DLL_DECL void ShowUsageWithFlags(const char *argv0); </span><br><span class="line">// what --help does </span><br><span class="line">^ make[1]: *** [obj/Release/guetzli.o] 错误 1 </span><br><span class="line">make: *** [guetzli] 错误 2</span><br></pre></td></tr></table></figure></p>
<p>错误中出现了多处 <strong>xx在此作用域中尚未声明</strong> 对应的 c++ 文件刚好是:<code>gflags.h</code></p>
<p>因此我猜测，可能是版本不对。通过 <code>yum info gflags</code> 确认一下当前的版本信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">名称    ：gflags</span><br><span class="line">架构    ：x86_64</span><br><span class="line">版本    ：2.1.1</span><br><span class="line">发布    ：6.el7</span><br><span class="line">大小    ：72 k</span><br><span class="line">源    ：epel/x86_64</span><br><span class="line">简介    ： Library for commandline flag processing</span><br><span class="line">网址    ：http://code.google.com/p/gflags</span><br><span class="line">协议    ： BSD</span><br></pre></td></tr></table></figure></p>
<p>是2.1版本。因为我mac上的 <code>Guetzli</code> 是可以运行的，因此查看一下mac上的 <code>gflags</code> 版本，得到如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gflags: stable 2.2.0 (bottled)</span><br><span class="line">Library for processing command-line flags</span><br></pre></td></tr></table></figure>
<p>ok，两者之间差了一个小版本。在 <a href="https://github.com/gflags/gflags" target="_blank" rel="external">gflags github</a> 查看发布的 <strong>release</strong> 版本。看到了最新的 2.2.0 版本。然后看到其对应的描述：</p>
<blockquote>
<p>This release adds support for use of the gflags library as external dependency not only in projects using CMake, but also Bazel, or pkg-config. </p>
</blockquote>
<p>我想，不管怎么样，先试试呗。</p>
<h1 id="正确安装-gflags-新版本"><a href="#正确安装-gflags-新版本" class="headerlink" title="正确安装 gflags 新版本"></a>正确安装 gflags 新版本</h1><p>由于 epel 还没有最新的源，只能自己动手编译了。<a href="https://github.com/gflags/gflags/blob/master/INSTALL.md" target="_blank" rel="external">官方编译指南</a></p>
<p><em>ps: Debian/Ubuntu Linux 可以直接使用 apt-get 来安装，但是好像有些版本也会出现版本问题，也可以动手自己编译最新的版本</em></p>
<p>由于 <code>gflags</code> 需要 <code>ccmake</code> 编译。所以需要先安装 cmake (安装 cmake 后，就可以使用 <code>ccmake</code>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install cmake</span><br></pre></td></tr></table></figure></p>
<p>好，搞定 <code>cmake</code> ，接下来开始 <code>gflags</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@play ~]# wget https://github.com/gflags/gflags/archive/v2.2.0.tar.gz</span><br><span class="line">[root@play ~]# tar -zxvf v2.2.0.tar.gz</span><br><span class="line">[root@play ~]# cd gflags</span><br><span class="line">[root@play ~]# mkdir build &amp;&amp; cd build</span><br><span class="line">[root@play ~]# ccmake ..</span><br></pre></td></tr></table></figure></p>
<p>这时会有一个界面，用来生成 configuration files，这里需要特别说明一下，建议大家进入界面后，一直按<code>c</code>，选项不明白的都不要设置，知道出现一个<code>g</code> 的时候，请 press g，截个图<br><img src="http://ol59nqr1i.bkt.clouddn.com/gflags-config.jpeg" alt="image"></p>
<p>接着来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@play ~]# make</span><br><span class="line">[root@play ~]# make install</span><br></pre></td></tr></table></figure></p>
<p>ok，现在安装好了gflags，如果编译过程中还有其他错误，应该是少了一些支持的 lib，根据错误去查一查。</p>
<h1 id="Guetzli安装"><a href="#Guetzli安装" class="headerlink" title="Guetzli安装"></a>Guetzli安装</h1><p>前面都是为了安装它而做的准备工作，接下来就来完成它的编译，so easy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@play ~]# git clone https://github.com/google/guetzli.git</span><br><span class="line">[root@play ~]# make</span><br></pre></td></tr></table></figure>
<p>然后会在目录中生成一个文件</p>
<blockquote>
<p>guetzli/bin/Release/guetzli</p>
</blockquote>
<p>将命令移动到自己的命令环境中，就可以使用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@play ~]# guetzli</span><br><span class="line">guetzli: Guetzli JPEG compressor. Usage:</span><br><span class="line">guetzli [flags] input_filename output_filename</span><br><span class="line"></span><br><span class="line">xxxxxx</span><br><span class="line"></span><br><span class="line">  Flags from guetzli/guetzli.cc:</span><br><span class="line">    -quality (Visual quality to aim for, expressed as a JPEG quality value.)</span><br><span class="line">      type: double default: 95</span><br><span class="line">    -verbose (Print a verbose trace of all attempts to standard output.)</span><br><span class="line">      type: bool default: false</span><br></pre></td></tr></table></figure></p>
<p>然后大家可是试一试压缩效果。后续会有文章介绍它的压缩效果，以及php中使用它。请持续关注。</p>
<h1 id="我要吐槽"><a href="#我要吐槽" class="headerlink" title="我要吐槽"></a>我要吐槽</h1><p>当我费劲心思解决这个问题后，作者 <code>robryk</code> 在issue 中告诉我，最新的代码已经把 gflags 依赖给移除了。因为出现相关问题的人太多了。详情</p>
<ul>
<li><a href="https://github.com/google/guetzli/pull/97" target="_blank" rel="external">https://github.com/google/guetzli/pull/97</a></li>
<li><a href="https://github.com/google/guetzli/issues/89" target="_blank" rel="external">https://github.com/google/guetzli/issues/89</a></li>
</ul>
<p>如果直接下载的是 <code>guetzli</code> 当前最新的代码(git clone <a href="https://github.com/google/guetzli.git)。" target="_blank" rel="external">https://github.com/google/guetzli.git)。</a></p>
<p>将不再需要 <code>gflags</code> 包了。只需要用 <code>yum install libpng-devel</code> 就好</p>
<p>然后编译 <code>guetzli</code> ，进入目录，直接 <code>make</code> 就可得到正确结果。</p>
<p>觉得本文不错，欢迎打赏：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/pay-qr.jpg?imageView2/2/w/500" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：接入支付宝当面付（扫码支付与条码支付）教程]]></title>
      <url>https://helei112g.github.io/2017/03/15/Payment%EF%BC%9A%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E5%BD%93%E9%9D%A2%E4%BB%98%EF%BC%88%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98%E4%B8%8E%E6%9D%A1%E7%A0%81%E6%94%AF%E4%BB%98%EF%BC%89%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>越写越觉得支付类的文档写这么细，会不会反而让大家觉得很复杂呀？其实都是同样的调用方式</p>
<p>这一篇，将把支付宝剩下的扫码支付与条码支付全部写清楚。<br><a id="more"></a></p>
<p><strong><code>Payment 3.0</code></strong> 支付宝的配置设置文档请 <a href="https://helei112g.github.io/2017/03/09/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B/">点击这里</a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>支付宝的当面付，包括扫码支付与条码支付。</p>
<ul>
<li>扫码支付，是消费者用手机去扫商家生成的二维码。个人觉得也可以将这个功能用在pc支付上。取代即时到账接口。</li>
<li>条码支付，商家用扫码枪读取用户支付宝上的条码。对应微信的刷卡支付。该项广泛用在超市结账时。</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>body</td>
<td>boolean</td>
<td>是</td>
<td>商品描述</td>
</tr>
<tr>
<td>subject</td>
<td>string</td>
<td>是</td>
<td>商品名称,该参数最长为128个汉字</td>
</tr>
<tr>
<td>order_no</td>
<td>string</td>
<td>是</td>
<td>商户网站唯一订单号</td>
</tr>
<tr>
<td>timeout_express</td>
<td>string</td>
<td>是</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。</td>
</tr>
<tr>
<td>amount</td>
<td>float</td>
<td>是</td>
<td>该笔订单的资金总额，单位为RMB-Yuan</td>
</tr>
<tr>
<td>store_id</td>
<td>string</td>
<td>否</td>
<td>商户门店编号 </td>
</tr>
<tr>
<td>operator_id</td>
<td>string</td>
<td>否</td>
<td>商户操作员编号</td>
</tr>
<tr>
<td>terminal_id</td>
<td>string</td>
<td>否</td>
<td>商户机具终端编号</td>
</tr>
<tr>
<td>alipay_store_id</td>
<td>string</td>
<td>否</td>
<td>支付宝店铺的门店ID</td>
</tr>
<tr>
<td>scene</td>
<td>string</td>
<td>是</td>
<td>条码支付时，必须设置</td>
</tr>
<tr>
<td>auth_code</td>
<td>string</td>
<td>是</td>
<td>条码支付时，必须设置</td>
</tr>
</tbody>
</table>
<p><strong><code>body</code></strong> 主要是对商品的描述，根据自己的业务写就好，不过不要用一些非常特殊的字符，支付宝可能会进行一些处理，导致你的结果与预期不一样</p>
<p><strong><code>subject</code></strong> 可以写一下商品名称信息，主要是方便支付宝后台对账时查看</p>
<p><strong><code>order_no</code></strong> 自己生成的订单号，每次下单的单号必须唯一。也就是说：同一个 order_no 他的其他下单数据不能发生变化，价格、名称等等。如果有变化，需要重新生成一个订单号。</p>
<p><strong><code>timeout_express</code></strong> 订单过期时间，很简单，你希望在那一刻过期，就写那个点的时间戳。只会精确到分钟</p>
<p><strong><code>amount</code></strong> 订单的金额，就是用户实际需要支付的金额。</p>
<p><strong><code>store_id</code></strong> 门店编号，这部分数据主要是支付宝为了将业务深化到线下而提供的，如果用不到，不设置就好。</p>
<p><strong><code>operator_id</code></strong> 商户操作员编号，可以不设置。</p>
<p><strong><code>terminal_id</code></strong> 商户机具终端编号，可以不设置。</p>
<p><strong><code>alipay_store_id</code></strong> 支付宝店铺的门店ID，没有的话，也可以不设置。</p>
<p><strong><code>scene</code></strong> 条码支付，必须设置该选项，条码支付，取值：bar_code 声波支付，取值：wave_code</p>
<p><strong><code>auth_code</code></strong> 条码支付必须设置。</p>
<p>在上面的参数中，除了特别说明的，其它部分，扫码支付与条码支付都需要。</p>
<p>代码调用。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Client</span>\<span class="title">Charge</span>;</span><br><span class="line"></span><br><span class="line">$config = <span class="keyword">require_once</span>(<span class="string">'./aliconfig.php'</span>);<span class="comment">// 支付宝的配置信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$channel = <span class="string">'ali_qr'</span>;<span class="comment">// ali_bar</span></span><br><span class="line">$payData = [</span><br><span class="line">    <span class="string">'body'</span> =&gt; <span class="string">'一个苹果'</span>,</span><br><span class="line">    <span class="string">'subject'</span> =&gt; <span class="string">'牛逼公司--付款吧'</span>,</span><br><span class="line">    <span class="string">'order_no'</span> =&gt; <span class="string">'NB12312355'</span>,</span><br><span class="line">    <span class="string">'timeout_express'</span> =&gt; <span class="string">'1489241888'</span>,</span><br><span class="line">    <span class="string">'amount'</span> =&gt; <span class="string">'100'</span>,</span><br><span class="line">    <span class="string">'return_param'</span> =&gt; <span class="string">'buy some'</span>,</span><br><span class="line">    <span class="string">'goods_type'</span> =&gt; <span class="number">1</span>,<span class="comment">// 默认值为1，因此也可以省略</span></span><br><span class="line">    <span class="string">'store_id'</span> =&gt; <span class="string">''</span>,<span class="comment">// 没有就不设置</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $str = Charge::run($channel, $config, $payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> htmlspecialchars($str);</span><br></pre></td></tr></table></figure>
<p>如果使用的扫码支付，  <code>$channel = &#39;ali_qr&#39;</code></p>
<p>则返回一个url。大家可以通过将返回的字符串生成一个二维码。即可进行扫码支付。</p>
<p>另外请记得，如果使用的沙箱请使用对应的沙箱支付宝来扫码。关于沙箱的介绍。<a href="https://helei112g.github.io/2017/03/12/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E6%95%99%E7%A8%8B/">看这里</a></p>
<p>如果使用的条码支付，  <code>$channel = &#39;ali_bar&#39;</code></p>
<p>必须设置以下两个字段</p>
<ul>
<li>scene   支付场景 条码支付，取值：bar_code 声波支付，取值：wave_code</li>
<li>auth_code   支付授权码，也就是用户手机条码对应的值。</li>
</ul>
<p>这个接口测试时，大家可以手动把条码的值，输入进去</p>
<p>ok！支付宝支付类的接口基本就讲完了。接下来将开始讲解微信支付的接口。使用起来都一样，不一样的仅仅是参数部分。还是安排将微信支付的配置开一篇单独的文章进行讲解。</p>
<hr>
<p>如果你有不清楚的或者愿意交流的地方，请联系我：</p>
<p><strong>邮箱</strong>：dayugog@gmail.com</p>
<p>如果你觉得这个项目有帮助到你，请打赏我，让我有动力持续下去<a href="#">左边微信，右边支付宝</a>：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-wx-pay.jpg?imageView2/2/w/500" alt="image"></p>
<p><strong>ps：</strong> 一般性的问题请大家可以先查资料，如果实在无法解决找我吧（不免费服务）。</p>
<p>我的个人公众号(技术、创业主题)，希望在这里遇见你：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：支付宝移动支付服务端教程]]></title>
      <url>https://helei112g.github.io/2017/03/14/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>默默的写文档，为什么要写呢？因为我想要被你们点赞，被你们打赏。</p>
<a id="more"></a>
<p><strong><code>Payment 3.0</code></strong> 支付宝的配置设置文档请 <a href="https://helei112g.github.io/2017/03/09/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B/">点击这里</a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>移动支付，适用场景:</p>
<blockquote>
<p>适用于商家在App应用中集成支付宝支付功能。<br>商家APP调用支付宝提供的SDK调用支付宝客户端内的支付模块，商家APP会跳转到支付宝中完成支付，支付完后跳回到商家APP内，最后展示支付结果。<br>目前支持手机系统有：iOS（苹果）、Android（安卓）。</p>
</blockquote>
<p>现在来讲服务端的部分。支持的参数如下表格。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>body</td>
<td>boolean</td>
<td>是</td>
<td>商品描述</td>
</tr>
<tr>
<td>subject</td>
<td>string</td>
<td>是</td>
<td>商品名称,该参数最长为128个汉字</td>
</tr>
<tr>
<td>order_no</td>
<td>string</td>
<td>是</td>
<td>商户网站唯一订单号</td>
</tr>
<tr>
<td>timeout_express</td>
<td>string</td>
<td>是</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。</td>
</tr>
<tr>
<td>amount</td>
<td>float</td>
<td>是</td>
<td>该笔订单的资金总额，单位为RMB-Yuan</td>
</tr>
<tr>
<td>return_param</td>
<td>string</td>
<td>是</td>
<td>公用回传参数</td>
</tr>
<tr>
<td>goods_type</td>
<td>string</td>
<td>否</td>
<td>商品主类型：0—虚拟类商品，1—实物类商品 默认为1</td>
</tr>
<tr>
<td>store_id</td>
<td>string</td>
<td>否</td>
<td>商户门店编号 </td>
</tr>
</tbody>
</table>
<p><strong><code>body</code></strong> 主要是对商品的描述，根据自己的业务写就好，不过不要用一些非常特殊的字符，支付宝可能会进行一些处理，导致你的结果与预期不一样</p>
<p><strong><code>subject</code></strong> 可以写一下商品名称信息，主要是方便支付宝后台对账时查看</p>
<p><strong><code>order_no</code></strong> 自己生成的订单号，每次下单的单号必须唯一。也就是说：同一个 order_no 他的其他下单数据不能发生变化，价格、名称等等。如果有变化，需要重新生成一个订单号。</p>
<p><strong><code>timeout_express</code></strong> 订单过期时间，很简单，你希望在那一刻过期，就写那个点的时间戳。只会精确到分钟</p>
<p><strong><code>amount</code></strong> 订单的金额，就是用户实际需要支付的金额。</p>
<p><strong><code>return_param</code></strong>  希望支付宝异步通知时，原样返回给你的数据，同样注意避免一些特殊字符</p>
<p><strong><code>goods_type</code></strong> 用来区分购买的是实际商品还是虚拟商品，虚拟商品不需要物流发货，并且 虚拟类商品不支持使用花呗渠道</p>
<p><strong><code>store_id</code></strong> 门店编号，这部分数据主要是支付宝为了将业务深化到线下而提供的，如果用不到，不设置就好。</p>
<p>代码调用。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Client</span>\<span class="title">Charge</span>;</span><br><span class="line"></span><br><span class="line">$config = <span class="keyword">require_once</span>(<span class="string">'./aliconfig.php'</span>);<span class="comment">// 支付宝的配置信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$channel = <span class="string">'ali_app'</span>;</span><br><span class="line">$payData = [</span><br><span class="line">    <span class="string">'body'</span> =&gt; <span class="string">'一个苹果'</span>,</span><br><span class="line">    <span class="string">'subject'</span> =&gt; <span class="string">'牛逼公司--付款吧'</span>,</span><br><span class="line">    <span class="string">'order_no'</span> =&gt; <span class="string">'NB12312355'</span>,</span><br><span class="line">    <span class="string">'timeout_express'</span> =&gt; <span class="string">'1489241888'</span>,</span><br><span class="line">    <span class="string">'amount'</span> =&gt; <span class="string">'100'</span>,</span><br><span class="line">    <span class="string">'return_param'</span> =&gt; <span class="string">'buy some'</span>,</span><br><span class="line">    <span class="string">'goods_type'</span> =&gt; <span class="number">1</span>,<span class="comment">// 默认值为1，因此也可以省略</span></span><br><span class="line">    <span class="string">'store_id'</span> =&gt; <span class="string">''</span>,<span class="comment">// 没有就不设置</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $str = Charge::run($channel, $config, $payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> htmlspecialchars($str);</span><br></pre></td></tr></table></figure>
<p>这里返回的是一个拼接好的字符串，客户端（IOS 或者 Android） 拿到后，就可调起支付宝进行支付。客户端如何调起，请看资料</p>
<ul>
<li><strong><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.J4lJwo&amp;treeId=204&amp;articleId=105296&amp;docType=1" target="_blank" rel="external">Andorid集成流程</a></strong></li>
</ul>
<ul>
<li><strong><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.q2sevn&amp;treeId=204&amp;articleId=105295&amp;docType=1" target="_blank" rel="external">Ios集成流程</a></strong></li>
</ul>
<p>这篇文章真的太偷懒了。完全就是把 <a href="https://helei112g.github.io/2017/03/12/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E6%95%99%E7%A8%8B/">手机网站支付</a> 拷贝过来了而已。</p>
<p>唯一的差别在于  <code>$channel</code> 参数的不同。</p>
<p><code>$channel</code> 可取值：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ali_web</td>
<td>即时到账</td>
</tr>
<tr>
<td>ali_app</td>
<td>app支付（移动支付）</td>
</tr>
<tr>
<td>ali_wap</td>
<td>H5支付（手机网站支付、wap支付）</td>
</tr>
<tr>
<td>ali_qr</td>
<td>当面付中的扫码支付</td>
</tr>
<tr>
<td>ali_bar</td>
<td>当面付中的条码支付</td>
</tr>
</tbody>
</table>
<blockquote>
<p>还剩下支付宝的当面付，包括：扫码支付  条码支付  将会在下一篇全部写完。 </p>
</blockquote>
<p><a href="https://helei112g.github.io/2017/03/15/Payment%EF%BC%9A%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E5%BD%93%E9%9D%A2%E4%BB%98%EF%BC%88%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98%E4%B8%8E%E6%9D%A1%E7%A0%81%E6%94%AF%E4%BB%98%EF%BC%89%E6%95%99%E7%A8%8B/">点击这里看当面付</a> 当面付包括：扫码支付  条码支付</p>
<hr>
<p>如果你有不清楚的或者愿意交流的地方，请联系我：</p>
<p><strong>邮箱</strong>：dayugog@gmail.com</p>
<p>如果你觉得这个项目有帮助到你，请打赏我，让我有动力持续下去<a href="#">左边微信，右边支付宝</a>：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-wx-pay.jpg?imageView2/2/w/500" alt="image"></p>
<p><strong>ps：</strong> 一般性的问题请大家可以先查资料，如果实在无法解决找我吧（不免费服务）。</p>
<p>我的个人公众号(技术、创业主题)，希望在这里遇见你：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：支付宝手机网站支付教程]]></title>
      <url>https://helei112g.github.io/2017/03/12/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>支付宝的H5支付体验真不错（支付宝叫他手机网站支付）。</p>
<p>反观微信支付干嘛要把H5支付藏起来？而且体验还那么差。<br><a id="more"></a></p>
<p><strong><code>Payment 3.0</code></strong> 支付宝的配置设置文档请 <a href="https://helei112g.github.io/2017/03/09/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B/">点击这里</a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>从本篇开始，将用支付宝的沙箱方式进行演示，在项目的 <code>payment/examples</code> 中我已经提供了我的沙箱帐号。</p>
<p>新版接口已经同时支持 RSA 与 RSA2 。更换签名方式时，注意公钥的变化，在demo中我进行了注释。</p>
<p>另外支付宝为了提升支付体验，可以将 <code>手机网站支付转Native支付</code> ，对于混合应用是非常好的体验。这部分服务器端的业务逻辑无须变动，只需要客户端更新到最新的 <a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.71N4co&amp;treeId=203&amp;articleId=106493&amp;docType=1" target="_blank" rel="external">详情地址</a></p>
<p>还是先讲手机网站支付需要设置哪些参数，后面用代码演示。代码部分大家会发现跟 <a href="https://helei112g.github.io/2017/03/11/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5%E6%95%99%E7%A8%8B/"><code>即时到账</code></a> 支付的使用完全一致。他们的不同之处仅仅是下单参数的区别。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>body</td>
<td>boolean</td>
<td>是</td>
<td>商品描述</td>
</tr>
<tr>
<td>subject</td>
<td>string</td>
<td>是</td>
<td>商品名称,该参数最长为128个汉字</td>
</tr>
<tr>
<td>order_no</td>
<td>string</td>
<td>是</td>
<td>商户网站唯一订单号</td>
</tr>
<tr>
<td>timeout_express</td>
<td>string</td>
<td>是</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。</td>
</tr>
<tr>
<td>amount</td>
<td>float</td>
<td>是</td>
<td>该笔订单的资金总额，单位为RMB-Yuan</td>
</tr>
<tr>
<td>return_param</td>
<td>string</td>
<td>是</td>
<td>公用回传参数</td>
</tr>
<tr>
<td>goods_type</td>
<td>string</td>
<td>否</td>
<td>商品主类型：0—虚拟类商品，1—实物类商品 默认为1</td>
</tr>
<tr>
<td>store_id</td>
<td>string</td>
<td>否</td>
<td>商户门店编号 </td>
</tr>
</tbody>
</table>
<p><strong><code>body</code></strong> 主要是对商品的描述，根据自己的业务写就好，不过不要用一些非常特殊的字符，支付宝可能会进行一些处理，导致你的结果与预期不一样</p>
<p><strong><code>subject</code></strong> 可以写一下商品名称信息，主要是方便支付宝后台对账时查看</p>
<p><strong><code>order_no</code></strong> 自己生成的订单号，每次下单的单号必须唯一。也就是说：同一个 order_no 他的其他下单数据不能发生变化，价格、名称等等。如果有变化，需要重新生成一个订单号。</p>
<p><strong><code>timeout_express</code></strong> 订单过期时间，很简单，你希望在那一刻过期，就写那个点的时间戳。只会精确到分钟</p>
<p><strong><code>amount</code></strong> 订单的金额，就是用户实际需要支付的金额。</p>
<p><strong><code>return_param</code></strong>  希望支付宝异步通知时，原样返回给你的数据，同样注意避免一些特殊字符</p>
<p><strong><code>goods_type</code></strong> 用来区分购买的是实际商品还是虚拟商品，虚拟商品不需要物流发货，并且 虚拟类商品不支持使用花呗渠道</p>
<p><strong><code>store_id</code></strong> 门店编号，这部分数据主要是支付宝为了将业务深化到线下而提供的，如果用不到，不设置就好。</p>
<p>代码调用。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Client</span>\<span class="title">Charge</span>;</span><br><span class="line"></span><br><span class="line">$config = <span class="keyword">require_once</span>(<span class="string">'./aliconfig.php'</span>);<span class="comment">// 支付宝的配置信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$channel = <span class="string">'ali_wap'</span>;</span><br><span class="line">$payData = [</span><br><span class="line">    <span class="string">'body'</span> =&gt; <span class="string">'一个苹果'</span>,</span><br><span class="line">    <span class="string">'subject'</span> =&gt; <span class="string">'牛逼公司--付款吧'</span>,</span><br><span class="line">    <span class="string">'order_no'</span> =&gt; <span class="string">'NB12312355'</span>,</span><br><span class="line">    <span class="string">'timeout_express'</span> =&gt; <span class="string">'1489241888'</span>,</span><br><span class="line">    <span class="string">'amount'</span> =&gt; <span class="string">'100'</span>,</span><br><span class="line">    <span class="string">'return_param'</span> =&gt; <span class="string">'buy some'</span>,</span><br><span class="line">    <span class="string">'goods_type'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">    <span class="string">'store_id'</span> =&gt; <span class="string">''</span>,<span class="comment">// 没有就不设置</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $payUrl = Charge::run($channel, $config, $payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> htmlspecialchars($payUrl);</span><br></pre></td></tr></table></figure>
<p>大家在这里可以回到即时到账的部分对比一下，调用代码完全一致。唯一的差别就是 <code>payData</code> 中的些微差别。<br>多了一个 <code>store_id</code> 参数。少了另外两个参数： qr_mod   paymethod</p>
<p>后面的几种支付在调用上也是如此没有差别，变化主要时围绕 <code>payData</code> 进行的。</p>
<p>当然这里最重要的变化是：<strong><code>$channel</code></strong>  。Payment 知道使用那种支付方式，完全是根据这个参数来设置的。因此一定要设置正确。再把对应的信息贴出来。方便大家查看。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ali_web</td>
<td>即时到账</td>
</tr>
<tr>
<td>ali_app</td>
<td>app支付（移动支付）</td>
</tr>
<tr>
<td>ali_wap</td>
<td>H5支付（手机网站支付、wap支付）</td>
</tr>
<tr>
<td>ali_qr</td>
<td>当面付中的扫码支付</td>
</tr>
<tr>
<td>ali_bar</td>
<td>当面付中的条码支付</td>
</tr>
</tbody>
</table>
<p>另外这里返回的依然是一个url。大家根据自己的业务进行合理的处理。<code>htmlspecialchars()</code> 函数的目的还是为了转义，正式使用时，请注意。</p>
<p>关于异步通知部分，会有专门的文章讲解，这里暂时略过。请关注后面的文章。接下来会说到最热门的<a href="https://helei112g.github.io/2017/03/14/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%99%E7%A8%8B/">移动支付</a></p>
<hr>
<p>如果你有不清楚的或者愿意交流的地方，请联系我：</p>
<p><strong>邮箱</strong>：dayugog@gmail.com</p>
<p>如果你觉得这个项目有帮助到你，请打赏我，让我有动力持续下去 <a href="#">左边微信，右边支付宝</a>：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-wx-pay.jpg?imageView2/2/w/500" alt="image"></p>
<p><strong>ps：</strong> 一般性的问题请大家可以先查资料，如果实在无法解决找我吧（不免费服务）。</p>
<h2 id="关于沙箱"><a href="#关于沙箱" class="headerlink" title="关于沙箱"></a>关于沙箱</h2><p>对于支付宝的沙箱功能，我得再啰嗦几句。先把我配置的沙箱帐号贡献出来。方便大家测试</p>
<p><strong>商家信息</strong></p>
<ul>
<li>商家账号  naacvg9185@sandbox.com</li>
<li>商户UID   2088102169252684</li>
<li>appId     2016073100130857</li>
</ul>
<p><strong>买家信息</strong></p>
<ul>
<li>买家账号    aaqlmq0729@sandbox.com</li>
<li>登录密码    111111</li>
<li>支付密码    111111</li>
</ul>
<p>当前沙箱的买家帐号，只能使用 <code>android</code> 版本进行登陆。</p>
<blockquote>
<p>沙箱钱包只支持扫一扫、付款码、门店详情页功能，其余功能不提供</p>
</blockquote>
<p><img src="https://zos.alipayobjects.com/rmsportal/CaXHDDXkdxikcZP.png" alt="image"></p>
<p>所以大家，不要在使用我提供的沙箱帐号时，用你们真实的支付宝帐号去支付，那样子是不会成功的。沙箱的所有功能，都只能使用上面的沙箱帐号去完成。</p>
<p>我的个人公众号(技术、创业主题)，希望在这里遇见你：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：支付宝即时到账接口接入教程]]></title>
      <url>https://helei112g.github.io/2017/03/11/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>记住，如果觉得文档写得不清楚，一定要告诉我。励志写好文档为大家服务！</p>
<a id="more"></a>
<hr>
<p><strong><code>Payment 3.0</code></strong> 支付宝的配置设置文档请 <a href="https://helei112g.github.io/2017/03/09/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B/">点击这里</a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>支付宝从新版本开始，提供了沙箱方式，方便进行调试。但是，即时到账支付宝没有提供沙箱模式。因此大家在使用过程中，注意设置配置。</p>
<p>我在项目中提供的初始配置也不能用于测试 <strong>即时到账接口</strong>。</p>
<blockquote>
<p>即时到账属于老版本接口。不支持 RSA2 的签名方式，请设置为 RSA 签名方式。</p>
</blockquote>
<p>支付宝的支付种类比较多。先从即时到账开始吧。</p>
<p>即时到账 主要应用于网站支付。当前也可使用支付宝提供的当面付–扫码支付来完成网站支付的业务。</p>
<p>即时到账接口属于支付宝老版本接口，当前 Payment 依然将其进行了保留。后期会跟随支付宝公告进行调整。<br>即时到账的权限需要在支付宝商家平台进行签约。</p>
<p><strong>签约地址:</strong> <a href="https://b.alipay.com/order/productDetail.htm?productId=2015110218012942" target="_blank" rel="external">https://b.alipay.com/order/productDetail.htm?productId=2015110218012942</a></p>
<p>即时到账签约后，默认开通以下两个接口的权限：</p>
<ul>
<li>即时到账交易接口(create_direct_pay_by_user)</li>
<li>即时到账批量退款有密接口(refund_fastpay_by_platform_pwd)</li>
</ul>
<p>但是 <code>Payment3.x</code> 并未接入 <strong>即时到账批量退款有密接口</strong>。大家可以通过 新版退款接口发起退款操作。<br>退款操作文档，可点击这里（TODO）</p>
<p>先上 <strong>即时到账发起支付</strong> 需要的参数列表</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>body</td>
<td>boolean</td>
<td>是</td>
<td>商品描述</td>
</tr>
<tr>
<td>subject</td>
<td>string</td>
<td>是</td>
<td>商品名称,该参数最长为128个汉字</td>
</tr>
<tr>
<td>order_no</td>
<td>string</td>
<td>是</td>
<td>商户网站唯一订单号</td>
</tr>
<tr>
<td>timeout_express</td>
<td>string</td>
<td>是</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。</td>
</tr>
<tr>
<td>amount</td>
<td>float</td>
<td>是</td>
<td>该笔订单的资金总额，单位为RMB-Yuan</td>
</tr>
<tr>
<td>return_param</td>
<td>string</td>
<td>是</td>
<td>公用回传参数</td>
</tr>
<tr>
<td>qr_mod</td>
<td>string</td>
<td>否</td>
<td>扫码支付方式</td>
</tr>
<tr>
<td>paymethod</td>
<td>string</td>
<td>否</td>
<td>默认支付方式</td>
</tr>
<tr>
<td>goods_type</td>
<td>string</td>
<td>否</td>
<td>商品主类型：0—虚拟类商品，1—实物类商品 默认为1</td>
</tr>
</tbody>
</table>
<p><strong><code>body</code></strong> 主要是对商品的描述，根据自己的业务写就好，不过不要用一些非常特殊的字符，支付宝可能会进行一些处理，导致你的结果与预期不一样</p>
<p><strong><code>subject</code></strong> 可以写一下商品名称信息，主要是方便支付宝后台对账时查看</p>
<p><strong><code>order_no</code></strong> 自己生成的订单号，每次下单的单号必须唯一。也就是说：同一个 order_no 他的其他下单数据不能发生变化，价格、名称等等。如果有变化，需要重新生成一个订单号。</p>
<p><strong><code>timeout_express</code></strong> 订单过期时间，很简单，你希望在那一刻过期，就写那个点的时间戳。只会精确到分钟</p>
<p><strong><code>amount</code></strong> 订单的金额，就是用户实际需要支付的金额。</p>
<p><strong><code>return_param</code></strong>  希望支付宝异步通知时，原样返回给你的数据，同样注意避免一些特殊字符</p>
<p><strong><code>qr_mod</code></strong> 这个参数可以不设置，如果没有特殊需求建议不设置，可设置：0 1 2 3  。效果可以自己看看</p>
<p><strong><code>paymethod</code></strong> 当用户进行支付时，默认使用的付款方式。可选值：creditPay（信用支付）directPay（余额支付）</p>
<p><strong><code>goods_type</code></strong> 用来区分购买的是实际商品还是虚拟商品，虚拟商品不需要物流发货，并且 虚拟类商品不支持使用花呗渠道</p>
<hr>
<p>ok，以上就是需要发起支付的全部参数了。具体到 sdk 如何调用。看代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use Payment\Common\PayException;</span><br><span class="line">use Payment\Client\Charge;</span><br><span class="line"></span><br><span class="line">$config = require_once(&apos;./aliconfig.php&apos;);// 这里我假设大家都已经配置好了。不会的请去看配置设置文档</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$channel = &apos;ali_web&apos;;</span><br><span class="line">$payData = [</span><br><span class="line">    // 按照上表格中的信息配置一个数组</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    $payUrl = Charge::run($channel, $config, $payData);</span><br><span class="line">&#125; catch (PayException $e) &#123;</span><br><span class="line">    // 异常处理</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo htmlspecialchars($payUrl);</span><br></pre></td></tr></table></figure>
<p>即时到账的代码就全部完成了。</p>
<p><code>$payUrl</code>  是跳转向支付宝支付的一个连接。访问该连接即可跳转到支付宝。</p>
<p>接下来说下重点，请仔细往下看。</p>
<blockquote>
<p>这里需要注意的一个点： htmlspecialchars() 函数在正式环境上，如果时进行url的跳转操作，请不要用它进行转义。我这里使用它是为了方便输出到页面上。因为 &amp;not 是一个特殊符号，如果不转移，在网页上无法正常显示。</p>
</blockquote>
<p><code>Payment</code> 的设计思路是将配置文件与下单数据进行了分离。配置文件一般来讲是静态的，不会经常变更，并且大家都会用到。而下单的订单数据则不同，每一个支付接口需要的下单数据不同，并且根据业务，其对应的值也不稳定，常常发生变化。</p>
<p>其次，还有一个 <code>$channel</code> 参数，这个简单来讲，就是用来标记，你现在想要使用那种接口。可以取的参数如下：</p>
<p><em>channel可取值</em></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ali_web</td>
<td>即时到账</td>
</tr>
<tr>
<td>ali_app</td>
<td>app支付（移动支付）</td>
</tr>
<tr>
<td>ali_wap</td>
<td>H5支付（手机网站支付、wap支付）</td>
</tr>
<tr>
<td>ali_qr</td>
<td>当面付中的扫码支付</td>
</tr>
<tr>
<td>ali_bar</td>
<td>当面付中的条码支付</td>
</tr>
</tbody>
</table>
<p>接下来将说道<a href="https://helei112g.github.io/2017/03/12/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E6%95%99%E7%A8%8B/">手机网站支付</a>，会给大家说到沙箱的问题</p>
<hr>
<p>如果你有不清楚的或者愿意交流的地方，请联系我：</p>
<p><strong>邮箱</strong>：dayugog@gmail.com</p>
<p>如果你觉得这个项目有帮助到你，请打赏我，让我有动力持续下去<a href="#">左边微信，右边支付宝</a>：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-wx-pay.jpg?imageView2/2/w/500" alt="image"></p>
<p><strong>ps：</strong> 一般性的问题请大家可以先查资料，如果实在无法解决找我吧（不免费服务）。</p>
<p>我的个人公众号(技术、创业主题)，希望在这里遇见你：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：支付宝支付配置文件设置教程]]></title>
      <url>https://helei112g.github.io/2017/03/09/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>终于把3.0版本做好了。从今天开始好好写文档，让大家做支付做的开心点。<br><a id="more"></a></p>
<p>项目GitHub地址：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>从2016年6月payment做出来，到这一版本（3.0），坚持了快一年啦。感谢这期间给我支持（打赏与协作）的人。</p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external"><code>Payment</code></a> 主要针对支付宝支付、微信支付的接口进行了聚合。开发者无需重复集成繁琐的支付接口，使用 <a href="https://github.com/helei112g/payment" target="_blank" rel="external"><code>Payment</code></a> 就能应对所有支付场景，快速接入支付功能。</p>
<p><code>Payment</code> 针对不同支付服务商的接口，提供了统一的调用方式，并且内部将签名、验签进行了集成，使用者只需要喂数据然后拿到结果进行自己的业务即可。完全屏蔽支付宝与微信内部繁杂的细节。只要按照我的文档操作，10分钟可完成支付流程。</p>
<p>当前 <a href="https://github.com/helei112g/payment" target="_blank" rel="external"><code>Payment</code></a> 基本接入完支付宝与微信的资金相关接口。到当前为止，<code>Payment SDK</code> 主要支持功能如下：</p>
<p>支持的支付宝相关接口清单：</p>
<ul>
<li>即时到账功能（主要用于pc上支付）</li>
<li>手机网站支付（WAP支付）</li>
<li>APP支付（移动支付）</li>
<li>当面付（扫码支付与条码支付）</li>
<li>交易查询（支付订单查询接口）</li>
<li>退款接口（完成支付的订单，可通过该接口完成退款）</li>
<li>退款查询接口（退款接口需要通过该接口进行查询状态）</li>
<li>单笔转账到支付宝账户接口（只能转到用户支付宝帐号）</li>
<li>转账订单查询接口（查询转账订单状态）</li>
</ul>
<p><em>ps：</em> 支付宝接口从 payment 3.0 开始，仅支持支付宝新版本接口。</p>
<p>支持的微信支付相关接口清单：</p>
<ul>
<li>手机网站支付（H5支付，特殊商家可用）</li>
<li>APP支付（移动支付）</li>
<li>公众号支付</li>
<li>刷卡支付（类似支付宝的条码支付）</li>
<li>小程序支付</li>
<li>交易查询（支付订单查询）</li>
<li>申请退款接口</li>
<li>查询退款接口</li>
<li>企业付款给个人接口</li>
<li>查询企业付款接口</li>
</ul>
<p>微信最糟糕的就是，不同支付接口，需要申请不同的商户号。这里简单总结一下：</p>
<p><strong>APP支付</strong>  必须到 微信开放平台申请一个应用，然后去申请开通支付功能，申请的商户帐号无法用于 公众号支付与小程序支付。</p>
<p><strong>公众号支付</strong> 必须首先有一个认证的服务号，然后到公众号后台进行申请开通支付功能。又会获得一个商户号</p>
<p><strong>小程序支付</strong> 微信分配的小程序ID，所以恭喜你，你又有了一个商户号</p>
<p>至于其他支付，目前检测好像可用共享。也就只剩下一个刷卡支付了。</p>
<hr>
<p>本文主要讲解支付宝的配置文件，配置清单如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'use_sandbox'</span>           =&gt; <span class="keyword">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'partner'</span>               =&gt; <span class="string">'2088102169252684'</span>,</span><br><span class="line">    <span class="string">'app_id'</span>                =&gt; <span class="string">'2016073100130857'</span>,</span><br><span class="line">    <span class="string">'sign_type'</span>             =&gt; <span class="string">'RSA2'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'ali_public_key'</span>        =&gt; <span class="string">'MIIBIjANBgkqhkiG9w0BAQEFAAOCAU3GYXkAaumdWQt7IDAQAB'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>       =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'rsa_private_key.pem'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'limit_pay'</span>             =&gt; [</span><br><span class="line">        <span class="comment">//'balance',</span></span><br><span class="line">        <span class="comment">//'moneyFund',</span></span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>            =&gt; <span class="string">'https://helei112g.github.io/'</span>,</span><br><span class="line">    <span class="string">'return_url'</span>            =&gt; <span class="string">'https://helei112g.github.io/'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'return_raw'</span>            =&gt; <span class="keyword">false</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>在支付中最麻烦的就是配置密钥。这里逐一为大家说明每一个配置的含义、以及如何进行设置。<br>其中 <strong>是否必须</strong> 列表中如果标记为 <code>是</code>  ，则该项必须设置，否则sdk将无法得到结果。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>use_sandbox</td>
<td>boolean</td>
<td>否</td>
<td>是否开启沙箱模式</td>
</tr>
<tr>
<td>partner</td>
<td>string</td>
<td>是</td>
<td>商户UID，以2088开头</td>
</tr>
<tr>
<td>app_id</td>
<td>string</td>
<td>是</td>
<td>支付宝分配给开发者的应用ID</td>
</tr>
<tr>
<td>sign_type</td>
<td>string</td>
<td>是</td>
<td>签名方式</td>
</tr>
<tr>
<td>ali_public_key</td>
<td>string</td>
<td>是</td>
<td>支付宝公钥</td>
</tr>
<tr>
<td>rsa_private_key</td>
<td>string</td>
<td>是</td>
<td>用户应用私钥</td>
</tr>
<tr>
<td>limit_pay</td>
<td>string</td>
<td>否</td>
<td>限制的支付方式</td>
</tr>
<tr>
<td>notify_url</td>
<td>string</td>
<td>是</td>
<td>支付宝异步通知的服务器地址</td>
</tr>
<tr>
<td>return_url</td>
<td>string</td>
<td>否</td>
<td>支付报支付成功返回地址</td>
</tr>
<tr>
<td>return_raw</td>
<td>boolean</td>
<td>否</td>
<td>是否返回支付宝原始数据</td>
</tr>
</tbody>
</table>
<p>接下来对每一个参数详细说明，不同的设置带来的不同效果。</p>
<p><strong><code>use_sandbox</code></strong> 支付宝新版本提供了沙箱模式。如果该选项设置为 <code>true</code> 则使用支付宝的沙箱功能。<br>下面简单介绍沙箱的使用方式。</p>
<p>首先登陆 <a href="https://open.alipay.com" target="_blank" rel="external">蚂蚁金服开放平台</a> 按照下图找到自己的沙箱应用。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-sanbox.jpeg?imageView2/2/w/600" alt="image"></p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-sandbox-info.jpeg?imageView2/2/w/600" alt="image"></p>
<p>大家注意截图，重要的配置信息均来自这里。</p>
<p><strong><code>partner</code></strong> 对应图中的 商户UID，如果是正式应用，可用在【我的应用】=》【应用】中找到对应的信息。<br>这部分信息较敏感，就不截图了。</p>
<p><strong><code>app_id</code></strong> 就是对应的创建的应用的id。图中有很醒目的字标记。</p>
<p><strong><code>sign_type</code></strong> 请求支付时，数据加密的方式，目前支持RSA2和RSA，推荐使用RSA2。你完全不用管签名的实现，只需要这里做一下配置就好。</p>
<p>接下来，密钥的配置是重点，70% 的支付无法成功的原因，均是密钥设置问题。<br>关于密钥如何生成与配置，请看</p>
<p><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.XduKK8&amp;treeId=291&amp;articleId=106103&amp;docType=1" target="_blank" rel="external">支付宝官方密钥生成与配置教程</a></p>
<p><strong><code>ali_public_key</code></strong>  注意看这张图的红线部分，只要上传自己应用的公钥后，可用点这里，查看支付宝公钥，可获取到支付宝的公钥。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-sandbox-info.jpeg?imageView2/2/w/600" alt="image"></p>
<p>这里一定要记得是 <strong>支付宝的公钥</strong>，不是你自己本地生成的，而是在开发平台中上传自己的公钥后，拿到的支付宝公钥。</p>
<p>接下来就是这个配置该如何填写了。这里支持文件的方式，你可以将支付宝公钥复制到一个单独的文件，然后这个字段填写对应文件的路径。例如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'ali_public_key'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'alipay_public_key_rsa.pem'</span></span><br></pre></td></tr></table></figure></p>
<p>你也可用直接将支付宝公钥的值，填入这里，例如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'ali_public_key'</span> =&gt; <span class="string">'MIIBIjANBgkqhkiG9w0BAQEFAAOO1BU3GYXkAaumdWQt7f+khoFoSw+x8yqQIDAQAB'</span>,</span><br></pre></td></tr></table></figure></p>
<p>这里为了文章排版美观，有删减部分支付宝公钥内容</p>
<p>无论那种方式，强烈建议在填入时，去掉：</p>
<blockquote>
<p>—–BEGIN PUBLIC KEY—–<br>以及  —–END PUBLIC KEY—– 只保留中间部分的内容。</p>
</blockquote>
<p><strong><code>rsa_private_key</code></strong> 商户私钥的设置，按照<a href="(https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.XduKK8&amp;treeId=291&amp;articleId=106103&amp;docType=1">上面发的教程</a>)进行操作，然后把获取到的值，复制出来。跟支付宝公钥一样，也可以单独放在一个文件里，然后引用他的路径，或者直接将它的值，设置在这个字段上。</p>
<p>请记得只保留密钥内容部分。</p>
<p>这里请一定分清楚 <strong>私钥，是商户自己生成的</strong>。  <strong>公钥，是支付宝开发平台看到的</strong></p>
<p><strong><code>limit_pay</code></strong> 在让用户使用支付宝支付过程中，可能想禁止用户使用某些渠道，比如：不准使用 信用卡支付  不准使用 花呗支付。都可以在这里进行配置。详细的可取值，请看图片</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-limit-pay.jpeg?imageView2/2/w/600" alt="image"></p>
<p><a href="https://doc.open.alipay.com/doc2/detail.htm?treeId=203&amp;articleId=105463&amp;docType=1#qdsm" target="_blank" rel="external">官方链接</a></p>
<p><strong><code>notify_url</code></strong> 异步通知。当支付宝支付成功后，你想要在服务端收到支付宝支付成功的通知，就必须设置该选项。应该是：http/https 开头的url。</p>
<p>这里强烈建议以支付宝服务器的通知为依据来判断是否支付成功。关于异步通知的处理，在后面的文章将有专题讲解。</p>
<p><strong><code>return_url</code></strong>  当前主要是即时到账、手机网站支付两个接口会用到，在支付成功后，跳转到哪一个链接。也必须是以 HTTP/HTTPS 开头的url。可以理解为同步通知，但请不要以它的结果为准。为了安全还是应该以异步为准。</p>
<p><strong><code>return_raw</code></strong>  之前的版本都没有该参数，是3.0新加入的，它的主要目的是让调用者控制自己拿到什么样的数据。如果设置为true。SDK 则只会向支付宝发出请求，收到数据后进行验签，通过后，会以数组的形式将所有支付宝返回的数据返回给客户端。</p>
<p>如果设置为false ，则会抛弃支付宝的某些字段。并且会对某些字段名称进行重新映射，这种方式带来的好处是，可用确保支付宝、微信返回的数据是基本一致的，但是可能导致调用者损失部分信息。这里大家根据实际情况进行衡量。</p>
<p>至此，支付宝的配置全部讲解完毕。  去看看如何完成<a href="https://helei112g.github.io/2017/03/11/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5%E6%95%99%E7%A8%8B/">即时到账</a>吧</p>
<p>如果你有不清楚的或者愿意交流的地方，请联系我：</p>
<p><strong>邮箱</strong>：dayugog@gmail.com</p>
<p>如果你觉得这个项目有帮助到你，请打赏我，让我有动力持续下去<a href="#">左边微信，右边支付宝</a>：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-wx-pay.jpg?imageView2/2/w/500" alt="image"></p>
<p><strong>ps：</strong> 一般性的问题请大家可以先查资料，如果实在无法解决找我吧（不免费服务）。</p>
<p>我的个人公众号(技术、创业主题)，希望在这里遇见你：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/mp-qr.jpg" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP中浮点数位数截取性能大比拼]]></title>
      <url>https://helei112g.github.io/2017/02/16/PHP%E4%B8%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BD%8D%E6%95%B0%E6%88%AA%E5%8F%96%E6%80%A7%E8%83%BD%E5%A4%A7%E6%AF%94%E6%8B%BC/</url>
      <content type="html"><![CDATA[<p>本文没什么好说的，点进来看吧… …<br><a id="more"></a></p>
<p>最近工作中，在处理电商用户下单模块的时候，之前遗留系统保留的是三位小数。这里带来了一个问题：<br>如果用户的订单价格是：6.666元，那么在向支付宝或者微信发起支付时，第三方只会保留两位数，也就是用户实际付款：6.66元。</p>
<p>那么问题来了，支付成功第三方回调系统接口，在接口中的逻辑需要比对支付的金额，会发现 6.666≠6.66，然后后面的逻辑无法运行，处理失败。</p>
<p>这里引申出来的一个问题是：我们对浮点数位数保留时，该使用何种方式？</p>
<p>php中提供了很多种处理浮点数位数的方式。</p>
<ul>
<li>number_format — 以千位分隔符方式格式化一个数字</li>
<li>round — 对浮点数进行四舍五入 (通过传入第三个参数，可以控制舍、入的方式)</li>
<li>sprintf — Return a formatted string</li>
<li>bcadd — 2个任意精度数字的加法计算</li>
</ul>
<p>还有一种方式就是字符串截取，比如以前三位小数，现在只要两位，就把最后一位截去。</p>
<p>但是，这种方式千万别用，非常无耻，万一某个数据查询出来是：9999元，你把最后一位搞掉变成：999元，自己赔公司损失吧。</p>
<p>说完处理的方式，不得不提一下性能问题。这里由于 <code>round</code> 函数如果数字后面全是0的话。不能正确处理小数位数，这里就先不提.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$data = array_fill(0, 1, range(1, 100000, 1.1))[0];</span><br><span class="line"></span><br><span class="line">$start = microtime(true);</span><br><span class="line">foreach ($data as $num) &#123;</span><br><span class="line">    number_format(10000, 2, &apos;.&apos;, &apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">$end = microtime(true);</span><br><span class="line">$need = $end - $start;</span><br><span class="line">print(&quot;number_format time: &#123;$need&#125;&quot; . PHP_EOL);</span><br><span class="line"></span><br><span class="line">$start = microtime(true);</span><br><span class="line">foreach ($data as $num) &#123;</span><br><span class="line">    bcadd($num, 0, 2);</span><br><span class="line">&#125;</span><br><span class="line">$end = microtime(true);</span><br><span class="line">$need = $end - $start;</span><br><span class="line">print(&quot;bcadd time: &#123;$need&#125;&quot; . PHP_EOL);</span><br><span class="line"></span><br><span class="line">$start = microtime(true);</span><br><span class="line">foreach ($data as $num) &#123;</span><br><span class="line">    sprintf(&apos;.2%f&apos;, $num);</span><br><span class="line">&#125;</span><br><span class="line">$end = microtime(true);</span><br><span class="line">$need = $end - $start;</span><br><span class="line">print(&quot;sprintf time: &#123;$need&#125;&quot; . PHP_EOL);</span><br></pre></td></tr></table></figure>
<p>上面的代码运行，会得到以下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number_format time: 0.086385011672974</span><br><span class="line">bcadd time: 0.098035097122192</span><br><span class="line">sprintf time: 0.069508075714111</span><br></pre></td></tr></table></figure></p>
<p>所以通过对比，推荐使用 <code>sprintf</code> 来处理浮点数位数的问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swoole入门指南：PHP7安装Swoole详细教程（一）]]></title>
      <url>https://helei112g.github.io/2017/02/08/Swoole%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9APHP7%E5%AE%89%E8%A3%85Swoole%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>本教程一步步深入swoole，通过demo讲解它的学习与使用方法。<br><a id="more"></a></p>
<p>好久未更新了，不是懒呃，是太忙啦！终于偷得浮生几日闲。<br>这一段时间准备为大家带来swoole的入门教程，感受一下php的nodeJs强悍之处。</p>
<p>所有的示例代码均放在了github上：<a href="https://github.com/helei112g/learn-swoole" target="_blank" rel="external">learn-swoole</a></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>这里不在使用apache做为web server。该用nginx + php-fpm，性能更强大，配置更方便。并且为了跟上php的步伐，也使用了比较新的php版本</p>
<ul>
<li>[x] centos7</li>
<li>[x] php7.0.12</li>
<li>[x] nginx/1.10.2</li>
<li>[x] php-fpm</li>
</ul>
<h1 id="下载-swoole"><a href="#下载-swoole" class="headerlink" title="下载 swoole"></a>下载 swoole</h1><p>首先下载swoole的源码包，这个操作很简单，没有太多说的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://github.com/swoole/swoole-src/archive/v2.0.6.tar.gz</span><br><span class="line"></span><br><span class="line">解压: tar -zxvf v2.0.6.tar.gz</span><br><span class="line"></span><br><span class="line">cd swoole-src-2.0.6/</span><br></pre></td></tr></table></figure></p>
<h1 id="编译-amp-安装"><a href="#编译-amp-安装" class="headerlink" title="编译&amp;安装"></a>编译&amp;安装</h1><p>使用phpize来生成php编译配置</p>
<p><em>./configure</em> 来做编译配置检测</p>
<p>make进行编译，make install进行安装</p>
<p>命令执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 swoole-src-2.0.6]# phpize</span><br><span class="line">[root@php7 swoole-src-2.0.6]# ./configure</span><br><span class="line">[root@php7 swoole-src-2.0.6]# make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>make install后，如果正确，会出现以下内容<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 swoole-src-2.0.6]# make install</span><br><span class="line">Installing shared extensions:     /usr/lib64/php/modules/</span><br></pre></td></tr></table></figure></p>
<p>这表示，在 <code>/usr/lib64/php/modules/</code> 目录中，成功生成了 <code>swoole.so</code> 文件</p>
<h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>要能够使用该模块，还需要在 <code>php.ini</code> 文件中添加该模块。</p>
<p>这里需要注意，php7的模块配置文件均单独分开了。<br>在 <code>php.ini</code> 中可找到如下内容</p>
<blockquote>
<p>;;;;<br>; Note: packaged extension modules are now loaded via the .ini files<br>; found in the directory /etc/php.d; these are loaded by default.<br>;;;;</p>
</blockquote>
<p>因此，如果你的php安装时，如果未特殊设置，可以在<code>/etc/php.d</code> 目录中，找到添加模块的配置文件。</p>
<p>进入到  <em>cd /etc/php.d</em> 目录，完成相关的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 swoole-src-2.0.6]# vim swoole.ini</span><br><span class="line"></span><br><span class="line">; Enable swoole extension module</span><br><span class="line">extension=swoole.so</span><br></pre></td></tr></table></figure>
<h1 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h1><p>新增php模块后，需要重新启动服务，才会生效，如果有时候restart后依然无效，请先关闭，再重新启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 swoole-src-2.0.6]# systemctl restart nginx</span><br><span class="line">[root@php7 swoole-src-2.0.6]# systemctl restart php-fpm</span><br></pre></td></tr></table></figure>
<p>通过php -m或phpinfo()来查看是否成功加载了swoole</p>
<p><img src="https://helei112g.github.io/images/swoole-phpinfo.png" alt="image"></p>
<h1 id="swoole-代码的自动提示"><a href="#swoole-代码的自动提示" class="headerlink" title="swoole 代码的自动提示"></a>swoole 代码的自动提示</h1><p>安装好扩展后，就是使用的问题。由于没有代码的提示，有时候很不方便，github上有人已经提供了swoole代码提示的 ide-helper 。具体设置办法如下：</p>
<p>这里以： phpStorme 为例，download 代码到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:eaglewu/swoole-ide-helper.git ide-helper</span><br></pre></td></tr></table></figure></p>
<p>按照图片内容设置<br><img src="https://helei112g.github.io/images/swoole-setting.png" alt="image"></p>
<p>经过以上步骤，可以在 phpStorme 中使用swoole了。并且提供代码提示。</p>
<h1 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h1><p>所有的测试代码均放在 <a href="https://github.com/helei112g/learn-swoole" target="_blank" rel="external">这里</a></p>
<p>请将该代码 <code>clone</code> 到本地，方便观察效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:helei112g/learn-swoole.git</span><br></pre></td></tr></table></figure></p>
<p>本节所提供的代码实例 <a href="https://github.com/helei112g/learn-swoole/blob/master/demo1-serv.php" target="_blank" rel="external">demo1-serv</a></p>
<p>进入到测试代码目录，</p>
<p>然后在服务端使用 <code>telnet</code> 进行测试</p>
<hr>
<ul>
<li>首先，运行服务端的监听程序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php demo1-serv.php</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>执行这个命令后，服务器会显示： </p>
<blockquote>
<p><code>Client: Connect.</code> </p>
</blockquote>
<ul>
<li>另外开一个终端，使用 <code>telnet</code> 连接当前服务端监听的端口，并且输入一些文字，观察终端的变化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 ~]# telnet 127.0.0.1 9999</span><br><span class="line">Hi!</span><br><span class="line">Server: Hi!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里只是进行简单的模拟回复。客户端发什么，服务器就回应什么消息。<br>退出telnet，观察服务器会显示什么<br>直接关闭窗口，或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 ~]# Ctrl+]</span><br><span class="line">[root@php7 ~]# telnet&gt; quit</span><br></pre></td></tr></table></figure>
<p>此时，会在服务侧看到：</p>
<blockquote>
<p>Client: Close.</p>
</blockquote>
<p>PS：如果测试环境没有安装 <code>telnet</code> ，请自行google安装。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列五：Vagrant使用中遇到的坑]]></title>
      <url>https://helei112g.github.io/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E4%BA%94%EF%BC%9AVagrant%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>这篇文章是在windows上使用了vagrant半年后，突然切换到mac上来，遇到了各种坑，今天补了这篇文章。希望对你有帮助。</p>
<a id="more"></a>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>之前写了一系列的vagrant使用教程，当时写这个教程的时候实在windows的环境下。最近再mac上使用，遇到了一些麻烦。</p>
<p><a href="http://blog.csdn.net/hel12he/article/details/51069269" target="_blank" rel="external">原文章路径</a></p>
<p>今天最想说的一个问题就是权限的问题。</p>
<p>在windows中由于没有文件权限的概念，所有当我们共享目录后，共享目录默认就是777权限。<br>但是当我使用mac时，共享后的目录权限以及用户组都不正确了。无法正常使用。这样导致的一个直接问题就是：</p>
<blockquote>
<p>项目a运行在虚拟机中，需要向runtime目录写入日志或者临时文件之类的，总之就是需要读写权限。</p>
</blockquote>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>当时我直接ssh上vagrang后，给予777权限，无法写入，然后又在主机给予777权限，可以写入一个文件，但是下个文件又拿到权限写入。</p>
<p>后来由各种google与百度，看到说使用nfs的方式可以解决这个问题，但是各方给出的解决方案都很成旧，有的方法使用后甚至虚拟机都无法启动了。</p>
<p>没办法，老老实实上官网看nfs相关的配置吧。老实说官方给的文档真的是有点太简单抽象了，只能结合之前的一些东西结合起来使用。最终终于找到办法，这里将相关的配置贴出来，供大家参考。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">config.vm.define :php7 <span class="keyword">do</span> |p7|</span><br><span class="line">  p7.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> |v|</span><br><span class="line">        v.customize [<span class="string">"modifyvm"</span>, :id, <span class="string">"--name"</span>, <span class="string">"php6"</span>, <span class="string">"--memory"</span>, <span class="string">"512"</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 域名解析慢</span></span><br><span class="line">        v.customize [<span class="string">"modifyvm"</span>, :id, <span class="string">"--natdnshostresolver1"</span>, <span class="string">"on"</span>]</span><br><span class="line">        v.customize [<span class="string">"modifyvm"</span>, :id, <span class="string">"--natdnsproxy1"</span>, <span class="string">"on"</span>]</span><br><span class="line">  end</span><br><span class="line">  p7.vm.box = <span class="string">"CentOs7"</span></span><br><span class="line">  p7.vm.hostname = <span class="string">"php7"</span></span><br><span class="line">  p7.vm.network :private_network, ip: <span class="string">"192.168.33.10"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ssh 奇怪：第一次启动虚拟机无法获取ip</span></span><br><span class="line">  p7.ssh.username = <span class="string">"root"</span></span><br><span class="line">  p7.ssh.password = <span class="string">"vagrant"</span></span><br><span class="line">  p7.ssh.host = <span class="string">"192.168.33.11"</span></span><br><span class="line">  p7.ssh.port = <span class="number">22</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">## nfs文件权限问题  启动了好几次才正常，不知道原因</span></span><br><span class="line">  p7.vm.synced_folder <span class="string">"./www"</span>, <span class="string">"/data/wwwroot"</span>, type: <span class="string">"nfs"</span>, :nfs =&gt; &#123;</span><br><span class="line">    :linux_nfs_options =&gt; [<span class="string">"not_root_squash"</span>],</span><br><span class="line">    :map_uid =&gt; <span class="number">0</span>,</span><br><span class="line">    :map_gid =&gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这个配置是在一个 <code>Vagrantfile</code> 中配置多台机器的配置文档。其中遇到的一些奇怪问题，注释中都标明了。</p>
<ul>
<li>配置的ip地址，首次使用 <code>vagrant up php7</code> 后，无效，需要重新启动，虚拟机才能拿到这个ip。至今不懂为什么，麻烦知道的告诉我一下啊！</li>
<li>nfs配置信息全面解决了权限问题。你需要给出什么权限直接在 vagrang 虚拟机中进行设置。但是在挂载目录时，有时候配置的新机器会莫名其妙重新启动好几次才可以。我启动了三次。</li>
<li><p>另一个坑是，新机器安装后，需要配置dns解析。否则有的资源是无法下载的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/resolv.conf</span><br><span class="line"></span><br><span class="line">## 增加以下内容</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于配置了启动时使用 <code>root</code> 帐号，需要每次在mac上启动的时候输入机器密码，很麻烦，官方指导配置 <code>/etc/sudoers</code> 如下内容</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cmnd_Alias VAGRANT_EXPORTS_ADD = /usr/bin/tee -a /etc/exports</span><br><span class="line">Cmnd_Alias VAGRANT_NFSD = /sbin/nfsd restart</span><br><span class="line">Cmnd_Alias VAGRANT_EXPORTS_REMOVE = /usr/bin/sed -E -e /*/ d -ibak /etc/exports</span><br><span class="line">%admin ALL=(root) NOPASSWD: VAGRANT_EXPORTS_ADD, VAGRANT_NFSD, VAGRANT_EXPORTS_REMOVE</span><br></pre></td></tr></table></figure>
<p><em>该配置仅针对mac</em></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这类问题还是蛮常见，对于使用很久的用户，轻松解决了，但是对于大多数使用vagrant的新手，这个问题很头痛，可能直接导致放弃使用vagrant吧。为了不让你放弃，我必须写出来帮助大家渡过这道坑。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列四：Vagrant搭建redis与redis的监控程序redis-stat]]></title>
      <url>https://helei112g.github.io/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E5%9B%9B%EF%BC%9AVagrant%E6%90%AD%E5%BB%BAredis%E4%B8%8Eredis%E7%9A%84%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8Fredis-stat/</url>
      <content type="html"><![CDATA[<p>redis经常会被用到<br><a id="more"></a></p>
<p><strong>重要提示，从3.2版本后，redis需要设置密码才能够被外部网络访问。</strong><br>所以如果你发现可以链接上redis，但是无法写入或者读取那么请检查是否使用了密码方式。</p>
<h1 id="redis的安装"><a href="#redis的安装" class="headerlink" title="redis的安装"></a>redis的安装</h1><p>哎，写到这儿，说一句，诅咒联通这网络，联通网络一上，打开vpn，照样不能访问外网，联baidu都一卡一卡的。</p>
<p>redis就不用yum来进行安装了。直接从官方下载来安装吧。(老实说，我也不知道yum里边有没有redis的最新版)</p>
<h2 id="下载redis"><a href="#下载redis" class="headerlink" title="下载redis"></a>下载redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c http://download.redis.io/releases/redis-3.0.7.tar.gz</span><br></pre></td></tr></table></figure>
<p>当然你也可以到<a href="http://redis.io/download" target="_blank" rel="external">redis官网</a> 下载最新的版本。当然个人建议，开发中还是使用稳定版本吧！<br><img src="http://img.blog.csdn.net/20160412233549976" alt="这里写图片描述"></p>
<h2 id="解压redis"><a href="#解压redis" class="headerlink" title="解压redis"></a>解压redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf redis-3.0.7.tar.gz</span><br></pre></td></tr></table></figure>
<p>这个命令什么意思，我就不多说了，如果不清楚的同学，建议平时还是多积累点linux的命令知识额。加薪升职的利器额。<br><img src="http://img.blog.csdn.net/20160412233743743" alt="这里写图片描述"></p>
<h2 id="编译安装redis"><a href="#编译安装redis" class="headerlink" title="编译安装redis"></a>编译安装redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd redis-3.0.7</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>进入到解压后的目录，然后执行编译，然后安装。</p>
<p><img src="http://img.blog.csdn.net/20160412233953683" alt="这里写图片描述"></p>
<p>OK，至此，我们的redis安装还没有完额，其实好玩儿的才刚刚开始呢。</p>
<h2 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h2><p>创建redis 配置文件夹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$　mkdir /etc/redis</span><br></pre></td></tr></table></figure></p>
<p>在/var/lib/redis 下创建有效的保存数据的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$　mkdir -p /var/lib/redis/6379</span><br></pre></td></tr></table></figure></p>
<p>redis.conf 是 redis 的配置文件，然而你会看到我们会把这个文件的名字改为 6379.conf ，而这个数字就是 redis 监听的网络端口。如果你想要运行超过一个的 redis 实例，推荐用这样的名字。</p>
<p>复制示例的 redis.conf 到 /etc/redis/6379.conf。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure></p>
<p>修改的内容如下：</p>
<blockquote>
<p>设置 daemonize 为 no，systemd 需要它运行在前台，否则 redis 会突然挂掉。<br>daemonize yes</p>
<p>设置 pidfile 为 /var/run/redis_6379.pid。<br>pidfile /var/run/redis_6379.pid</p>
<p>如果不准备用默认端口，可以修改。<br>port 6379</p>
<p>设置日志级别。<br>loglevel debug</p>
<p>修改日志文件路径。<br>logfile /var/log/redis_6379.log</p>
<p>设置目录为 /var/lib/redis/6379<br>dir /var/lib/redis/6379</p>
</blockquote>
<p>redis配置文件，各项的详解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line">######################### 通用 #########################</span><br><span class="line"></span><br><span class="line"># 启动后台进程</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># 后台进程的pid文件存储位置</span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"></span><br><span class="line"># 默认监听端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 在高并发的环境中，为避免慢客户端的连接问题，需要设置一个高速后台日志</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"># 只接受以下绑定的IP请求</span><br><span class="line"># Examples:</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 设置unix监听，默认为空</span><br><span class="line"># unixsocket /tmp/redis.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line">#客户端空闲多长时间，关闭链接，0表示不关闭</span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"># TCP keepalive.</span><br><span class="line"># 如果是非零值，当失去链接时，会使用SO_KEEPALIVE发送TCP ACKs 到客户端。</span><br><span class="line"># 这个参数有两个作用:</span><br><span class="line"># 1.检测断点。</span><br><span class="line"># 2.从网络中间设备来看，就是保持链接</span><br><span class="line"># 在Linux上，设定的时间就是发送ACKs的周期。</span><br><span class="line"># 注意：达到双倍的设定时间才会关闭链接。在其他内核上，周期依赖于内核设置。</span><br><span class="line"># 一个比较合理的值为60s</span><br><span class="line">tcp-keepalive 0</span><br><span class="line"></span><br><span class="line"># 指定日志级别，以下记录信息依次递减</span><br><span class="line"># debug用于开发/测试</span><br><span class="line"># verbose没debug那么详细</span><br><span class="line"># notice适用于生产线</span><br><span class="line"># warning只记录非常重要的信息</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">#日志文件名称，如果为stdout则输出到标准输出端，如果是以后台进程运行则不产生日志</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 要想启用系统日志记录器，设置一下选项为yes</span><br><span class="line"># syslog-enabled no</span><br><span class="line"></span><br><span class="line"># 指明syslog身份</span><br><span class="line"># syslog-ident redis</span><br><span class="line"></span><br><span class="line"># 指明syslog设备。必须是一个用户或者是local0 ~ local7之一</span><br><span class="line"># syslog-facility local0</span><br><span class="line"></span><br><span class="line">#设置数据库数目，第一个数据库编号为：0</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line">######################### 快照 #########################</span><br><span class="line"></span><br><span class="line"># 在什么条件下保存数据库到磁盘，条件可以有很多个，满足任何一个条件都会进行快照存储</span><br><span class="line"># 在900秒之内有一次key的变化</span><br><span class="line">save 900 1</span><br><span class="line"># 在300秒之内，有10个key的变化</span><br><span class="line">save 300 10</span><br><span class="line"># 在60秒之内有10000个key变化</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 当持久化失败的时候，是否继续提供服务</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 当写入磁盘时，是否使用LZF算法压缩数据，默认为yes</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 是否添加CRC64校验到每个文件末尾--花费时间保证安全</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># 磁盘上数据库的保存名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># Redis工作目录，以上数据库保存文件和AOF日志都会写入此目录</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line">######################### 主从同步 #########################</span><br><span class="line"></span><br><span class="line"># 主从复制，当本机是slave时配置</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"># 当主机需要密码验证时候配置</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line"># 当slave和master丢失链接，或正处于同步过程中。是否响应客户端请求</span><br><span class="line"># 设置为yes表示响应</span><br><span class="line"># 设置为no，直接返回&quot;SYNC with master in progress&quot;（正在和主服务器同步中）</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># 设置slave是否为只读。</span><br><span class="line"># 注意：即使slave设置为只读，也不能令其暴露在不受信任的网络环境中</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"># 无硬盘复制功能</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># 等待多个slave一起来请求之间的间隔时间</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"># 设置slave给master发送ping的时间间隔</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"></span><br><span class="line"># 设置数据传输I/O，主机数据、ping响应超时时间，默认60s</span><br><span class="line"># 这个时间一定要比repl-ping-slave-period大，否则会不断检测到超时</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line"># 是否在SYNC后slave socket上禁用TCP_NODELAY？</span><br><span class="line"># 如果你设置为yes，Redis会使用少量TCP报文和少量带宽发送数据给slave。</span><br><span class="line"># 但是这样会在slave端出现延迟。如果使用Linux内核的默认设置，大概40毫秒。</span><br><span class="line"># 如果你设置为no，那么在slave端研究就会减少但是同步带宽要增加。</span><br><span class="line"># 默认我们是为低延迟优化的。</span><br><span class="line"># 但是如果流量特别大或者主从服务器相距比较远，设置为yes比较合理。</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"># 设置复制的后台日志大小。</span><br><span class="line"># 复制的后台日志越大， slave 断开连接及后来可能执行部分复制花的时间就越长。</span><br><span class="line"># 后台日志在至少有一个 slave 连接时，仅仅分配一次。</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line"># 在 master 不再连接 slave 后，后台日志将被释放。下面的配置定义从最后一个 slave 断开连接后需要释放的时间（秒）。</span><br><span class="line"># 0 意味着从不释放后台日志</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"># 设置slave优先级，默认为100</span><br><span class="line"># 当主服务器不能正确工作的时候，数字低的首先被提升为主服务器，但是0是禁用选择</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"># 如果少于 N 个 slave 连接，且延迟时间 &lt;=M 秒，则 master 可配置停止接受写操作。</span><br><span class="line"># 例如需要至少 3 个 slave 连接，且延迟 &lt;=10 秒的配置：</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line"># 设置 0 为禁用</span><br><span class="line"># 默认 min-slaves-to-write 为 0 （禁用）， min-slaves-max-lag 为 10</span><br><span class="line"></span><br><span class="line">######################### 安全 #########################</span><br><span class="line"></span><br><span class="line"># 设置客户端连接密码，因为Redis响应速度可以达到每秒100w次，所以密码要特别复杂</span><br><span class="line"># requirepass 1413</span><br><span class="line"></span><br><span class="line"># 命令重新命名，或者禁用。</span><br><span class="line"># 重命名命令为空字符串可以禁用一些危险命令比如：FLUSHALL删除所有数据</span><br><span class="line"># 需要注意的是，写入AOF文件或传送给slave的命令别名也许会引起一些问题</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 设置客户端连接密码，因为Redis响应速度可以达到每秒100w次，所以密码要特别复杂</span><br><span class="line">requirepass 1413</span><br><span class="line"></span><br><span class="line"># 命令重新命名，或者禁用。</span><br><span class="line"># 重命名命令为空字符串可以禁用一些危险命令比如：FLUSHALL删除所有数据</span><br><span class="line"># 需要注意的是，写入AOF文件或传送给slave的命令别名也许会引起一些问题</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line"></span><br><span class="line">######################### 限制 #########################</span><br><span class="line"></span><br><span class="line"># 设置最多链接客户端数量，默认为10000。</span><br><span class="line"># 实际可以接受的请求数目为设置值减去32，这32是Redis为内部文件描述符保留的</span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line"># 设置最多链接客户端数量，默认为10000。</span><br><span class="line"># 实际可以接受的请求数目为设置值减去32，这32是Redis为内部文件描述符保留的</span><br><span class="line"># maxclients 10000</span><br><span class="line"># 设置最大使用内存数量，在把Redis当作LRU缓存时特别有用。</span><br><span class="line"># 设置的值要比系统能使用的值要小</span><br><span class="line"># 因为当启用删除算法时，slave输出缓存也要占用内存</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line">#达到最大内存限制时，使用何种删除算法</span><br><span class="line"># volatile-lru  使用LRU算法移除带有过期标致的key</span><br><span class="line"># allkeys-lru -&gt; 使用LRU算法移除任何key</span><br><span class="line"># volatile-random -&gt; 随机移除一个带有过期标致的key</span><br><span class="line"># allkeys-random -&gt;  随机移除一个key</span><br><span class="line"># volatile-ttl -&gt; 移除最近要过期的key</span><br><span class="line"># noeviction -&gt; 不删除key，当有写请求时，返回错误</span><br><span class="line">#默认设置为volatile-lru</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line"># LRU和最小TTL算法没有精确的实现</span><br><span class="line"># 为了节省内存只在一个样本范围内选择一个最近最少使用的key，可以设置这个样本大小</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br><span class="line">######################### AO模式 #########################</span><br><span class="line"></span><br><span class="line"># AOF和RDB持久化可以同时启用</span><br><span class="line"># Redis启动时候会读取AOF文件，AOF文件有更好的持久化保证</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># AOF的保存名称，默认为appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 设置何时写入追加日志，又三种模式</span><br><span class="line"># no：表示由操作系统决定何时写入。性能最好，但可靠性最低</span><br><span class="line"># everysec：表示每秒执行一次写入。折中方案，推荐</span><br><span class="line"># always：表示每次都写入磁盘。性能最差，比上面的安全一些</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># 当AOF同步策略设定为alway或everysec</span><br><span class="line"># 当后台存储进程（后台存储或者AOF日志后台写入）会产生很多磁盘开销</span><br><span class="line"># 某些Linux配置会使Redis因为fsync()调用产生阻塞很久</span><br><span class="line"># 现在还没有修复补丁，甚至使用不同线程进行fsync都会阻塞我们的同步write(2)调用。</span><br><span class="line"># 为了缓解这个问题，使用以下选项在一个BGSAVE或BGREWRITEAOF运行的时候</span><br><span class="line"># 可以阻止fsync()在主程序中被调用，</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># AOF自动重写（合并命令，减少日志大小）</span><br><span class="line"># 当AOF日志大小增加到一个特定比率，Redis调用BGREWRITEAOF自动重写日志文件</span><br><span class="line"># 原理：Redis 会记录上次重写后AOF文件的文件大小。</span><br><span class="line"># 如果刚启动，则记录启动时AOF大小</span><br><span class="line"># 这个基本大小会用来和当前大小比较。如果当前大小比特定比率大，就会触发重写。</span><br><span class="line"># 你也需要指定一个AOF需要被重写的最小值，这样会避免达到了比率。</span><br><span class="line"># 但是AOF文件还很小的情况下重写AOF文件。</span><br><span class="line"># 设置为0禁用自动重写</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">#redis在启动时可以加载被截断的AOF文件，而不需要先执行 redis-check-aof 工具</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line">######################### LUA脚本 #########################</span><br><span class="line"></span><br><span class="line"># Lua脚本的最大执行时间，单位毫秒</span><br><span class="line"># 超时后会报错，并且计入日志</span><br><span class="line"># 当一个脚本运行时间超过了最大执行时间</span><br><span class="line"># 只有SCRIPT KILL和 SHUTDOWN NOSAVE两个命令可以使用。</span><br><span class="line"># SCRIPT KILL用于停止没有调用写命令的脚本。</span><br><span class="line"># SHUTDOWN NOSAVE是唯一的一个，在脚本的写命令正在执行</span><br><span class="line"># 用户又不想等待脚本的正常结束的情况下，关闭服务器的方法。</span><br><span class="line"># 以下选项设置为0或负数就会取消脚本执行时间限制</span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line">####################### redis集群  ########################</span><br><span class="line"></span><br><span class="line"># 是否启用集群</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># 集群配置文件</span><br><span class="line"># 集群配置变更后会自动写入改文件</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"># 节点互连超时的阀值 </span><br><span class="line"># 节点超时时间，超过该时间无法连接主要Master节点后，会停止接受查询服务 </span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"># 控制从节点FailOver相关的设置,设为0，从节点会一直尝试启动FailOver.</span><br><span class="line"># 设为正数，失联大于一定时间（factor*节点TimeOut），不再进行FailOver</span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line"># 最小从节点连接数</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line"># 默认为Yes,丢失一定比例Key后（可能Node无法连接或者挂掉），集群停止接受写操作</span><br><span class="line"># 设置为No，集群丢失Key的情况下仍提供查询服务</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line">######################### 慢查询 #########################</span><br><span class="line"></span><br><span class="line"># Redis慢查询日志记录超过设定时间的查询，且只记录执行命令的时间</span><br><span class="line"># 不记录I/O操作，比如：和客户端交互，发送回复等。</span><br><span class="line"># 时间单位为微妙，1000000微妙 = 1 秒</span><br><span class="line"># 设置为负数会禁用慢查询日志，设置为0会记录所有查询命令</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"># 日志长度没有限制，但是会消耗内存。超过日志长度后，最旧的记录会被移除</span><br><span class="line"># 使用SLOWLOG RESET命令可以回收内存</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line">######################### 延迟监测 #########################</span><br><span class="line"></span><br><span class="line"># 系统只记录超过设定值的操作，单位是毫秒，0表示禁用该功能  </span><br><span class="line"># 可以通过命令“CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;” 直接设置而不需要重启redis  </span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line">######################### 事件通知 #########################</span><br><span class="line">#  当事件发生时， Redis 可以通知 Pub/Sub 客户端。</span><br><span class="line">#  可以在下表中选择 Redis 要通知的事件类型。事件类型由单个字符来标识：</span><br><span class="line"># K     Keyspace 事件，以 _keyspace@&lt;db&gt;_ 的前缀方式发布</span><br><span class="line"># E     Keyevent 事件，以 _keysevent@&lt;db&gt;_ 的前缀方式发布</span><br><span class="line"># g     通用事件（不指定类型），像 DEL, EXPIRE, RENAME, …</span><br><span class="line"># $     String 命令</span><br><span class="line"># s     Set 命令</span><br><span class="line"># h     Hash 命令</span><br><span class="line"># z     有序集合命令</span><br><span class="line"># x     过期事件（每次 key 过期时生成）</span><br><span class="line"># e     清除事件（当 key 在内存被清除时生成）</span><br><span class="line"># A     g$lshzxe 的别称，因此 ”AKE” 意味着所有的事件</span><br><span class="line"># notify-keyspace-events 带一个由 0 到多个字符组成的字符串参数。空字符串意思是通知被禁用。</span><br><span class="line">#  例子：启用 list 和通用事件：</span><br><span class="line"># notify-keyspace-events Elg</span><br><span class="line">#  默认所用的通知被禁用，因为用户通常不需要改特性，并且该特性会有性能损耗。</span><br><span class="line">#  注意如果你不指定至少 K 或 E 之一，不会发送任何事件。</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">#notify-keyspace-events AKE</span><br><span class="line"></span><br><span class="line">######################### 高级设置 #########################</span><br><span class="line"></span><br><span class="line"># 当有少量条目的时候，哈希使用高效内存数据结构。最大的条目也不能超过设定的阈值。# “少量”定义如下：</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># 和哈希编码一样，少量列表也以特殊方式编码节省内存。“少量”设定如下：</span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># 集合只在以下情况下使用特殊编码来节省内存</span><br><span class="line"># --&gt;集合全部由64位带符号10进制整数构成的字符串组成</span><br><span class="line"># 下面的选项设置这个特殊集合的大小。</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"># 当有序集合的长度和元素设定为以下数字时，又特殊编码节省内存</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># HyperLogLog 稀疏表示字节限制</span><br><span class="line"># 这个限制包含了16个字节的头部，当一个HyperLogLog使用sparse representation</span><br><span class="line"># 超过了这个显示，它就会转换到dense representation上</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line"># 哈希刷新使用每100个CPU毫秒中的1毫秒来帮助刷新主哈希表（顶级键值映射表）。</span><br><span class="line">#  Redis哈希表使用延迟刷新机制，越多操作，越多刷新。</span><br><span class="line"># 如果服务器空闲，刷新操作就不会进行，更多内存会被哈希表占用</span><br><span class="line"># 默认每秒进行10次主字典刷新，释放内存。</span><br><span class="line"># 如果你有硬性延迟需求，偶尔2毫秒的延迟无法忍受的话。设置为no</span><br><span class="line"># 否则设置为yes</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"># 客户端输出缓存限制强迫断开读取速度比较慢的客户端</span><br><span class="line"># 有三种类型的限制</span><br><span class="line"># normal -&gt; 正常</span><br><span class="line"># slave  -&gt; slave和 MONITOR</span><br><span class="line"># pubsub -&gt; 客户端至少订阅了一个频道或者模式</span><br><span class="line"># 客户端输出缓存限制语法如下（时间单位：秒）</span><br><span class="line"># client-output-buffer-limit &lt;类别&gt; &lt;强制限制&gt; &lt;软性限制&gt; &lt;软性时间&gt;</span><br><span class="line"># 达到强制限制缓存大小，立刻断开链接。</span><br><span class="line"># 达到软性限制，仍然会有软性时间大小的链接时间</span><br><span class="line"># 默认正常客户端无限制，只有请求后，异步客户端数据请求速度快于它能读取数据的速度</span><br><span class="line"># 订阅模式和主从客户端又默认限制，因为它们都接受推送。</span><br><span class="line"># 强制限制和软性限制都可以设置为0来禁用这个特性</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line"># 设置Redis后台任务执行频率，比如清除过期键任务。</span><br><span class="line"># 设置范围为1到500，默认为10.越大CPU消耗越大，延迟越小。</span><br><span class="line"># 建议不要超过100</span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line"># 当子进程重写AOF文件，以下选项开启时，AOF文件会每产生32M数据同步一次。</span><br><span class="line"># 这有助于更快写入文件到磁盘避免延迟</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure></p>
<p>##　redis开机自启动<br>复制redis的自启动脚本到init.d中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp utils/redis_init_script /etc/init.d/redis_6379</span><br></pre></td></tr></table></figure></p>
<p>这里说明一下哈，镜像还是前面用的CentOs7，所以有的命令稍微跟6不一样。建立一个redis的服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$　vim /etc/systemd/system/redis_6379.service</span><br></pre></td></tr></table></figure></p>
<p>然后输入下面的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Redis on port 6379</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/init.d/redis_6379 start</span><br><span class="line">ExecStop=/etc/init.d/redis_6379 stop</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>注意上面文件的目录，就是刚刚复制的目录，如果有多个redis，这里需要注意。</p>
<h2 id="系统参数的调整"><a href="#系统参数的调整" class="headerlink" title="系统参数的调整"></a>系统参数的调整</h2><p>为了让redis正常运行，需要对某些系统参数进行调整。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 避免数据被截断</span><br><span class="line">$　sysctl -w vm.overcommit_memory=1</span><br><span class="line"></span><br><span class="line"># 修改 backlog 连接数的最大值超过 redis.conf 中的 tcp-backlog 值，即默认值511</span><br><span class="line">$ sysctl -w net.core.somaxconn=512</span><br><span class="line"></span><br><span class="line"># 取消对透明巨页内存（transparent huge pages）的支持，因为这会造成 redis 使用过程产生延时和内存访问问题。</span><br><span class="line">$ echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure></p>
<p>然后将以上配置，写入相关文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure></p>
<p>输入内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.overcommit_memory = 1</span><br><span class="line">net.core.somaxconn=512</span><br></pre></td></tr></table></figure></p>
<p>对于透明巨页内存支持，并没有直接 sysctl 命令可以控制，所以需要将下面的命令放到 /etc/rc.local 的结尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure></p>
<p>通过以上配置，可以来启动redis服务了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start redis_6379</span><br><span class="line"># 设置为开机启动</span><br><span class="line">$ systemctl enable redis_6379</span><br><span class="line"># 通过以下命令，查看redis的状态</span><br><span class="line">$ systemctl status redis_6379</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20160413105018714" alt="这里写图片描述"></p>
<p>然后使用客户端来进行测试一下redis服务是否正常，参见截图：<br><img src="http://img.blog.csdn.net/20160413105130090" alt="这里写图片描述"></p>
<h1 id="redis的监控redis-stat的安装"><a href="#redis的监控redis-stat的安装" class="headerlink" title="redis的监控redis-stat的安装"></a>redis的监控redis-stat的安装</h1><p>由于redis-stat是使用ruby开发的，在安装前，请确保你的环境已经有了ruby的环境，如果没有，请自行google、百度安装之，我就不写了哦。<br>由于ruby默认使用的镜像在国外，剩下的不说了，大家都懂得，然后万能的淘宝镜像，切换一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/</span><br></pre></td></tr></table></figure></p>
<p>证据如下：<br><img src="http://img.blog.csdn.net/20160413105728889" alt="这里写图片描述"></p>
<p>然后开始安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install redis-stat</span><br></pre></td></tr></table></figure></p>
<p>然后，一般来说，你会发现报错啦，报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Building native extensions.  This could take a while...</span><br><span class="line">ERROR:  Error installing redis-stat:</span><br><span class="line">	ERROR: Failed to build gem native extension.</span><br><span class="line"></span><br><span class="line">    /usr/bin/ruby extconf.rb</span><br><span class="line">mkmf.rb can&apos;t find header files for ruby at /usr/share/include/ruby.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Gem files will remain installed in /usr/local/share/gems/gems/json-1.8.3 for inspection.</span><br><span class="line">Results logged to /usr/local/share/gems/gems/json-1.8.3/ext/json/ext/generator/gem_make.out</span><br></pre></td></tr></table></figure></p>
<p>哈哈，，我好机智，想到大家很多人会搜索这个错误信息，会不会因此被带到这里呢？就像试试认真写的博客，会有多少人看。<br>这个错呢，很简单，就是因为没有安装ruby-devel，所有通过yum给安装上吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install ruby-devel</span><br></pre></td></tr></table></figure></p>
<p>这个就不要截图了吧。没什么好看的。</p>
<p>安装完成后，再次执行 <code>gem install redis-stat</code><br><img src="http://img.blog.csdn.net/20160413110515627" alt="这里写图片描述"></p>
<p>然后，至此安装完成，看一看劳动成果吧。随便说一句，它对redis的效率影响，基本可以忽略不计，因此，可以放心的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-stat</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20160413110608484" alt="这里写图片描述"></p>
<p>然后，他会自带一个web的版本。大家可以通过浏览器来访问，具体方式留给大家自己去查一查，搜一搜吧。</p>
<p>单机版的redis服务安装与监控，就全部搞定。so easy！！！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列三：Vagrant搭建的php7环境]]></title>
      <url>https://helei112g.github.io/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9AVagrant%E6%90%AD%E5%BB%BA%E7%9A%84php7%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>本文实战教你如何搭建自己的开发环境。希望大家通过本文实战后，可以根据自己的情况搭建任意想要的环境。<br><a id="more"></a></p>
<p>前面已经把vagrant的基础知识已经基本过了一遍 了，相信只要按着教程来，你已经搭建好了自己的基础环境。接下来说一说如何搭建php7的开发环境。</p>
<blockquote>
<p>申明一下，这里使用的box，就是前面演示的centos7<br>地址奉上：<br><a href="https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/centos-7.0-x86_64.box" target="_blank" rel="external">https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/centos-7.0-x86_64.box</a></p>
</blockquote>
<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><p>首先需要跟新一些ngin的相关源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line"></span><br><span class="line">// 执行安装过程</span><br><span class="line">$ yum install nginx</span><br></pre></td></tr></table></figure></p>
<p>看到以下界面时，请稍等，如果需要输入的地方，请直接按 <code>y</code> 然后回车。<br><img src="http://img.blog.csdn.net/20160406225356057" alt="这里写图片描述"></p>
<h2 id="启动nginx并设置为开机启动"><a href="#启动nginx并设置为开机启动" class="headerlink" title="启动nginx并设置为开机启动"></a>启动nginx并设置为开机启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start nginx </span><br><span class="line">$ systemctl enable nginx</span><br></pre></td></tr></table></figure>
<h1 id="安装epel与remi源"><a href="#安装epel与remi源" class="headerlink" title="安装epel与remi源"></a>安装epel与remi源</h1><p>安装epel，epel是Fedora小组维护的一个软件仓库项目，为RHEL/CentOS提供他们默认不提供的软件包。安装时一定需要注意一下自己系统的版本额。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ivh http://mirrors.opencas.cn/epel/7/x86_64/e/epel-release-7-5.noarch.rpm</span><br></pre></td></tr></table></figure></p>
<p>2016-10-22日修改：</p>
<blockquote>
<p>最近发上面的源不能用了。请大家自己在这里找对应的版本<br><a href="http://dl.fedoraproject.org/pub/" target="_blank" rel="external">http://dl.fedoraproject.org/pub/</a><br>过不了墙的请用国内镜像<br><a href="http://mirrors.sohu.com/fedora-epel/7/x86_64/e/epel-release-7-8.noarch.rpm" target="_blank" rel="external">http://mirrors.sohu.com/fedora-epel/7/x86_64/e/epel-release-7-8.noarch.rpm</a></p>
</blockquote>
<p>remi源种包含最新的php相关信息，如：php7、mysql等，因此为了便捷获取php7的最新信息，也需要安装一下这个源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</span><br></pre></td></tr></table></figure></p>
<h1 id="iptables防火墙"><a href="#iptables防火墙" class="headerlink" title="iptables防火墙"></a>iptables防火墙</h1><p>因为以前经常使用iptables，对centos7自带的firewalld防火墙不熟悉，因此我就将关闭centos7自带的firewalld，启用自己熟悉的iptables吧。</p>
<p>首先，关闭自带的firewalld防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld.service </span><br><span class="line">$ systemctl disable firewalld.service #防止开机启动</span><br></pre></td></tr></table></figure></p>
<h2 id="安装iptables"><a href="#安装iptables" class="headerlink" title="安装iptables"></a>安装iptables</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install iptables-services</span><br></pre></td></tr></table></figure>
<p>安装进程如下图所示<br><img src="http://img.blog.csdn.net/20160406225557402" alt="这里写图片描述"></p>
<p>启动iptables防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start iptables.service </span><br><span class="line">systemctl enable iptables.service #开机自动启动</span><br></pre></td></tr></table></figure></p>
<h2 id="编辑防火墙配置文件"><a href="#编辑防火墙配置文件" class="headerlink" title="编辑防火墙配置文件"></a>编辑防火墙配置文件</h2><p>为了我们在自己的主机上能够顺利访问，需要开启以下端口，<br>vim /etc/sysconfig/iptables<br>编辑防火墙，设置80(nginx) 3306(mysql/mariadb) 6379(redis)端口，外网可访问<br><img src="http://img.blog.csdn.net/20160406225918341" alt="这里写图片描述"></p>
<h1 id="PHP7-0的安装"><a href="#PHP7-0的安装" class="headerlink" title="PHP7.0的安装"></a>PHP7.0的安装</h1><p>查看remi源中可安装的php信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list --enablerepo=remi --enablerepo=remi-php70 | grep php70</span><br></pre></td></tr></table></figure></p>
<p>该列表会列出所有可以安装的php模块信息，从中安装自己需要的模块，下面安装模块，是我自己的一个模块选择情况。其中有一部分是必须的，有一部分是可选的。比如php-fpm就是必须的，如果你用的是nginx的话。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install --enablerepo=remi --enablerepo=remi-php70 php php-opcache php-pecl-apcu php-devel php-mbstring php-mcrypt php-mysqlnd php-pecl-xdebug php-pdo php-pear php-fpm php-cli php-xml php-bcmath php-process php-gd php-common php-json php-imap php-pecl-redis php-pecl-memcached php-pecl-mongodb</span><br></pre></td></tr></table></figure></p>
<p>安装完成后,输入 <code>php -v</code> 可以查看当前安装的php版本信息。<br><img src="http://img.blog.csdn.net/20160406230204248" alt="这里写图片描述"></p>
<p>启动php-fpm，因为nginx需要通过它来解析php程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start php-fpm</span><br><span class="line">$ systemctl enable php-fpm #设置开机自启动</span><br></pre></td></tr></table></figure></p>
<h2 id="配置nginx可以访问php"><a href="#配置nginx可以访问php" class="headerlink" title="配置nginx可以访问php"></a>配置nginx可以访问php</h2><p>进入nginx的文件配置中心，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc/nginx/conf.d/</span><br><span class="line"># 复制默认的配置文件 </span><br><span class="line">$ cp default.conf php.conf</span><br></pre></td></tr></table></figure></p>
<p>首先先通过vim编辑default文件。将监听端口改为8080， 因为后面我们自己的php.conf会用到80端口。<br><img src="http://img.blog.csdn.net/20160406230633531" alt="这里写图片描述"></p>
<p>现在来编辑复制的php.conf文件，可以直接复制以下内容，至于配置的含义，后面再开一篇文章来单独讲解吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /vagrant/www;# 自己的项目目录，也就是php项目所在目录</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">	    # 请注意，一定要加index.php这项</span><br><span class="line">        index  index.php index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        # 注意此处变量的不同</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改完文件后，必须要重新启动nginx，才会使当前的配置生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl reload nginx</span><br></pre></td></tr></table></figure></p>
<h2 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h2><p>在/vagrant/www下新建一个文件index.php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    phpinfo();</span><br></pre></td></tr></table></figure>
<p>在浏览器中打开，访问对应的ip，可以看到输出的php信息<br><img src="http://img.blog.csdn.net/20160406233803608" alt="这里写图片描述"></p>
<p><em>注：如果在使用过程中，有新增加的php模块，需要重新启动php－fpm</em></p>
<p><code>systemctl reload php-fpm</code></p>
<h1 id="Mariadb的安装"><a href="#Mariadb的安装" class="headerlink" title="Mariadb的安装"></a>Mariadb的安装</h1><p>这里很多同学可能第一次听说mariadb，他呢是mysql的一个重要分子，或者可以理解为mysql的替代品，自从mysql被控制后，更新速度已经慢太多了。两者的用法基本没有区别，实际中有哪些坑，大家可以自己去踩一踩。哈哈，别说我不负责任。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">$ yum install mariadb-server</span><br><span class="line"># 启动服务</span><br><span class="line">$ systemctl start mariadb</span><br><span class="line"># 开机启动</span><br><span class="line">$ systemctl enable mariadb</span><br></pre></td></tr></table></figure></p>
<h2 id="MariaDB的安全配置"><a href="#MariaDB的安全配置" class="headerlink" title="MariaDB的安全配置"></a>MariaDB的安全配置</h2><p>MariaDB默认root密码为空，我们需要设置一下，执行脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mysql_secure_installation</span><br></pre></td></tr></table></figure></p>
<p>这个脚本会经过一些列的交互问答来进行MariaDB的安全设置。</p>
<p>首先提示输入当前的root密码：</p>
<blockquote>
<p>Enter current password for root (enter for none):<br>初始root密码为空，我们直接敲回车进行下一步。</p>
<p>Set root password? [Y/n]<br>设置root密码，默认选项为Yes，我们直接回车，提示输入密码，在这里设置您的MariaDB的root账户密码。</p>
<p>Remove anonymous users? [Y/n]<br>是否移除匿名用户，默认选项为Yes，建议按默认设置，回车继续。</p>
<p>Disallow root login remotely? [Y/n]<br>是否禁止root用户远程登录？如果您只在本机内访问MariaDB，建议按默认设置，回车继续。 如果您还有其他云主机需要使用root账号访问该数据库，则需要选择n。</p>
<p>Remove test database and access to it? [Y/n]<br>是否删除测试用的数据库和权限？ 建议按照默认设置，回车继续。</p>
<p>Reload privilege tables now? [Y/n]<br>是否重新加载权限表？因为我们上面更新了root的密码，这里需要重新加载，回车。</p>
</blockquote>
<p>完成后你会看到Success!的提示，MariaDB的安全设置已经完成。我们可以使用以下命令登录MariaDB：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>按提示输入root密码，就会进入MariaDB的交互界面，说明已经安装成功。<br><img src="http://img.blog.csdn.net/20160406232302024" alt="这里写图片描述"></p>
<p>最后我们将MariaDB设置为开机启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable mariadb</span><br></pre></td></tr></table></figure></p>
<h2 id="让外网可以进行链接"><a href="#让外网可以进行链接" class="headerlink" title="让外网可以进行链接"></a>让外网可以进行链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;root&apos;;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
<h1 id="安装composer"><a href="#安装composer" class="headerlink" title="安装composer"></a>安装composer</h1><p>composer的大名，我就不想介绍了，如果你是一个phper，没用过，我也就不怪你，毕竟但是他现在才刚过1.0版，但是如果听都没听过，请面壁去……</p>
<p>安装说明<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ php -r “readfile(‘https:<span class="comment">//getcomposer.org/installer‘);” &gt; composer-setup.php</span></span><br><span class="line"></span><br><span class="line">$ php composer-setup.php</span><br><span class="line"></span><br><span class="line">$ php -r “unlink(‘composer-setup.php’);”</span><br></pre></td></tr></table></figure></p>
<p>上述 3 条命令的作用依次是：</p>
<blockquote>
<ol>
<li>下载安装脚本（composer-setup.php）到当前目录。 </li>
<li>执行安装过程。 </li>
<li>删除安装脚本 – composer-setup.php 。</li>
</ol>
</blockquote>
<h2 id="全局安装composer"><a href="#全局安装composer" class="headerlink" title="全局安装composer"></a>全局安装composer</h2><p>全局安装是将 Composer 安装到系统环境变量 PATH 所包含的路径下面，然后就能够在命令行窗口中直接执行 composer 命令了。</p>
<p>Mac 或 Linux 系统：打开命令行窗口并执行如下命令将前面下载的 composer.phar 文件移动到 /usr/local/bin/ 目录下面：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv composer.phar /usr/local/bin/composer</span><br></pre></td></tr></table></figure>
<p>然后执行：<br><code>composer -v</code><br><img src="http://img.blog.csdn.net/20160406233243543" alt="这里写图片描述"><br>由于composer的包都在国外，这里设置一下composer的配置，让其每次运行时，都使用国内的包<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ composer config -g repo.packagist composer https:<span class="comment">//packagist.phpcomposer.com</span></span><br></pre></td></tr></table></figure></p>
<p>查看composer的配置文件<br>vim /root/.composer/config.json<br><img src="http://img.blog.csdn.net/20160406233556529" alt="这里写图片描述"><br>看到以上内容，表示配置成功！</p>
<hr>
<p>至此，基本的php7环境搭建已经完成了。然后呢，下一次说一说用vagrant搭建redis吧。当然我不会仅仅只说redis的搭建额。到时候看啊吧！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列二：Vagrant的配置文件vagrantfile详解]]></title>
      <url>https://helei112g.github.io/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9AVagrant%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6vagrantfile%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>通过配置文件轻松的完成一台机器的配置，使用过vm然后再来使用这个，你就会惊叹怎会如此方便。</p>
<a id="more"></a>
<p>上一篇文章完整的讲叙了如何安装一个vagrant的环境。这里主要说一说vagrant的配置文件Vagrantfile。我在尝试各种技术的时候，常常苦恼于很多时候没有教程把相关的配置信息说明完整。所以在我的博客里，我一定会完整的把这块给补上。</p>
<h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h1><p>在我们的开发目录下有一个文件Vagrantfile，里面包含有大量的配置信息，主要包括三个方面的配置，虚拟机的配置、SSH配置、Vagrant的一些基础配置。Vagrant是使用Ruby开发的，所以它的配置语法也是Ruby的，但是我们没有学过Ruby的人还是可以跟着它的注释知道怎么配置一些基本项的配置。</p>
<p><strong>box设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.box = <span class="string">"CentOs7"</span></span><br></pre></td></tr></table></figure></p>
<p>该名称是再使用 vagrant init 中后面跟的名字。</p>
<p><strong>hostname设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.hostname = <span class="string">"for_work"</span></span><br></pre></td></tr></table></figure></p>
<p>设置hostname非常重要，因为当我们有很多台虚拟服务器的时候，都是依靠hostname來做识别的。比如，我安装了php7 php56两台虚拟机，再启动时，我可以通过vagrant up php7来指定只启动哪一台。</p>
<p><strong>虚拟机网络设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network <span class="string">"private_network"</span>, ip: <span class="string">"192.168.33.10"</span></span><br><span class="line"><span class="comment">#config.vm.network "public_network"</span></span><br></pre></td></tr></table></figure></p>
<p>Vagrant有两种方式来进行网络连接，一种是host-only(主机模式)，意思是主机和虚拟机之间的网络互访，而不是虚拟机访问internet的技术，也就是只有你一個人自High，其他人访问不到你的虚拟机。另一种是Bridge(桥接模式)，该模式下的VM就像是局域网中的一台独立的主机，也就是说需要VM到你的路由器要IP，这样的话局域网里面其他机器就可以访问它了。我一般设置为host－only模式。<br>当然该模式，再指定ip的时候注意不要跟主机所在网段发生冲突。</p>
<p><strong>同步目录设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.synced_folder  <span class="string">"/Users/helei/www"</span>, <span class="string">"/vagrant"</span></span><br></pre></td></tr></table></figure></p>
<p>我们上面介绍过/vagrant目录默认就是当前的开发目录，这是在虚拟机开启的时候默认挂载同步的。我们还可以通过配置来设置额外的同步目录。</p>
<p><strong>端口转发设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network :forwarded_port, guest: <span class="number">80</span>, host: <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>上面这句配置可厉害了，这一行的意思是把对host机器上8080端口的访问请求forward到虚拟机的80端口的服务上，例如你在你的虚拟机上使用nginx跑了一个php应用，那么你在host机器上的浏览器中打开<a href="http://localhost时，Vagrant就会把这个请求转发到VM里面跑在80端口的nginx服务上，因此我们可以通过这个设置来帮助我们去设定host和VM之间，或是VM和VM之间的信息交互。" target="_blank" rel="external">http://localhost时，Vagrant就会把这个请求转发到VM里面跑在80端口的nginx服务上，因此我们可以通过这个设置来帮助我们去设定host和VM之间，或是VM和VM之间的信息交互。</a><br>个人不建议使用该方法，经常因为两台机子端口占用的问题，导致不能正常通信。还是使用上面说的两种网络方式进行设置吧。</p>
<hr>
<p>上面说的配置方式，均是单机模式，下面说说如何进行集群机器的部署与配置，这是vagrant让我正真激动与兴奋的地方。</p>
<p>看完下面，你会觉得超级简单</p>
<p>现在我们来建立多台VM跑起來，並且让他们之间能够相通信，假设一台是应用服务器、一台是redis服务器，那么这个结构在Vagrant中非常简单，其实和单台的配置差不多，你只需要通过config.vm.define来定义不同的角色就可以了，现在我们打开配置文件进行如下设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  config.vm.define :web do |web|</span><br><span class="line">    web.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line">          v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;web&quot;, &quot;--memory&quot;, &quot;512&quot;]</span><br><span class="line">    end</span><br><span class="line">    web.vm.box = &quot;CentOs7&quot;</span><br><span class="line">    web.vm.hostname = &quot;web&quot;</span><br><span class="line">    web.vm.network :private_network, ip: &quot;192.168.33.10&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  config.vm.define :redis do |redis|</span><br><span class="line">    redis.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line">          v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;redis&quot;, &quot;--memory&quot;, &quot;512&quot;]</span><br><span class="line">    end</span><br><span class="line">    redis.vm.box = &quot;CentOs7&quot;</span><br><span class="line">    redis.vm.hostname = &quot;redis&quot;</span><br><span class="line">    redis.vm.network :private_network, ip: &quot;192.168.33.11&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p>这里的的设置与设置单台机器非常的类似，如果还需要机器，只需要再配置文件中拷贝一下，然后重新加载一下这个配置文件就ok啦。是不是非常容易？后面我打算学hadoop的时候，就用这种方式来试试。<br>现在只需要重新启动一下vagrant up机器，你就会在虚拟机中看到两台虚拟机欢快的跑起来了。<br>然后这个时候，在使用vagrant ssh登录时，需要指明一下登录的是哪一台机器就ok啦。</p>
<hr>
<p>比如，我要登录到redis中去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh redis</span><br></pre></td></tr></table></figure></p>
<p>这么简单就完成登录了。登录成功后，可以使用ping命令，检查一下机器之间是否能够互相通信。</p>
<p>好吧，本地有了如此利器，你想模拟那样的服务器架构，都可以完成了，只有你的单机足够强大，你可以开20台虚拟机，请随意。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列一：Vagrant的安装与初识]]></title>
      <url>https://helei112g.github.io/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%9AVagrant%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>本系列文章之前首发在csdn上。觉得还不错现在迁移过来。本文主要介绍安装与一些简单介绍。后续会有更深入的探讨。<br><a id="more"></a></p>
<blockquote>
<p>实际上Vagrant只是一个让你可以方便设置你想要的虚拟机的便携式工具，它底层支持VirtualBox、VMware甚至AWS作为虚拟机系统，本书中我们将使用VirtualBox来进行说明，所以第一步需要先安裝Vagrant和VirtualBox。</p>
<p>安装环境：mac<br>注：windows环境下，基本一致</p>
</blockquote>
<h1 id="安装VirtualBox"><a href="#安装VirtualBox" class="headerlink" title="安装VirtualBox"></a>安装VirtualBox</h1><p>直接来到官网 <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">https://www.virtualbox.org/wiki/Downloads</a> 点击下载最新的virtualbox，双击安装，一路傻瓜化完成。</p>
<h1 id="安装Vagrant"><a href="#安装Vagrant" class="headerlink" title="安装Vagrant"></a>安装Vagrant</h1><p>网上有说什么使用gem命令来安装的，建议大家别进这个坑了，直接到官网 <a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">https://www.vagrantup.com/downloads.html</a> 下载最新的vagrant，然后双击安装，也是一路傻瓜化，就不说。<br>在windows下安装vagrant，为了写入相应配置到环境变量，可能会要求重新启动一下系统。</p>
<h1 id="如何配置Vagrant"><a href="#如何配置Vagrant" class="headerlink" title="如何配置Vagrant"></a>如何配置Vagrant</h1><hr>
<h2 id="下载一个合适的box"><a href="#下载一个合适的box" class="headerlink" title="下载一个合适的box"></a>下载一个合适的box</h2><p>进行完以上步骤后，就需要考虑我们的虚拟机需要使用什么操作系统了，我这里会以CentOs7.0为例。在以前使用vm的过程中，我们需要自己去下载镜像，然后进行相关的安装，设置系统等等操作。而vagrant的开源社区，提供了很多已经打包好的操作系统，在vagrant的世界里被称为box。在 <a href="http://www.vagrantbox.es/" target="_blank" rel="external">http://www.vagrantbox.es/</a> 这里你可以找到你想要的操作系统box，当然你也可以自己制作一个。后续教程会讲到，这里就不多说。</p>
<h2 id="完成一个box的安装"><a href="#完成一个box的安装" class="headerlink" title="完成一个box的安装"></a>完成一个box的安装</h2><p>我的开发机是Mac，所以我建立了如下的开发环境目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /Users/helei/vagrant</span><br><span class="line">$ cd /Users/helei/vagrant</span><br></pre></td></tr></table></figure></p>
<p>本来，vagrant提供的在线安装，非常便利，但是无奈我国有非常NB的gfw，我为了速度，就先翻墙出去把box下载到本地，然后再进行安装。</p>
<blockquote>
<p>box链接：<a href="https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/centos-7.0-x86_64.box" target="_blank" rel="external">https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/centos-7.0-x86_64.box</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box add &#123;title&#125; &#123;url&#125;</span><br><span class="line">$ vagrant init &#123;title&#125;</span><br><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure>
<p>vagrant box add 是添加box的命令<br>其中｛title｝可以自行设置，我这里使用的是 <em>centos7</em> ，｛url｝是下载到本地box路径。我的路径是：/Users/helei/vagrant/centos-7.0-x86_64.box</p>
<p>下面把一些命令执行后的输出进行展示，方便大家比对：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装box</span><br><span class="line">$ vagrant box add CentOs7 /Users/helei/vagrant/centos-7.0-x86_64.box</span><br></pre></td></tr></table></figure></p>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Downloading or copying the box...</span><br><span class="line">Extracting box...te: 47.5M/s, Estimated time remaining: --:--:--)</span><br><span class="line">Successfully added box &apos;base&apos; with provider &apos;virtualbox&apos;!</span><br></pre></td></tr></table></figure></p>
<p>box中的镜像文件被放到了：/Users/helei/.vagrant.d/boxes/，如果在window系统中应该是放到了： C:\Users\当前用户名.vagrant.d\boxes\目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果是才add 的box，就必须执行本步骤，初始化一次后，以后启动系统，就不需要执行本步骤。</span><br><span class="line">$ vagrant init CentOs7</span><br></pre></td></tr></table></figure></p>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A `Vagrantfile` has been placed in this directory.</span><br><span class="line">You are now ready to `vagrant up` your first virtual environment!</span><br><span class="line">Please read the comments in the Vagrantfile as well as documentation on `vagrantup.com` for more information on using Vagrant.</span><br></pre></td></tr></table></figure></p>
<p>这样就会在当前目录生成一个 Vagrantfile的文件，里面有很多配置信息，后面我在慢慢说，默认不做任何配置改动，也是可以启动系统的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动系统</span><br><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure></p>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...</span><br><span class="line">[default] Importing base box &apos;base&apos;...</span><br><span class="line">[default] Matching MAC address for NAT networking...</span><br><span class="line">[default] Setting the name of the VM...</span><br><span class="line">[default] Clearing any previously set forwarded ports...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="ssh链接到安装的虚拟机"><a href="#ssh链接到安装的虚拟机" class="headerlink" title="ssh链接到安装的虚拟机"></a>ssh链接到安装的虚拟机</h2><p>经过以上操作后，完成了虚拟机的安装，现在需要登录上虚拟机，进行操作。链接很简单，可以使用第三方（xshell等）shell工具或系统自带的，进行登录<br>在系统中，如mac，可直接使用 <code>vagrant ssh</code> 来完成链接。或者使用第三方如xshell，ip地址是：localhost，端口，需要观察，映射的22端口是多少。一般是2200 或者2222<br>用户名与密码均是： vagrant</p>
<h1 id="vagrant的命令详解"><a href="#vagrant的命令详解" class="headerlink" title="vagrant的命令详解"></a>vagrant的命令详解</h1><hr>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>vagrant box add</td>
<td>添加box的操作</td>
</tr>
<tr>
<td>vagrant init</td>
<td>初始化box的操作，会生成vagrant的配置文件Vagrantfile</td>
</tr>
<tr>
<td>vagrant up</td>
<td>启动本地环境</td>
</tr>
<tr>
<td>vagrant ssh</td>
<td>通过 ssh 登录本地环境所在虚拟机</td>
</tr>
<tr>
<td>vagrant halt</td>
<td>关闭本地环境</td>
</tr>
<tr>
<td>vagrant suspend</td>
<td>暂停本地环境</td>
</tr>
<tr>
<td>vagrant resume</td>
<td>恢复本地环境</td>
</tr>
<tr>
<td>vagrant reload</td>
<td>修改了 Vagrantfile 后，使之生效（相当于先 halt，再 up）</td>
</tr>
<tr>
<td>vagrant destroy</td>
<td>彻底移除本地环境</td>
</tr>
<tr>
<td>vagrant box list</td>
<td>显示当前已经添加的box列表</td>
</tr>
<tr>
<td>vagrant box remove</td>
<td>删除相应的box</td>
</tr>
<tr>
<td>vagrant package</td>
<td>打包命令，可以把当前的运行的虚拟机环境进行打包</td>
</tr>
<tr>
<td>vagrant plugin</td>
<td>用于安装卸载插件</td>
</tr>
<tr>
<td>vagrant status</td>
<td>获取当前虚拟机的状态</td>
</tr>
<tr>
<td>vagrant global-status</td>
<td>显示当前用户Vagrant的所有环境状态</td>
</tr>
</tbody>
</table>
<p>下一篇，主要讲vagrant的配置，通过配置文件，实现多台虚拟机的启动.能够很方便的实现多台机器。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP设计模式：模板方法真的很有用]]></title>
      <url>https://helei112g.github.io/2016/09/09/PHP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9C%9F%E7%9A%84%E5%BE%88%E6%9C%89%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>模版方法很好的提现了继承的思想，我用它为核心完成了支付集成的开源项目，在使用过程中受益匪浅。<br><a id="more"></a></p>
<p>在设计模式分类中，模板方法被分在 <strong>行为型模式</strong></p>
<p>在我最近的项目中我也经常使用。然后在看YII的源码时，它的身影也随处可见。忍不住想要将它说一说。希望能够帮助大家解决一些开发中灵活扩展的问题。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以在不改变一个算法的结构的情况下重定义该算法的某些特定的步骤</p>
</blockquote>
<ul>
<li>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。</li>
<li>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。</li>
</ul>
<p>上面两点是行为型模式的一个特征。以上两点在 <strong>模板方法模式</strong> 中体现的非常明显。</p>
<p>教科书给出的概念读起来总是这么绕口。搞得人云里雾里的。还是结合代码来说吧。</p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="http://www.phppan.com/wp-content/uploads/2010/09/Template.jpg" alt="image"></p>
<h1 id="模板方法code案例"><a href="#模板方法code案例" class="headerlink" title="模板方法code案例"></a>模板方法code案例</h1><p>为了让大家能够在实际中看到设计模式的使用。我就直接用YII中的一些代码片段来讲。然后大家可以下载YII下来。然后自己对照看一看。</p>
<p>根据上面的类图。首先需要一个抽象的父类。它里边定义了一个 <code>templateMethod</code>  这个方法内部会调用 <code>primitiveOperation1</code>  <code>primitiveOperation2</code> 这两个方法。但是调用的两个发放是抽象的。要在子类中来具体决定实现。</p>
<p>先把示例代码写出来，大家看一看</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseObject</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 顶层组织逻辑的方法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;primitiveOperation1();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;primitiveOperation2();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 基本方法1</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">primitiveOperation1</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * 基本方法2</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">primitiveOperation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个抽象类定义好了调用的层次。凡是继承了它的子类，都需要实现这两个方法，并且完成自己相应的逻辑。比如一个子类继承了它。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 基本方法1</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">primitiveOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'primitiveOperation1&lt;br /&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * 基本方法2</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">primitiveOperation2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'primitiveOperation2&lt;br /&gt;'</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上基本上就是模板方法模式的全部代码。不知道大家是否从中领教到它的厉害之处？我先不解释，接下来看看YII中对这种设计模式的应用</p>
<h1 id="YII中的模板方法"><a href="#YII中的模板方法" class="headerlink" title="YII中的模板方法"></a>YII中的模板方法</h1><p>凡是用过YII的都知道，它有一个 <code>Object</code> 类。这个类是整个YII的基础。今天我们不说YII。单说设计模式。就略过不说了。下面是简化后的 <code>Object代码</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Configurable</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($config = [])</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>($config)) &#123;</span><br><span class="line">            Yii::configure(<span class="keyword">$this</span>, $config);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意这个方法</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// YII中为它定义了一个空实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>YII在 <code>Object</code> 的构造函数中，调用 <code>Object::init()</code> 这个方法。但是这个方法是一个空实现，因此具体要init的东西，延迟到了子类进行实现，</p>
<p>看看YII的代码，就知道基本上所有的类都是继承自这个类，每个类的init都可以进行个性化定制。</p>
<p>它的实现，我们可以看看 <code>ActiveController</code> 中代码的实现</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActiveController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">parent</span>::init();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;modelClass === <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidConfigException(<span class="string">'The "modelClass" property must be set.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>Controller</code> 也是继承自 <code>Object</code> 大家可以自己追踪一下代码。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>模板方法模式使用的范围非常广泛。总结一下它的特点</p>
<ul>
<li>将具体的一些实现延迟到子类，可以减少父类初始化的压力</li>
<li>父类只定义调用步骤，具体每一步的实现由子类自己决定</li>
<li>这样的结构利用了一种反射的思路，由父类来调用子类的具体实现方法</li>
<li>很好的进行了代码的复用</li>
</ul>
<p>在YII中有很多模板方法的使用，大家可以自己去阅读代码看一看。这种设计模式带来的一个麻烦的地方是查看代码的不方便。<br>比如：经常继承一个类后实现了一些方法，但是这个方法的调用关系一头雾水，如果遇到这种情况，建议去父类看看是否有个方法组织调用了你重写的方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入微信企业付款功能]]></title>
      <url>https://helei112g.github.io/2016/08/16/PHP%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E4%BB%98%E6%AC%BE%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>可以利用该接口，完成转账功能，目前仅微信支持，支付宝已关闭。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.0版本</a></p>
<p>这个功能与支付宝的批量付款到支付宝帐号功能类似。但是当前支付宝这个接口已经停止审核了。</p>
<p>当前很多提问平台就用到了这两个平台。比如［来问医生］，你提的问题如果被人看了。医生得0.5元，你得0.5元。然后累积够1元后，［来问医生］就会通过微信的企业付款功能给你的微信余额增加1元。</p>
<h1 id="代码调用"><a href="#代码调用" class="headerlink" title="代码调用"></a>代码调用</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">TransferContext</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Config</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成转款单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$wxconfig = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxa244db59a34996fc'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'1331302101'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'adslkfjiKQJLAIQLJ393201482333333'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时 退款  转款，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转款数据</span></span><br><span class="line">$transData = [</span><br><span class="line">    <span class="string">'trans_no'</span> =&gt; createPayid(),</span><br><span class="line">    <span class="string">'trans_data'</span>   =&gt; [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">'serial_no'</span> =&gt; createPayid(),</span><br><span class="line">            <span class="string">'user_account'</span> =&gt; <span class="string">'otijfvr2oMz3tXnaQdKKbQeeBmhM'</span>,<span class="comment">// 微信转款时，为用户所关注公众号的openid</span></span><br><span class="line">            <span class="string">'user_name'</span> =&gt; <span class="string">'愚不可及'</span>,</span><br><span class="line">            <span class="string">'trans_fee'</span> =&gt; <span class="string">'1'</span>,</span><br><span class="line">            <span class="string">'desc'</span>  =&gt; <span class="string">'测试批量转款'</span>,</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$refund = <span class="keyword">new</span> TransferContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 微信的企业付款， 仅支持单笔</span></span><br><span class="line">    $type = Config::WEIXIN;</span><br><span class="line">    $refund-&gt;initTransfer(Config::WEIXIN, $wxconfig);</span><br><span class="line"></span><br><span class="line">    $ret = $refund-&gt;transfer($transData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump($ret);</span><br></pre></td></tr></table></figure>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>trans_no</td>
<td>商户订单号</td>
<td>商户订单号，需保持唯一性</td>
<td>是</td>
</tr>
<tr>
<td>trans_data</td>
<td>转账数据</td>
<td>转账数据详细信息，具体内容如下</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>trans_data数据</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>serial_no</td>
<td>流水号</td>
<td>对于微信该参数不需要，但请保留，后期可能支持批量退款需要</td>
<td>否</td>
</tr>
<tr>
<td>user_account</td>
<td>用户openid</td>
<td>商户appid下，某用户的openid</td>
<td>是</td>
</tr>
<tr>
<td>user_name</td>
<td>收款用户姓名</td>
<td>收款用户真实姓名。</td>
<td>是</td>
</tr>
<tr>
<td>trans_fee</td>
<td>金额</td>
<td>企业付款金额，单位为元</td>
<td>是</td>
</tr>
<tr>
<td>desc</td>
<td>企业付款描述信息</td>
<td>企业付款操作说明信息。</td>
<td>是</td>
</tr>
</tbody>
</table>
<h1 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_success</td>
<td>是否成功</td>
<td>失败会返回错误原因。T:成功  F:失败</td>
<td>是</td>
</tr>
<tr>
<td>error</td>
<td>错误原因</td>
<td>为T时有返回</td>
<td>否</td>
</tr>
<tr>
<td>response</td>
<td>成功时数据</td>
<td>成功时返回的具体数据</td>
<td>否</td>
</tr>
</tbody>
</table>
<p><strong>response数据</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>trans_no</td>
<td>商户订单号</td>
<td>商户订单号，需保持唯一性</td>
<td>是</td>
</tr>
<tr>
<td>trans_id</td>
<td>微信订单号</td>
<td>企业付款成功，返回的微信订单号</td>
<td>否</td>
</tr>
<tr>
<td>payment_time</td>
<td>微信支付成功时间</td>
<td>企业付款成功时间</td>
<td>否</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入微信退款接口]]></title>
      <url>https://helei112g.github.io/2016/08/16/PHP%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>买的东西不喜欢了，想要还给商家，申请后商家自动退换购买商品时的买家支付的费用。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.0版本</a> </p>
<p>微信的退款操作，通过封装与前面<a href="https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/">支付宝退款</a>除了配置文件，基本一样。</p>
<p>退款代码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">RefundContext</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Config</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成退款单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$config = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxa244db59a34996fc'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'1331302101'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'adslkfjiKQJLAIQLJ393201482333333'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时 退款  转款，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退款数据</span></span><br><span class="line">$reundData = [</span><br><span class="line">    <span class="string">'refund_no'</span> =&gt; createPayid(),</span><br><span class="line">    <span class="string">'refund_data'</span>   =&gt; [</span><br><span class="line">        [<span class="string">'transaction_id'</span> =&gt; <span class="string">'4007572001201607098672633287'</span>, <span class="string">'amount'</span>   =&gt; <span class="string">'5'</span>, <span class="string">'refund_fee'</span> =&gt; <span class="string">'5'</span>, <span class="string">'reason'</span> =&gt; <span class="string">'微信测试金额退款'</span>],</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$refund = <span class="keyword">new</span> RefundContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 微信退款</span></span><br><span class="line">    $type = Config::WEIXIN;</span><br><span class="line">    $refund-&gt;initRefund(Config::WEIXIN, $wxconfig);</span><br><span class="line"></span><br><span class="line">    $ret = $refund-&gt;refund($reundData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump($ret);</span><br></pre></td></tr></table></figure></p>
<p>当前sdk支付宝可一次退款多笔数据。微信仅能每次退款1笔（如果想要实现一次退订多笔订单，可在客户端通过循环来处理。）</p>
<p>接下来解释下相关的配置信息</p>
<p>微信的配置文件解释参考 <a href="https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%94%AF%E4%BB%98%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%85%A5%EF%BC%9AAPP%E6%94%AF%E4%BB%98%E3%80%81%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%E3%80%81%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/">微信的三种支付方式接入：APP支付、公众号支付、扫码支付</a> 中的微信配置信息。</p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction_id</td>
<td>微信交易号</td>
<td>微信系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>总金额</td>
<td>微信交易对应的交易总金额</td>
<td>是</td>
</tr>
<tr>
<td>refund_fee</td>
<td>退款金额</td>
<td>本次申请的退款金额，退款金额不能大于总金额</td>
<td>是</td>
</tr>
<tr>
<td>reason</td>
<td>退款理由</td>
<td>退款的理由，可在用户端查看到</td>
<td>是</td>
</tr>
</tbody>
</table>
<h1 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_success</td>
<td>成功标识</td>
<td>请求是否成功，T:成功，F:失败</td>
<td>是</td>
</tr>
<tr>
<td>error</td>
<td>错误提示</td>
<td>只有is_success=F时才返回</td>
<td>否</td>
</tr>
<tr>
<td>response</td>
<td>响应数据</td>
<td>查询成功后返回的数据，一个数组，is_success=T时返回</td>
<td>否</td>
</tr>
</tbody>
</table>
<p><strong>response</strong> 数据描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction_id</td>
<td>微信订单号</td>
<td>微信订单号，下单成功后，微信返回</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户订单号</td>
<td>商户系统内部的订单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_no</td>
<td>商户退款单号</td>
<td>商户退款单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_id</td>
<td>微信退款单号</td>
<td>微信退款单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_fee</td>
<td>申请退款金额</td>
<td>退款总金额,单位为元(已被我处理),可以做部分退款</td>
<td>否</td>
</tr>
<tr>
<td>amount</td>
<td>订单金额</td>
<td>订单总金额，单位为元，最多两位小数</td>
<td>否</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信支付订单、退款订单、转款订单的查询]]></title>
      <url>https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E8%AE%A2%E5%8D%95%E3%80%81%E9%80%80%E6%AC%BE%E8%AE%A2%E5%8D%95%E3%80%81%E8%BD%AC%E6%AC%BE%E8%AE%A2%E5%8D%95%E7%9A%84%E6%9F%A5%E8%AF%A2/</url>
      <content type="html"><![CDATA[<p>主要介绍相关订单的查询，简化针对不同类型订单（支付的、退单的、转款的）的查询工作。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a></p>
<p>微信并未提供一个统一的查询接口。对应每种查询均需要不同的api。为了便于大家在项目中使用，忽略细节。对以上三种进行了封装。通过工厂的方式降低调用成本。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$wxconfig = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxxxx'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'xxxx'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxx'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">QueryContext</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Config</span>;</span><br><span class="line"></span><br><span class="line">$query = <span class="keyword">new</span> QueryContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过交易号查询，  推荐</span></span><br><span class="line">$data = [</span><br><span class="line">    <span class="comment">//'order_no'    =&gt; '2016011402433464',// 商户订单号</span></span><br><span class="line">    <span class="string">'transaction_id'</span>    =&gt; <span class="string">'4007572001201607098672633287'</span>,<span class="comment">// 微信订单查询  微信退款单查询</span></span><br><span class="line">    <span class="comment">//'trans_no'  =&gt; '1007570439201601142692427764', // 微信批量转款查询</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 微信订单查询</span></span><br><span class="line">    $query-&gt;initQuery(Config::WEIXIN, $wxconfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信退款订单状态查询</span></span><br><span class="line">    <span class="comment">//$query-&gt;initQuery(Config::WEIXIN_REFUND, $wxconfig);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信企业付款查询</span></span><br><span class="line">    <span class="comment">//$query-&gt;initQuery(Config::WEIXIN_TRANS, $wxconfig);</span></span><br><span class="line"></span><br><span class="line">    $ret = $query-&gt;query($data);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>订单查询非常简单。对于微信支付订单以及退款订单可以根据微信支付的流水号进行查询。对于微信支付的订单还可根据商户的订单号进行查询。但是强烈建议通过微信自身的流水号进行查询。</p>
<p>对于批量转款查询。需要提供再转款时，生产的转款单号（此单号是由商家自行生产的）。这里我也蛮迷惑，为什么不提供使用微信返回的转款流水号进行查询呢？</p>
<p>接下来对返回值进行解释,以下结构为一个顶层结构</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_success</td>
<td>成功标识</td>
<td>请求是否成功，T:成功，F:失败</td>
<td>是</td>
</tr>
<tr>
<td>error</td>
<td>错误提示</td>
<td>只有is_success=F时才返回</td>
<td>否</td>
</tr>
<tr>
<td>response</td>
<td>响应数据</td>
<td>查询成功后返回的数据，一个数组，is_success=T时返回</td>
<td>否</td>
</tr>
</tbody>
</table>
<h2 id="微信支付订单返回值"><a href="#微信支付订单返回值" class="headerlink" title="微信支付订单返回值"></a>微信支付订单返回值</h2><p>支付订单中关于 <code>response</code> 中包含字段的描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>交易金额</td>
<td>本次订单总金额，单位为元，最多两位小数</td>
<td>是</td>
</tr>
<tr>
<td>channel</td>
<td>支付渠道</td>
<td>本处取值： wx</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户网站唯一订单号</td>
<td>商户生成的订单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>buyer_id</td>
<td>用户标识</td>
<td>用户在商户appid下的唯一标识</td>
<td>是</td>
</tr>
<tr>
<td>trade_state</td>
<td>交易状态</td>
<td>支付成功与否，可取值：success  not_pay</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>微信交易号</td>
<td>微信系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>time_end</td>
<td>交易付款时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="微信退款订单"><a href="#微信退款订单" class="headerlink" title="微信退款订单"></a>微信退款订单</h2><p>退款有以下两点需要注意</p>
<ul>
<li>交易时间超过一年的订单无法提交退款；</li>
<li>微信支付退款支持单笔交易分多次退款，多次退款需要提交原支付订单的商户订单号和设置不同的退款单号。一笔退款失败后重新提交，要采用原来的退款单号。总退款金额不能超过用户实际支付金额。</li>
</ul>
<p>由于一笔支付订单，可能存在多笔退单的情况，因此退款记录将返回一个数组</p>
<p>退款订单中关于 <code>response</code> 中包含字段的描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>交易金额</td>
<td>本次订单总金额，单位为元，最多两位小数</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户网站唯一订单号</td>
<td>商户生成的订单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>微信交易号</td>
<td>微信系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>refund_data</td>
<td>退款数据</td>
<td>其结构是一个数组，每一个元素包含一个退单信息</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><code>refund_data</code> 中包含字段的描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>refund_no</td>
<td>商户退款单号</td>
<td>商户退款单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_id</td>
<td>微信退款单号</td>
<td>微信退款单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_channel</td>
<td>退款渠道</td>
<td>ORIGINAL—原路退款  BALANCE—退回到余额</td>
<td>是</td>
</tr>
<tr>
<td>refund_fee</td>
<td>退款金额</td>
<td>退款总金额,单位为元,可以做部分退款</td>
<td>是</td>
</tr>
<tr>
<td>refund_status</td>
<td>退款状态</td>
<td>SUCCESS—退款成功  FAIL—退款失败  PROCESSING—退款处理中  NOTSURE—未确定，需要商户原退款单号重新发起  CHANGE—转入代发</td>
<td>是</td>
</tr>
<tr>
<td>recv_accout</td>
<td>退款入账账户</td>
<td>退款入账账户</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="转款订单查询结果"><a href="#转款订单查询结果" class="headerlink" title="转款订单查询结果"></a>转款订单查询结果</h2><pre><code>&apos;trans_id&apos;  =&gt; $data[&apos;detail_id&apos;],// 付款单号
&apos;trans_status&apos;  =&gt; $data[&apos;status&apos;],// 转账状态
&apos;reason&apos;    =&gt; $data[&apos;reason&apos;],// 失败原因
&apos;buyer_id&apos;   =&gt; $data[&apos;openid&apos;],
&apos;trans_name&apos;   =&gt; $data[&apos;transfer_name&apos;],// 收款用户姓名
&apos;trans_time&apos;   =&gt; $data[&apos;transfer_time&apos;],
&apos;desc&apos;   =&gt; $data[&apos;desc&apos;],// 付款描述
</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>付款金额</td>
<td>付款金额  单位元</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户单号</td>
<td>商户使用查询API填写的单号的原路返回.</td>
<td>是</td>
</tr>
<tr>
<td>trans_id</td>
<td>付款单号</td>
<td>调用企业付款API时，微信系统内部产生的单号</td>
<td>是</td>
</tr>
<tr>
<td>trans_status</td>
<td>转账状态</td>
<td>SUCCESS:转账成功   FAILED:转账失败  PROCESSING:处理中</td>
<td>是</td>
</tr>
<tr>
<td>reason</td>
<td>失败原因</td>
<td>如果失败则有失败原因</td>
<td>否</td>
</tr>
<tr>
<td>buyer_id</td>
<td>收款用户openid</td>
<td>收款用户openid</td>
<td>是</td>
</tr>
<tr>
<td>trans_name</td>
<td>收款用户姓名</td>
<td>真实姓名，如果是需要实名验证，则会返回</td>
<td>否</td>
</tr>
<tr>
<td>trans_time</td>
<td>转账时间</td>
<td>发起转账的时间  格式：2015-04-21 20:00:00</td>
<td>是</td>
</tr>
<tr>
<td>desc</td>
<td>付款描述</td>
<td>付款时候的描述</td>
<td>是</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信的三种支付方式接入：APP支付、公众号支付、扫码支付]]></title>
      <url>https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%94%AF%E4%BB%98%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%85%A5%EF%BC%9AAPP%E6%94%AF%E4%BB%98%E3%80%81%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%E3%80%81%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/</url>
      <content type="html"><![CDATA[<p>微信支付：app支付、公众号支付、扫码支付使用文档。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>微信的支付逻辑与支付宝的支付有一些差别。为了让客户端忽略这些差别，统一调用。本sdk做了对应处理。</p>
<p>＃ SDK调用</p>
<p>微信支付不同接口需要的参数会有差别。请大家在使用接口时，仔细查看文档。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">ChargeContext</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Config</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信支付，必须设置时区，否则发生错误</span></span><br><span class="line">date_default_timezone_set(<span class="string">'Asia/Shanghai'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成订单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单信息</span></span><br><span class="line">$payData = [</span><br><span class="line">    <span class="string">"order_no"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"amount"</span>	=&gt; <span class="string">'0.01'</span>,<span class="comment">// 单位为元 ,最小为0.01</span></span><br><span class="line">    <span class="string">"client_ip"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'测试支付'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付接口测试'</span>,</span><br><span class="line">    <span class="string">"extra_param"</span>	=&gt; <span class="string">''</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信扫码支付，需要设置的参数</span></span><br><span class="line">$payData[<span class="string">'product_id'</span>]  = <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信公众号支付，需要的参数</span></span><br><span class="line">$payData[<span class="string">'openid'</span>] = <span class="string">'otijfvr2oMz3tXnaQdKKbQeeBmhM'</span>;<span class="comment">// 需要通过微信提供的api获取该openid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 包含客户的配置文件</span><br><span class="line"> * 本次 2.0 版本，主要的改变是将配置文件独立出来，便于客户多个账号的情况</span><br><span class="line"> * 已经使用不同方式读取配置文件，如：db  file   cache等</span><br><span class="line"> */</span></span><br><span class="line">$wxconfig = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxxxx'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'xxxx'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxx'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 实例化支付环境类，进行支付创建</span><br><span class="line"> */</span></span><br><span class="line">$charge = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信 扫码支付</span></span><br><span class="line">    $type = Config::WX_CHANNEL_QR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信 APP支付</span></span><br><span class="line">    <span class="comment">//$type = Config::WX_CHANNEL_APP;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信 公众号支付</span></span><br><span class="line">    <span class="comment">//$type = Config::WX_CHANNEL_PUB;</span></span><br><span class="line">    $charge-&gt;initCharge($type, $wxconfig);</span><br><span class="line">    $ret = $charge-&gt;charge($payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($type === Config::WX_CHANNEL_QR) &#123;</span><br><span class="line">    $url = urlencode($ret);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;img alt='扫码支付' src='http://paysdk.weixin.qq.com/example/qrcode.php?data=&#123;$url&#125;' style='width:150px;height:150px;'/&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ($type === Config::WX_CHANNEL_PUB) &#123;</span><br><span class="line">    $json = $ret;</span><br><span class="line">    var_dump($json);<span class="keyword">exit</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> (stripos($type, <span class="string">'wx'</span>) !== <span class="keyword">false</span>) &#123;</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里扫码支付与公众号支付分别需要提供不同的参数。请一定注意进行区分。否则调用相应端口会抛出异常。</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>app_id</td>
<td>公众账号ID/应用id</td>
<td>微信分配的公众账号ID</td>
<td>是</td>
</tr>
<tr>
<td>mch_id</td>
<td>商户号</td>
<td>微信支付分配的商户号</td>
<td>是</td>
</tr>
<tr>
<td>md5_key</td>
<td>加密的key</td>
<td>在商户中心设置</td>
<td>是</td>
</tr>
<tr>
<td>notify_url</td>
<td>通知地址</td>
<td>接收微信支付异步通知回调地址，通知url必须为直接可访问的url，不能携带参数。</td>
<td>是</td>
</tr>
<tr>
<td>time_expire</td>
<td>交易过期时间</td>
<td>单位为分钟，过期后无法再次支付</td>
<td>是</td>
</tr>
<tr>
<td>cert_path</td>
<td>密钥文件</td>
<td>可在微信商户后台中下载</td>
<td>否，退款需要</td>
</tr>
<tr>
<td>key_path</td>
<td>密钥文件</td>
<td>可在商户中心下载</td>
<td>否，退款需要</td>
</tr>
</tbody>
</table>
<p>这里需要注意的是，app_id，由于微信的三个支付接口，需要对应两个不同的app_id。因此再开发中一定要注意。</p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>order_no</td>
<td>订单号</td>
<td>平台根据规则生成的订单号，最长64位，要在商户数据库中唯一</td>
<td>必须</td>
</tr>
<tr>
<td>amount</td>
<td>交易总金额</td>
<td>该笔订单的资金总额，单位为RMB-Yuan。取值范围为[0.01，100000000.00]，精确到小数点后两位。</td>
<td>必须</td>
</tr>
<tr>
<td>client_ip</td>
<td>客户端IP</td>
<td>用户在创建交易时，该用户当前所使用机器的IP。</td>
<td>必须</td>
</tr>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>商品的标题/交易标题/订单标题/订单关键字等。该参数最长为128个汉字。</td>
<td>必须</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>对一笔交易的具体描述信息。如果是多种商品，请将商品描述字符串累加传给body。</td>
<td>必须</td>
</tr>
<tr>
<td>extra_param</td>
<td>公用回传参数</td>
<td>如果用户请求时传递了该参数，则返回给商户时会回传该参数。</td>
<td>可选</td>
</tr>
<tr>
<td>product_id</td>
<td>商品ID</td>
<td>扫码支付，此参数必传。此id为二维码中包含的商品ID，商户自行定义。</td>
<td>可选</td>
</tr>
<tr>
<td>openid</td>
<td>用户标识</td>
<td>公众号支付，此参数必传，用户在商户appid下的唯一标识。</td>
<td>可选</td>
</tr>
</tbody>
</table>
<h1 id="返回值描述"><a href="#返回值描述" class="headerlink" title="返回值描述"></a>返回值描述</h1><p>三种支付方式返回值因为处理方式不同，微信方面返回了不同的类型。</p>
<ul>
<li>app支付返回了需要调用的数组。调用客户端的方式 <a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_12&amp;index=2" target="_blank" rel="external">查看微信文档</a></li>
<li>扫码支付返回了一个地址。可生成一个二维码，完成支付。</li>
<li>公众号支付，返回的是一个json数据。可直接放入微信的sdk完成jsapi调用。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝有密批量转款接口]]></title>
      <url>https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E6%89%B9%E9%87%8F%E8%BD%AC%E6%AC%BE%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>转款接口，支付宝已经停止审核啦，目前可以用微信的企业付款。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>这个接口蛮有用的，不过现阶段支付宝已经停止审核啦！微信的转账功能还可以继续使用。企业可以转账到其他支付宝账户。对于企业活动非常有帮助，比如：购买返现呀！</p>
<p>虽然现在已经不接收新的审核，但是我还是将该功能进行了集成，因为指不定什么时候又开放了，毕竟微信都有这个功能，支付宝不搞出来，实在说不过去。</p>
<h1 id="SDK调用"><a href="#SDK调用" class="headerlink" title="SDK调用"></a>SDK调用</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝配置信息</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转款接口，必须配置以下两项</span></span><br><span class="line">    <span class="string">'account'</span>   =&gt; <span class="string">'xxxxxxx@126.com'</span>,</span><br><span class="line">    <span class="string">'account_name'</span> =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成转款单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转款数据</span></span><br><span class="line">$transData = [</span><br><span class="line">    <span class="string">'trans_no'</span> =&gt; createPayid(),</span><br><span class="line">    <span class="string">'trans_data'</span>   =&gt; [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">'serial_no'</span> =&gt; createPayid(),</span><br><span class="line">            <span class="string">'user_account'</span> =&gt; <span class="string">'dayugog@gmail.com'</span>,</span><br><span class="line">            <span class="string">'user_name'</span> =&gt; <span class="string">'愚不可及'</span>,</span><br><span class="line">            <span class="string">'trans_fee'</span> =&gt; <span class="string">'0.01'</span>,</span><br><span class="line">            <span class="string">'desc'</span>  =&gt; <span class="string">'测试批量转款'</span>,</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$refund = <span class="keyword">new</span> TransferContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $refund-&gt;initTransfer(Config::ALI, $aliconfig);</span><br><span class="line">    $ret = $refund-&gt;transfer($transData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转支付宝</span></span><br><span class="line">header(<span class="string">"Location:&#123;$ret&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>这个接口也是需要管理员输入支付密码，才能够完成，完成后也会回调。回调过程请参考 <a href="https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/">支付的回调统一处理</a> 已经说明。</p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>trans_no</td>
<td>转款单号</td>
<td>由商家自定义生成，可由字母、数字组成</td>
<td>是</td>
</tr>
<tr>
<td>trans_data</td>
<td>转款数据</td>
<td>详细内容见后表，它是一个数组</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>trans_data数据组成</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>serial_no</td>
<td>流水号</td>
<td>由商家自定义生成，可由字母、数字组成</td>
<td>是</td>
</tr>
<tr>
<td>user_account</td>
<td>收款方账号</td>
<td>收款方的支付宝账号，支持邮箱和手机号2种格式。</td>
<td>是</td>
</tr>
<tr>
<td>user_name</td>
<td>收款账号姓名</td>
<td>收款方的支付宝账户名。</td>
<td>是</td>
</tr>
<tr>
<td>trans_fee</td>
<td>付款金额</td>
<td>向该账号转入多少金额，单位元</td>
<td>是</td>
</tr>
<tr>
<td>desc</td>
<td>备注说明</td>
<td>可以是转款理由等，如：8月工资2W</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>这个地方SDK总做了很多工作，简化了相当多的参数，大家可以去对照原接口查看一下。<a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.rVbILN&amp;treeId=64&amp;articleId=104804&amp;docType=1" target="_blank" rel="external">支付宝原接口地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝有密退款接口]]></title>
      <url>https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>可针对订单完成退款操作，但是需要输入密码。不是谁都可以操作。微信退款则可以根据密钥文件自动完成，无须人为干预。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>这个接口主要用于退款操作。之前没有接入该功能时，商城用户如果想要退款，我们需要先查到对应用户的支付流水号，然后写退款申请给财务，财务到支付宝进行查询。完了之后原路退回。然后告诉程序，程序再去修改订单状态。</p>
<p>这样的流程不仅麻烦。而且充满不安全性。如果程序误操作（或者是心情太差了），操作为其他人员，那么这将会为企业带来很大的风险。</p>
<h1 id="SDK调用"><a href="#SDK调用" class="headerlink" title="SDK调用"></a>SDK调用</h1><p>支付宝支持多笔退款。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝配置信息</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成退款单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退款数据</span></span><br><span class="line">$reundData = [</span><br><span class="line">    <span class="string">'refund_no'</span> =&gt; createPayid(),</span><br><span class="line">    <span class="string">'refund_data'</span>   =&gt; [</span><br><span class="line">        [<span class="string">'transaction_id'</span> =&gt; <span class="string">'2016011421001004330041239366'</span>, <span class="string">'amount'</span>   =&gt; <span class="string">'0.01'</span>, <span class="string">'refund_fee'</span> =&gt; <span class="string">'0.01'</span>, <span class="string">'reason'</span> =&gt; <span class="string">'测试退款1'</span>],</span><br><span class="line">        [<span class="string">'transaction_id'</span> =&gt; <span class="string">'2016031521001004330271745693'</span>, <span class="string">'amount'</span>   =&gt; <span class="string">'0.01'</span>, <span class="string">'refund_fee'</span> =&gt; <span class="string">'0.01'</span>, <span class="string">'reason'</span> =&gt; <span class="string">'测试退款2'</span>],</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$refund = <span class="keyword">new</span> RefundContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $refund-&gt;initRefund(Config::ALI, $aliconfig);</span><br><span class="line">    $ret = $refund-&gt;refund($reundData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转支付宝</span></span><br><span class="line">header(<span class="string">"Location:&#123;$ret&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>以上请求发送完毕后，会跳转到生成的url。界面如下：</p>
<p><img src="https://helei112g.github.io/images/ali-refund.png" alt="image"></p>
<p>这时候，只需要要输入支付密码。就可完成退款。确认完毕后会自动完成异步通知。异步通知数据内容在 <a href="https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/">支付的回调统一处理</a> 已经说明。</p>
<p>备注：支付宝支持一次退款多笔。也可单次退款一笔，请自行根据情况进行设置。</p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>refund_no</td>
<td>退款单号</td>
<td>由商家自定义生成，可由字母、数字组成</td>
<td>是</td>
</tr>
<tr>
<td>refund_data</td>
<td>退款数据</td>
<td>详细内容见后表，它是一个数组</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>refund_data数据</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction_id</td>
<td>支付宝流水号</td>
<td>支付成功时，异步通知时有返回</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>订单总金额</td>
<td>订单总金额，应该等于支付时的金额</td>
<td>否</td>
</tr>
<tr>
<td>refund_fee</td>
<td>退款金额</td>
<td>退款金额，不能超过支付的总金额</td>
<td>是</td>
</tr>
<tr>
<td>reason</td>
<td>退款理由</td>
<td>退款理由</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>一笔订单，可分多次进行退款处理。比如：一笔支付100元的订单。可分为10次，每次退款10元。该思路可扩展一下，就可实现提现功能（原路返回），想要具体了解提现功能，可咨询我！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝单笔订单查询接口]]></title>
      <url>https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E5%8D%95%E7%AC%94%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>查询支付宝订单状态<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>巴西奥运会来了，刚好我又是做体育行业的互联网。哎！这个月又要加班成狗了。最近遇到好多莫名其妙的问题，待我忙完这段，再跟大家分享下。今天还是继续说说 <a href="https://github.com/helei112g/payment" target="_blank" rel="external">Payment项目</a><br>今天主要说说支付宝订单查询接口。</p>
<h1 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h1><p>废话废话不多说。直接上支付宝订单查询的代码。微信的订单查询与此类似。后续也会更新文档。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝配置信息</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$data = [</span><br><span class="line">    <span class="comment">// 通过支付宝交易号查询，  推荐  效率更高</span></span><br><span class="line">    <span class="string">'transaction_id'</span>    =&gt; <span class="string">'2016011421001004330041239366'</span>,<span class="comment">// 支付宝</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过订单号查询</span></span><br><span class="line">    <span class="string">'order_no'</span>    =&gt; <span class="string">'2016011402433464'</span>,<span class="comment">// 支付宝</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$query = <span class="keyword">new</span> QueryContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 支付宝查询</span></span><br><span class="line">    $query-&gt;initQuery(Config::ALI, $aliconfig);</span><br><span class="line">    $ret = $query-&gt;query($data);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump($ret);</span><br></pre></td></tr></table></figure>
<p>非常简单，只需要提供支付宝的流水号，或者商家自己生成的订单号，就可完成订单详情的查询，当然前提是，依然要去签约这个接口（觉得支付宝真扯淡，都能够支付了，为什么查询还要单独签约？这一点微信比它强）</p>
<p>如果同时提供了 <code>transaction_id</code> 跟 <code>order_no</code> 这两个参数，会优先使用 <code>transaction_id</code> ,因为他的效率要高的多。</p>
<p>代码完成了下面分别解释下请求的参数。以及返回参数。关于支付宝的配置参数，请参考 <a href="https://helei112g.github.io/2016/07/29/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E3%80%81%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/">PHP接入支付宝手机网站支付、移动支付接口</a></p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><p>查询订单的参数非常简单。这里能够查询的仅指：支付成功后的订单</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction_id</td>
<td>支付宝流水号</td>
<td>支付成功后，异步通知中会返回</td>
<td>二选一</td>
</tr>
<tr>
<td>order_no</td>
<td>商户订单号</td>
<td>商户生成的唯一订单号</td>
<td>二选一</td>
</tr>
</tbody>
</table>
<p>对于上表中的数据，两个字段二选一即可。推荐使用 <code>transaction_id</code> ，该字段查询效率更高。如果两个字段同时提供，会优先使用 <code>transaction_id</code>。</p>
<p>请求后，程序会向支付宝进行查询。查询完成后，会将返回的数据做一定处理然后返回给客户端。</p>
<h1 id="返回参数"><a href="#返回参数" class="headerlink" title="返回参数"></a>返回参数</h1><p>查询存在两种情况，失败，成功，分别对返回字段含义进行说明。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_success</td>
<td>成功标识</td>
<td>请求是否成功，T:成功，F:失败</td>
<td>是</td>
</tr>
<tr>
<td>error</td>
<td>错误提示</td>
<td>只有is_success=F时才返回</td>
<td>否</td>
</tr>
<tr>
<td>response</td>
<td>响应数据</td>
<td>查询成功后返回的数据，一个数组，is_success=T时返回</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>关于 <code>response</code> 中包含字段的描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>订单的关键字</td>
<td>是</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>提交订单时的body值</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>交易金额</td>
<td>本次订单总金额</td>
<td>是</td>
</tr>
<tr>
<td>channel</td>
<td>支付渠道</td>
<td>本处取值： ali</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户网站唯一订单号</td>
<td>商户生成的订单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>buyer_id</td>
<td>买家支付宝账户号</td>
<td>可以是Email或手机号码。</td>
<td>是</td>
</tr>
<tr>
<td>trade_state</td>
<td>交易状态</td>
<td>支付成功与否，可取值：success  not_pay</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>支付宝交易号</td>
<td>支付宝系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>time_end</td>
<td>交易付款时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>针对查询返回的数据，调用者可进行相关的业务处理。如果需要更多信息可联系我进行定制开发，也可自行更改代码完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[支付的回调统一处理]]></title>
      <url>https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>支付成功的订单，都需要通过第三方的回调来告知自身服务器，任务已经完成，为了让使用者专注自身的业务，这个接口封装了一些基础处理，如：验签、数据解析等<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>经过这一段时间，终于把支付宝支付相关接口完成了。文档将陆续更新。这里先把回调的文档补充完成。这样结合之前 提供的 <a href="https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%EF%BC%9A%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/">支付宝即时到帐接口</a> 才能形成一个闭环。完成一次完整的支付流程。</p>
<h1 id="回调接口介绍"><a href="#回调接口介绍" class="headerlink" title="回调接口介绍"></a>回调接口介绍</h1><blockquote>
<p>支付服务商(支付宝、微信、PayPal等)处理完支付数据后。会将处理的结果数据通过服务器主动通知的方式通知给商户网站。这些处理结果数据就是服务器异步通知参数。</p>
</blockquote>
<p>简单来说，就是支付成功后，支付服务商告诉你，钱已经到账了，你应该把别个买的东西给别个了。</p>
<p>由于本次发布的接口主要都是与支付宝相关，因此本次回调的部分代码也主要先上支付宝的。微信等后期开发完成将更新相关文档。</p>
<p>针对不同的回调，我提供了统一的调用方式，让客户端专注自己的业务。不在处理支付相关的签名验证、来源验证的问题。下面代码是统一的回调处理代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 支付宝配置文件</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,<span class="comment">// 请填写自己的支付宝账号信息</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxx'</span>,<span class="comment">// 此密码无效，请填写自己对应设置的值</span></span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转款接口，必须配置以下两项</span></span><br><span class="line">    <span class="string">'account'</span>   =&gt; <span class="string">'xxxxxxx@126.com'</span>,</span><br><span class="line">    <span class="string">'account_name'</span> =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信配置文件</span></span><br><span class="line">$wxconfig = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxxxx'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'xxxx'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxx'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取异步通知上下文</span></span><br><span class="line">$notify = <span class="keyword">new</span> NotifyContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端的业务逻辑类。处理如：订单更新</span></span><br><span class="line">$callback = <span class="keyword">new</span> TestNotify();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 支付宝回调</span></span><br><span class="line">    <span class="comment">//$notify-&gt;initNotify(Config::ALI, $aliconfig);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 微信回调</span></span><br><span class="line">    $notify-&gt;initNotify(Config::WEIXIN, $wxconfig);</span><br><span class="line">    $notify-&gt;notify($callback);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端类 <code>TestNotify</code> 的注意事项 ，一定要继承 <code>PayNotifyInterface</code> 这个类</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Notify</span>\<span class="title">PayNotifyInterface</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestNotify</span> <span class="keyword">implements</span> <span class="title">PayNotifyInterface</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 客户端的业务逻辑，</span><br><span class="line">     * <span class="doctag">@param</span> array $data</span><br><span class="line">     * <span class="doctag">@return</span> bool  返回值一定是bool值</span><br><span class="line">     * <span class="doctag">@author</span> helei</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notifyProcess</span><span class="params">(array $data)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 一般支付的处理业务</span></span><br><span class="line">        <span class="number">1.</span> 检查订单是否存在</span><br><span class="line">        <span class="number">2.</span> 检查金额是否正确</span><br><span class="line">        <span class="number">3.</span> 检查订单是否已经处理过（防止重复通知）</span><br><span class="line">        <span class="number">4.</span> 更新订单</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>TestNotify::notifyProcess()</code> 方法中，我注释了常规的订单处理流程。这个地方客户端可根据自己的情况进行适当调整。只是返回结果一定需要 <strong>布尔值</strong></p>
<p>现在的重点是 <code>TestNotify::notifyProcess()</code> 方法中的参数 $data 中具体包含的值。根据不同的回调业务，返回的值也不一样。具体请往下看。</p>
<h1 id="支付宝回调通知类型"><a href="#支付宝回调通知类型" class="headerlink" title="支付宝回调通知类型"></a>支付宝回调通知类型</h1><p>支付宝的回调，与支付相关的对应三种类型。</p>
<ul>
<li>trade_status_sync  支付行为相关的异步通知</li>
<li>batch_refund_notify   有密批量退款的异步通知</li>
<li>batch_trans_notify   有密批量付款到支付宝账号的通知</li>
</ul>
<h2 id="trade-status-sync-异步通知返回数据"><a href="#trade-status-sync-异步通知返回数据" class="headerlink" title="trade_status_sync 异步通知返回数据"></a>trade_status_sync 异步通知返回数据</h2><p>该回调发生在：移动支付、即时到帐、手机网站支付接口调用后，如果支付成功，支付宝会发起回调接口。</p>
<p>返回的对应数据如下表</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>订单的关键字</td>
<td>是</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>提交订单时的body值</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>交易金额</td>
<td>本次订单总金额</td>
<td>是</td>
</tr>
<tr>
<td>channel</td>
<td>支付渠道</td>
<td>本处取值： ali</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户网站唯一订单号</td>
<td>商户生成的订单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>buyer_id</td>
<td>买家支付宝账户号</td>
<td>可以是Email或手机号码。</td>
<td>是</td>
</tr>
<tr>
<td>trade_state</td>
<td>交易状态</td>
<td>支付成功与否，可取值：success  not_pay</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>支付宝交易号</td>
<td>支付宝系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>time_end</td>
<td>交易付款时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
<tr>
<td>notify_time</td>
<td>通知时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
<tr>
<td>notify_type</td>
<td>通知类型</td>
<td>此处为：trade  表示交易</td>
<td>是</td>
</tr>
<tr>
<td>extra_param</td>
<td>商户自定义参数</td>
<td>仅即时到帐支持</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>传入到 <code>TestNotify::notifyProcess()</code> 中的数组，包括以上key。可根据以上内容进行业务处理。</p>
<h2 id="batch-refund-notify-异步通知返回数据"><a href="#batch-refund-notify-异步通知返回数据" class="headerlink" title="batch_refund_notify 异步通知返回数据"></a>batch_refund_notify 异步通知返回数据</h2><p>本类回调发生在操作退款后，支付宝会通知服务器是否退款成功。退款的界面，如下图：</p>
<p><img src="http://note.youdao.com/yws/public/resource/82ee87138ba987799b398e12b6c79c95/685E18BF0FF041C780F3E1721DA9A26A" alt="image"></p>
<p>输入支付密码后，就可完成退款。退款后支付宝会向商户服务器进行异步通知。他返回的数据如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>channel</td>
<td>渠道</td>
<td>本处取值： ali</td>
<td>是</td>
</tr>
<tr>
<td>refund_no</td>
<td>商户网站唯一退单号</td>
<td>商户生成的退单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>success_num</td>
<td>退款成功总数</td>
<td>0&lt;= success_num&lt;= 总退款笔数</td>
<td>是</td>
</tr>
<tr>
<td>notify_time</td>
<td>通知时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
<tr>
<td>notify_type</td>
<td>通知类型</td>
<td>此处为：trade  表示交易</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="batch-trans-notify-异步通知返回数据"><a href="#batch-trans-notify-异步通知返回数据" class="headerlink" title="batch_trans_notify 异步通知返回数据"></a>batch_trans_notify 异步通知返回数据</h2><p>该回调发生在批量付款后。返回的数据如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>channel</td>
<td>渠道</td>
<td>本处取值： ali</td>
<td>是</td>
</tr>
<tr>
<td>trans_no</td>
<td>商户网站唯一转账单号</td>
<td>商户生成的转账单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>pay_name</td>
<td>付款账号姓名</td>
<td>如果是个人为昵称，公司则为公司名称</td>
<td>是</td>
</tr>
<tr>
<td>pay_account</td>
<td>付款账号</td>
<td>邮箱或者手机号码</td>
<td>是</td>
</tr>
<tr>
<td>notify_time</td>
<td>通知时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
<tr>
<td>notify_type</td>
<td>通知类型</td>
<td>此处为：trade  表示交易</td>
<td>是</td>
</tr>
<tr>
<td>success</td>
<td>转账成功的详细信息</td>
<td>返回的是一个数组</td>
<td>是</td>
</tr>
<tr>
<td>fail</td>
<td>转账失败的详细信息</td>
<td>返回的是一个数组</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>备注：</strong></p>
<ul>
<li>success返回的数组中，单条记录格式如下：</li>
</ul>
<blockquote>
<p>流水号^收款方账号^收款账号姓名^付款金额^成功标识(S)^成功原因(null)^支付宝内部流水号^完成时间。</p>
</blockquote>
<ul>
<li>fail返回数据中的单条记录格式如下：</li>
</ul>
<blockquote>
<p>流水号^收款方账号^收款账号姓名^付款金额^失败标识(F)^失败原因^支付宝内部流水号^完成时间。</p>
</blockquote>
<p>OK。到此支付宝相关的回调通知数据，已经全部处理完成。这里需要大家注意一个问题，上面的数据并不是完整的支付宝返回数据。大部分经过了我的简化，如果有需要的参数，没有返回可执行修改源码或者联系我。</p>
<h1 id="微信支付回调"><a href="#微信支付回调" class="headerlink" title="微信支付回调"></a>微信支付回调</h1><p>微信的回调代码部分与支付宝相同。不同的主要是返回值</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>订单金额</td>
<td>微信默认为分，此处以处理为元，两位小数</td>
<td>是</td>
</tr>
<tr>
<td>channel</td>
<td>支付渠道</td>
<td>可取之为：ali   wx  此处为wx</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户订单号</td>
<td>商户系统的订单号，与请求一致。</td>
<td>是</td>
</tr>
<tr>
<td>buyer_id</td>
<td>用户标识</td>
<td>用户在商户appid下的唯一标识</td>
<td>是</td>
</tr>
<tr>
<td>trade_state</td>
<td>交易状态</td>
<td>表示交易成功，返回值：success</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>微信支付订单号</td>
<td>微信支付订单号</td>
<td>是</td>
</tr>
<tr>
<td>time_end</td>
<td>支付完成时间</td>
<td>支付完成时间，格式为yyyy-MM-dd HH:mm:ss</td>
<td>是</td>
</tr>
<tr>
<td>notify_time</td>
<td>异步通知发生时间</td>
<td>支付完成时间，格式为yyyy-MM-dd HH:mm:ss</td>
<td>是</td>
</tr>
<tr>
<td>notify_type</td>
<td>通知类型</td>
<td>此处为：trade  表示交易</td>
<td>是</td>
</tr>
<tr>
<td>extra_param</td>
<td>商户自定义参数</td>
<td>仅即时到帐支持</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>大家可以对比支付宝中异步通知的返回数据。对相关数据均做了命令统一、数据单位格式统一。方便再业务中进行统一处理。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝手机网站支付、移动支付接口]]></title>
      <url>https://helei112g.github.io/2016/07/29/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E3%80%81%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>支付宝手机网站、移动支付（app）接口。统一的接入方式，便于项目管理<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>前面已经说完了 PHP接入支付宝 即时到帐接口</p>
<p>回调接口也已经完成。这篇主要讲 <strong>手机网站支付</strong> 、 <strong>移动支付</strong> 接口的调用。调用方式与即时到帐 基本一样。</p>
<p>关于代码部分的详细解释，请 参看 <a href="https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%EF%BC%9A%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/">PHP接入支付宝 即时到帐接口</a></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 订单数组</span></span><br><span class="line">$orderData = [</span><br><span class="line">    <span class="string">"order_no"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"amount"</span>	=&gt; <span class="string">'0.01'</span>,<span class="comment">// 单位为元 ,最小为0.01</span></span><br><span class="line">    <span class="string">"client_ip"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'      测试支付'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付接口测试'</span>,</span><br><span class="line">    <span class="string">"show_url"</span>  =&gt; <span class="string">'http://mall.tiyushe.com/goods/23.html'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支付宝配置信息</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化环境类</span></span><br><span class="line"></span><br><span class="line">$charge = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 支付宝即时到帐接口</span></span><br><span class="line">    <span class="comment">// $type = Config::ALI_CHANNEL_WEB;</span></span><br><span class="line">    <span class="comment">// $charge-&gt;initCharge($type, $aliconfig);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付宝 手机网站支接口</span></span><br><span class="line">    <span class="comment">// $type = Config::ALI_CHANNEL_WAP;</span></span><br><span class="line">    <span class="comment">// $charge-&gt;initCharge($type, $aliconfig);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付宝 移动支付接口</span></span><br><span class="line">    $type = Config::ALI_CHANNEL_APP;</span><br><span class="line">    $charge-&gt;initCharge($type, $aliconfig);</span><br><span class="line">    $ret = $charge-&gt;charge($payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($type === Config::ALI_CHANNEL_APP) &#123;</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 跳转支付宝</span></span><br><span class="line">    header(<span class="string">"Location:&#123;$ret&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>oK！大家仔细看代码。唯一不同的，仅仅是支付的方式这个常量。<br>目前常量的含义</p>
<ul>
<li>Config::ALI_CHANNEL_WEB  及时到账接口，主要用于网站支付</li>
<li>Config::ALI_CHANNEL_WAP  手机网站支付接口，主要用于手机浏览器</li>
<li>Config::ALI_CHANNEL_APP  移动支付接口，主要用于原生APP</li>
</ul>
<p>调用方式非常统一，传入的参数也被最大程度的统一化。简化了客户端的调用。这里主要对参数进行一些说明。</p>
<h1 id="支付宝配置数据"><a href="#支付宝配置数据" class="headerlink" title="支付宝配置数据"></a>支付宝配置数据</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>partner</td>
<td>合作者身份ID</td>
<td>签约的支付宝账号对应的支付宝唯一用户号。以2088开头的16位纯数字组成。</td>
<td>是</td>
</tr>
<tr>
<td>md5_key</td>
<td>MD5密钥</td>
<td><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.qt91b7&amp;treeId=62&amp;articleId=104740&amp;docType=1#s1" target="_blank" rel="external">点击这里</a></td>
<td>是</td>
</tr>
<tr>
<td>rsa_private_key</td>
<td>RSA私钥</td>
<td><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.qt91b7&amp;treeId=62&amp;articleId=104740&amp;docType=1#s0" target="_blank" rel="external">点击这里</a></td>
<td>是</td>
</tr>
<tr>
<td>notify_url</td>
<td>服务器异步通知URI</td>
<td>支付宝服务器主动通知商户网站里指定的页面http路径。(建议使用https)</td>
<td>否</td>
</tr>
<tr>
<td>return_url</td>
<td>页面跳转同步通知页面路径</td>
<td>支付宝处理完请求后，当前页面自动跳转到商户网站里指定页面的url路径。仅在即时到账接口有效</td>
<td>否</td>
</tr>
<tr>
<td>time_expire</td>
<td>超时时间</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。单位默认为分钟</td>
<td>否</td>
</tr>
</tbody>
</table>
<h1 id="订单数据"><a href="#订单数据" class="headerlink" title="订单数据"></a>订单数据</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$orderData = [</span><br><span class="line">    <span class="string">"order_no"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"amount"</span>	=&gt; <span class="string">'0.01'</span>,<span class="comment">// 单位为元 ,最小为0.01</span></span><br><span class="line">    <span class="string">"client_ip"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'      测试支付'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付接口测试'</span>,</span><br><span class="line">    <span class="string">"show_url"</span>  =&gt; <span class="string">'http://mall.tiyushe.com/goods/23.html'</span>,</span><br><span class="line">    <span class="string">"extra_param"</span>   =&gt; <span class="string">'自定义参数'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>order_no</td>
<td>订单号</td>
<td>平台根据规则生成的订单号，最长64位，要在商户数据库中唯一</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>交易总金额</td>
<td>该笔订单的资金总额，单位为RMB-Yuan。取值范围为[0.01，100000000.00]，精确到小数点后两位。</td>
<td>是</td>
</tr>
<tr>
<td>client_ip</td>
<td>客户端IP</td>
<td>用户在创建交易时，该用户当前所使用机器的IP。</td>
<td>是</td>
</tr>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>商品的标题/交易标题/订单标题/订单关键字等。该参数最长为128个汉字。</td>
<td>是</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>对一笔交易的具体描述信息。如果是多种商品，请将商品描述字符串累加传给body。</td>
<td>是</td>
</tr>
<tr>
<td>show_url</td>
<td>商品展示网址</td>
<td>收银台页面上，商品展示的超链接。</td>
<td>手机网站支付接口：必须，其他：可选</td>
</tr>
<tr>
<td>extra_param</td>
<td>公用回传参数</td>
<td>如果用户请求时传递了该参数，则返回给商户时会回传该参数。仅在即时到帐接口有效</td>
<td>是</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[php设计模式：策略模式的实际应用]]></title>
      <url>https://helei112g.github.io/2016/07/23/php%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>多学两个设计模式总是好的，自己不写，但是总要看别人的代码吧？<br><a id="more"></a></p>
<p>最近写了一个集成各家支付的开源项目（支付宝与微信）。<a href="https://github.com/helei112g/payment" target="_blank" rel="external">项目地址</a>。让调用支付变得更加简单、统一。目前已经在<a href="http://mall.tiyushe.com/" target="_blank" rel="external">公司商城</a>推行使用，上海<a href="http://yimishiji.com/" target="_blank" rel="external">一米市集</a>也采用了这个支付集成项目。</p>
<p>我可不是打广告哦，只是为了让大家可以有一个只管的了解渠道。可以去看看。</p>
<p>今天主要聊的不是支付，而是说说其中使用的一个设计模式：策略模式。</p>
<h1 id="策略模式的定义解析"><a href="#策略模式的定义解析" class="headerlink" title="策略模式的定义解析"></a>策略模式的定义解析</h1><blockquote>
<p>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</p>
</blockquote>
<p>这是书本上给的定义，是不是完全搞不懂？我结合支付，再来给你解释一下，一定就赫然开朗啦！</p>
<p>首先是这句 <strong>让算法独立于使用它的客户而变化</strong>  （我是倒着在分析哦）。<br>这是什么意思？也就是说实现一个功能，有多个方法，而选择这个方法的控制权不要交给客户端，也就说了，我换了实现方法，客户端是不需要改代码的。</p>
<p>那么要做到这样子，必然提供给客户端的一个稳定的调用类(称为环境类)，首先调用这个类能够产生一个具体算法的实例，其次这个调用类，还需要公布一个接口，让客户端调用实现具体功能。</p>
<p>那么做到以上，无论实现多少种双方，客户端的调用都是不变的。控制权都在这个调用类里边，由它来决定到底采用哪种算法。</p>
<p>下面来接着说算法部分。如果需要 <strong>环境类</strong> 提供一个实现具体功能的接口，那么这些算法必然实现了一个公共接口（称为抽象策略类）。才能确保有相同的方法提供出来。然后具体的算法都要实现这个接口。这也就是上面定义中的 <strong>将每一个算法封装起来</strong> 每一个具体的算法称为：具体策略类</p>
<p>不知道这个解释大家清楚定义了没有，如果还不清楚，看类图</p>
<h1 id="类图演示"><a href="#类图演示" class="headerlink" title="类图演示"></a>类图演示</h1><p>策略模式包含的角色如下：</p>
<ul>
<li>Context: 环境类</li>
<li>Strategy: 抽象策略类</li>
<li>ConcreteStrategy: 具体策略类</li>
</ul>
<p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/Strategy.jpg" alt="image"></p>
<p>这下子是不是很清楚了？策略模式是使用非常广泛的一个设计模式。他很好的提现了：控制反转、依赖注入等思想。有同学说，不想看文字，有本事上代码呀！嗯，我喜欢，新鲜出炉的代码来了</p>
<h1 id="策略模式PHP代码实现"><a href="#策略模式PHP代码实现" class="headerlink" title="策略模式PHP代码实现"></a>策略模式PHP代码实现</h1><p>在整个模式中，Strategy 起着承上启下的作用。我就先来实现它</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ChargeStrategy</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，抽象策略类就完成了，他的主要目的就是规范一个必须要实现的方法，环境类依赖这个接口进行编程。</p>
<p>下面接着写算法的实现。还是以支付宝支付、微信支付为例。对于用户来说他要实现的功能是支付。那么支付又有多种选择(多种算法)。但是客户端不需要做出选择，他把这个权利让 环境类 去选择。这样子客户端就简单了。所有的算法需要实现 策略类接口。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝策略类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AliCharge</span> <span class="keyword">implements</span> <span class="title">ChargeStrategy</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 完成支付宝的相关逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信策略类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WxCharge</span> <span class="keyword">implements</span> <span class="title">ChargeStrategy</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 完成微信的相关逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里声明一下，这里为了纯粹的把 策略模式 讲明白，抛开了很多细枝末节，真正的支付中的实现，大家可以去看看<a href="https://github.com/helei112g/payment" target="_blank" rel="external">项目</a>的源代码。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ChargeContext</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@var</span> ChargeStrategy $charge</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> $charge;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">initInstance</span><span class="params">($channel)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($channel == <span class="string">'ali'</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;charge = <span class="keyword">new</span> AliCharge;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($chananel == <span class="string">'wx'</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;charge = <span class="keyword">new</span> WxCharge;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;charge = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_null(<span class="keyword">$this</span>-&gt;charge)) &#123;</span><br><span class="line">            <span class="keyword">exit</span>(<span class="string">'初始化错误'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">$this</span>-&gt;charge-&gt;charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就基本完成了，而对于客户端来说，就非常简单啦。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户选择的支付方式</span></span><br><span class="line">$channel = trim($_GET[<span class="string">'channel'</span>]);</span><br><span class="line"></span><br><span class="line">$context = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化支付实例</span></span><br><span class="line">$context-&gt;initInstance($channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用功能</span></span><br><span class="line">$context-&gt;charge();</span><br></pre></td></tr></table></figure>
<p>代码写完了，不知道大家有没有感受到好处，这个模式很好的实现了开闭原则。比如说：现在新增加了一个PayPal支付方式。那么只需要添加一个PayPal的策略算法。在ChargeContext中把对应的实例初始化加进去，其他地方都不需要动的。</p>
<h1 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h1><p>最后再说几句，不知道大家注意到没有，在 <code>ChargeContext</code> 这个类中，其实还使用了 <strong>简单工厂</strong> 这个模式。这里想给大家说明的是，其实设计模式只是一些编码的技巧，完全可以自由搭配组合，基本思想就是 <a href="http://blog.csdn.net/hel12he/article/details/51351763" target="_blank" rel="external">设计模式的六大原则</a> </p>
<p>当然，实际编码中也没有必要非要都实现这六大原则。这个也没有什么规范，只能大家多去实践，然后自己约定出一套适合业务的规范就好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[支付宝：即时到账接口接入]]></title>
      <url>https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%EF%BC%9A%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/</url>
      <content type="html"><![CDATA[<p>支付宝即时到账接口，简化支付宝本身文档一大堆的配置。让工作变得轻松<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p><strong>特别声明：</strong></p>
<blockquote>
<p>以下文档均针对 payment 2.0 以上版本，并且PHP需要5.5以上(含)。<br>代码中所有编码均使用 utf-8 。</p>
</blockquote>
<p>通过几天的时间，终于把payment 2.0的基本结构搭好了。今天刚完成支付宝 <strong>即时到帐</strong> 接口的开发。赶紧把使用文档给补上。请大家一定仔细查看文档，实在还不行就来问我吧！（我期待你问我，反正我收钱的，哈哈）</p>
<h1 id="即时到帐-接口签约"><a href="#即时到帐-接口签约" class="headerlink" title="即时到帐 接口签约"></a>即时到帐 接口签约</h1><p>在你使用这个接口时，请先确认你是否在支付宝商户中心签约了该接口。</p>
<p><img src="https://helei112g.github.io/images/trade-api.png" alt="image"></p>
<p>在商户中心，看到 <strong>即时到帐（已添加）</strong>，说明你已签约该接口，可正常使用。如果还不知道如何签约，请 <a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.FkBnFB&amp;treeId=62&amp;articleId=104749&amp;docType=1" target="_blank" rel="external">查看支付宝即时到帐签约教程</a></p>
<p>OK！完成签约后，</p>
<p>需要把 <a href="https://github.com/helei112g/payment/tree/paymentv2" target="_blank" rel="external">payment项目导入自己的项目中</a> 安装方法，请参考<a href="http://note.youdao.com/yws/public/redirect/share?id=5f8373d4cdfeb06dbcbe21b942efc53e&amp;type=false" target="_blank" rel="external">Payment项目简介</a>。</p>
<h1 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h1><p>在项目的 <code>examples</code> 文件夹中，我已提供完整的示例。为了便于大家理解，这里对代码再进行说明。</p>
<h2 id="支付宝的配置文件"><a href="#支付宝的配置文件" class="headerlink" title="支付宝的配置文件"></a>支付宝的配置文件</h2><p>在1.x版本中，配置文件被固定写在了sdk中，这种做法太流氓了。为了不继续流氓下去，在2.x版本中，将配置信息独立出来，让大家可以根据自己的实际情况自定义，灵活程度大大增加。</p>
<p>调用时，仅需要提供给我如下的一个数组，至于配置信息写在哪里，完全由你自己决定。</p>
<p>我在示例中，是将配置信息写在 <code>examples/aliconfig.php</code> 中，然后使用 <code>require_once</code> 包含进来。你完全可以写cache中、db中。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; <span class="string">'./rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>参数介绍</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>partner</td>
<td>合作者身份ID</td>
<td>签约的支付宝账号对应的支付宝唯一用户号。以2088开头的16位纯数字组成。</td>
<td>必须</td>
</tr>
<tr>
<td>md5_key</td>
<td>MD5密钥</td>
<td><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.qt91b7&amp;treeId=62&amp;articleId=104740&amp;docType=1#s1" target="_blank" rel="external">点击这里</a></td>
<td>必须</td>
</tr>
<tr>
<td>rsa_private_key</td>
<td>RSA私钥</td>
<td><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.qt91b7&amp;treeId=62&amp;articleId=104740&amp;docType=1#s0" target="_blank" rel="external">点击这里</a></td>
<td>必须</td>
</tr>
<tr>
<td>notify_url</td>
<td>服务器异步通知URI</td>
<td>支付宝服务器主动通知商户网站里指定的页面http路径。(建议使用https)</td>
<td>可选</td>
</tr>
<tr>
<td>return_url</td>
<td>页面跳转同步通知页面路径</td>
<td>支付宝处理完请求后，当前页面自动跳转到商户网站里指定页面的http路径。</td>
<td>可选</td>
</tr>
<tr>
<td>time_expire</td>
<td>超时时间</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。单位默认为分钟</td>
<td>可选</td>
</tr>
</tbody>
</table>
<p><strong>特别说明：</strong></p>
<ul>
<li>如果上述配置文件必须的key的值为空，会抛出 <code>PayException</code> 异常</li>
<li>如果 <code>notify_url</code> 为空，虽然可支付成功，但是客户端将无法收到支付宝的回调结果。</li>
<li>建议采用https协议</li>
</ul>
<h2 id="调用支付"><a href="#调用支付" class="headerlink" title="调用支付"></a>调用支付</h2><p>项目中的示例代码，参见 <code>examples/charge.php</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  生成订单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time())</span><br><span class="line">            .substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">            .rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单信息</span></span><br><span class="line">$orderData = [</span><br><span class="line">    <span class="string">"orderTradeNo"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"totalFee"</span>	=&gt; <span class="string">'1'</span>,</span><br><span class="line">    <span class="string">"clientIp"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'我是即时到帐'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付测试即时到帐接口'</span>,</span><br><span class="line">    <span class="string">"extraCommonParam"</span>	=&gt; <span class="string">''</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$aliconfig = <span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">'/aliconfig.php'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化支付环境类，进行支付创建</span></span><br><span class="line">$charge = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $charge-&gt;initCharge(Config::ALI_CHANNEL_WEB, $aliconfig);</span><br><span class="line">    $url = $charge-&gt;charge($payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求alipay</span></span><br><span class="line">header(<span class="string">"Location:&#123;$url&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码就完成了即时到帐的全部调用，下面分步骤来说明下代码含义：</p>
<h3 id="订单信息"><a href="#订单信息" class="headerlink" title="订单信息"></a>订单信息</h3><p>此部分的key部分，必须采用以下值，否则SDK无法识别。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createPayid(); 函数是为了演示方便，随手写的一个生成订单号的函数</span></span><br><span class="line"></span><br><span class="line">$orderData = [</span><br><span class="line">    <span class="string">"order_no"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"amount"</span>	=&gt; <span class="string">'1'</span>,<span class="comment">// 单位为元</span></span><br><span class="line">    <span class="string">"client_ip"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'测试支付'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付接口测试'</span>,</span><br><span class="line">    <span class="string">"extra_param"</span>	=&gt; <span class="string">''</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>order_no</td>
<td>订单号</td>
<td>平台根据规则生成的订单号，最长64位，要在商户数据库中唯一</td>
<td>必须</td>
</tr>
<tr>
<td>amount</td>
<td>交易总金额</td>
<td>该笔订单的资金总额，单位为RMB-Yuan。取值范围为[0.01，100000000.00]，精确到小数点后两位。</td>
<td>必须</td>
</tr>
<tr>
<td>client_ip</td>
<td>客户端IP</td>
<td>用户在创建交易时，该用户当前所使用机器的IP。</td>
<td>必须</td>
</tr>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>商品的标题/交易标题/订单标题/订单关键字等。该参数最长为128个汉字。</td>
<td>必须</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>对一笔交易的具体描述信息。如果是多种商品，请将商品描述字符串累加传给body。</td>
<td>必须</td>
</tr>
<tr>
<td>extra_param</td>
<td>公用回传参数</td>
<td>如果用户请求时传递了该参数，则返回给商户时会回传该参数。</td>
<td>可选</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="签名数据"><a href="#签名数据" class="headerlink" title="签名数据"></a>签名数据</h3><p>以下是真正实现数据签名的地方，返回的数据可直接用于发起支付宝支付。大家可以对比下支付宝自身信息，是不是已经大大简化了？<br>当然简化带来的另外一个意思就是：放弃了很多我们正常情况下用不到的功能，比如：花呗分期</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化支付环境类，进行支付创建</span></span><br><span class="line">$charge = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $charge-&gt;initCharge(Config::ALI_CHANNEL_WEB, $aliconfig);</span><br><span class="line">    $url = $charge-&gt;charge($payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对于调用者，仅仅需要知道 <code>ChargeContext</code> 这一个类，这里使用了 <strong>策略模式 + 简单工厂模式</strong> 两种方法来进行调用的简化。这种方式也非常方便后期进行扩展，对于客户端与复杂的逻辑进行了隔离。</p>
<h3 id="跳转支付宝"><a href="#跳转支付宝" class="headerlink" title="跳转支付宝"></a>跳转支付宝</h3><p>通过上一步返回的是请求支付宝的url。由于在页面上可能需要通过js调用支付宝或者还有其他逻辑，因为我并没有直接重定向到支付宝，而把控制权交到了客户端手中。</p>
<p>以下代码，示例的是简单的利用返回的url，重定向到支付宝，完成支付。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"Location:&#123;$url&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>本次支付宝的即时到帐接口到这里就完成了调用。下一节把回调通知部分完成，这样一个基本的支付流程就完成了。</p>
<h1 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h1><blockquote>
<p>如果需要协助集成到项目，可付费获得我的服务！</p>
</blockquote>
<ul>
<li><p>邮箱: <strong>dayugog@gmail.com</strong></p>
</li>
<li><p>对我有用，我要打赏：</p>
</li>
</ul>
<p><img src="https://helei112g.github.io/images/ali-qr.png" alt="image"></p>
<blockquote>
<p><a href="https://helei112g.github.io/categories/payment/">项目文档首页</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[支付宝、微信支付接入集成]]></title>
      <url>https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%E3%80%81%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E9%9B%86%E6%88%90/</url>
      <content type="html"><![CDATA[<p>没有摘要，请看正文<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>从开始写代码以来，一直就与支付打交道。终于到今天，我忍无可忍啦！每次都要重新写，重新调（主要换工作后，不能把前东家的代码给拷贝走）。好吧，写一份放到github上，以后啥时候用都有了，还方便做外包（哈哈哈……）</p>
<p>之前看了 ping++ 集成的各路支付接口，觉得挺爽的，但是要收费，而且公司也不放心，怕什么时候 ping++ 坚持不住了，那到时候怎么办？我倒是觉得可能大部分公司坚持不住了，ping++ 还在呢！ 因此不自量力的自己也来集成一个吧！</p>
<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p><strong>说明：</strong></p>
<ul>
<li>PHP 5.5 以上版本，包含5.5</li>
<li>采用PSR-4标准编码，可通过composer实现自动加载。</li>
<li>如果项目无法使用composer，请通过包含项目中的 <code>autoload.php</code> 来实现自动加载</li>
<li>客户端传入的参数均使用 <strong>下划线风格</strong></li>
</ul>
<h2 id="composer安装Payment"><a href="#composer安装Payment" class="headerlink" title="composer安装Payment"></a>composer安装Payment</h2><p>如果你励志要做php，强烈建议你学习下composer。</p>
<p><em>composer学习地址： <a href="http://www.phpcomposer.com/" target="_blank" rel="external">http://www.phpcomposer.com/</a></em></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装时请自行指定版本。否则将安装稳定版，当前稳定版是1.x</span></span><br><span class="line">composer <span class="keyword">require</span> riverslei/payment</span><br></pre></td></tr></table></figure>
<p>通过composer安装后，无需任何操作，可在项目中直接使用。</p>
<h2 id="直接下载"><a href="#直接下载" class="headerlink" title="直接下载"></a>直接下载</h2><p>当然如果由于历史原因（如果没有历史原因，强烈推荐composer安装，方便后续更新），无法通过composer安装，那么请自行下载（下载地址见下方 功能介绍），并在使用时，包含 <code>autoload.php</code> 文件。这种方式就不过多介绍了。</p>
<h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>说这么多废话没什么卵用，还是先介绍下本SDK支持的支付接口</p>
<ol>
<li>支付宝支付<ul>
<li><a href="https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%EF%BC%9A%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/">支付宝即时到帐</a></li>
<li><a href="https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/">支付宝异步通知回调</a></li>
<li><a href="https://helei112g.github.io/2016/07/29/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E3%80%81%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/">支付宝手机网站</a></li>
<li><a href="https://helei112g.github.io/2016/07/29/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E3%80%81%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/">支付宝移动支付</a></li>
<li><a href="https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/">支付宝有密退款</a></li>
<li><a href="https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E6%89%B9%E9%87%8F%E8%BD%AC%E6%AC%BE%E6%8E%A5%E5%8F%A3/">支付宝有密批量付款</a></li>
<li><a href="https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E5%8D%95%E7%AC%94%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3/">支付宝订单查询</a></li>
</ul>
</li>
</ol>
<ol>
<li>微信支付    <ul>
<li><a href="https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%94%AF%E4%BB%98%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%85%A5%EF%BC%9AAPP%E6%94%AF%E4%BB%98%E3%80%81%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%E3%80%81%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/">微信公众号支付\微信扫码支付\APP支付 接口</a></li>
<li><a href="https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E8%AE%A2%E5%8D%95%E3%80%81%E9%80%80%E6%AC%BE%E8%AE%A2%E5%8D%95%E3%80%81%E8%BD%AC%E6%AC%BE%E8%AE%A2%E5%8D%95%E7%9A%84%E6%9F%A5%E8%AF%A2/">订单查询接口/退款订单查询接口/企业付款查询接口</a></li>
<li><a href="https://helei112g.github.io/2016/08/16/PHP%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/">微信退款接口</a></li>
<li><a href="https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/">微信异步通知回调接口</a></li>
<li><a href="https://helei112g.github.io/2016/08/16/PHP%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E4%BB%98%E6%AC%BE%E5%8A%9F%E8%83%BD/">企业付款接口</a></li>
</ul>
</li>
</ol>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 2.x版本</a></p>
<p>当然有很多朋友问我支不支持paypal 银联等等。我也想呀，可惜这个得慢慢来。我这基础功能还搞完呢！哈哈，当然也欢迎大家push代码给我</p>
<h1 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h1><p>本来我想有完整的示例代码，大家应该在使用中不会遇到什么问题，但是还有有朋友遇到诸多问题。那么有关于项目本身的bug或建议，大家可以通过以下方式联系我：</p>
<ul>
<li>邮箱: <strong>dayugog@gmail.com</strong></li>
<li>微信：<strong>helei543345</strong></li>
</ul>
<blockquote>
<p>此外如果需要协助集成到项目，可付费获得我的服务！</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[1.APP后端开发系列：登陆系统设计中的注意问题]]></title>
      <url>https://helei112g.github.io/2016/07/12/1-APP%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%9A%E7%99%BB%E9%99%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>自从接触到app开发以来，遇到很多问题，一直都是一路走，一路解决。希望这些文字能够让大家少走些弯路。<br><a id="more"></a></p>
<p>想写这个系列很久了，因为之前做这个东西花费了大量的精力，有必要分享出来与大家共享。以前也写了一些关于 <a href="http://blog.csdn.net/hel12he/article/details/47721209" target="_blank" rel="external">APP后端开发的系列文章</a> 由于当初功力不够，很多问题描述不清楚或者解决方案过于复杂、不严谨等。</p>
<p>这一次查了很多资料，问了很多相关人士。准备再结合自己实际工作中的问题再次进行一些补充。就先从登陆的设计开始吧！</p>
<h1 id="越想越糊涂"><a href="#越想越糊涂" class="headerlink" title="越想越糊涂"></a>越想越糊涂</h1><p>之前再做这一部分的时候，总想着复杂的技术，说出去多调炸天呀。一般来说登陆的流程是：</p>
<p><img src="https://helei112g.github.io/images/login-flow.png" alt="image"></p>
<p>当时对于安全性过度痴迷，确走偏了道路。首先提交的时候爬信息被人劫持，因此客户端在上传时，进行AES加密，服务端解密出结果。服务端返回的信息也会AES加密，然后客户端解密。</p>
<p>然后这里又带来另外一个问题：加密信息放在了客户端，那么一但客户端被反编译，hacker拿到秘钥，那么对于服务端来说加密就没有任何意义了。又为了不在客户端保存这么敏感的信息，就像秘钥由服务端下发。这样子服务端可随时对秘钥进行变更。</p>
<p>到这里又带来了一个新的问题，感脚一切又回到了起点：下发秘钥要走http，那么依然可能被人劫持。这时候该是加密还是怎么弄呢？如果加密，客户端又放了一个秘钥过去。那这个秘钥依然可能被人反编译。不能再从服务端获取这个秘钥吧？为了确保上个秘钥的安全，生产下一个秘钥……</p>
<p>当时就是陷入了这样的死循环，不可自拔。现在想想真是too young too simple!</p>
<h1 id="简单、有效"><a href="#简单、有效" class="headerlink" title="简单、有效"></a>简单、有效</h1><p>首先在这里还是先说一下：如果你的产品刚刚起步，不要过于纠结性能、安全</p>
<p>先说性能：你的产品才推出的时候，冷启动的用户数一般来说不会超过1000人（这已经是很不得了的冷启动人数了）。然后你的并发也不会超过100。这种级别的访问，相信机器硬件就可以帮助你解决。如果你的条件远远超出以上规模，那么你的实力绝对足以应付即将发生的事情。<br>谈谈安全：安全这个事情，从一开始就要考虑，但是不能过于纠结（我之后可以讲讲我在做短信验证码这一部分的遇到的一个经理）。过早介入，会导致系统开发速度降低，过早做了一些不需要的事情（hacker来搞你也是需要成本的，在你没价值的时候，没人愿意来搞你）。所以早期应该重视开发成本，抓紧时间，早日上线。</p>
<p>另外，安全与性能有时候也是鱼与熊掌。</p>
<h1 id="演化之路"><a href="#演化之路" class="headerlink" title="演化之路"></a>演化之路</h1><p>这一部分会有一些代码与图来进行说明。在安全方面逐步演进。前面说前期开发只要快就好，但是这里也要注意一个问题，就是后续升级能够弥补前面的错，要给未来升级留下余地。因为否则你的系统始终留下了一个隐患。</p>
<h2 id="实现功能就好"><a href="#实现功能就好" class="headerlink" title="实现功能就好"></a>实现功能就好</h2><p>这是最开始的阶段，重点考虑功能实现。用户提交username + pwd 服务端验证通过后，返回一个令牌token。</p>
<p>这里需要注意的几个部分是要为未来的升级做好准备。我经常遇到的几个初期设计是：</p>
<blockquote>
<ol>
<li>验证通过后，把用户uid+username+salt等md5后，作为token返回到客户端。</li>
<li>对token加入时间戳，过期后客户端重新提交username + pwd验证后再发一个token到客户端</li>
<li>服务端生成一个token后下发到客户端，客户端按照约定的规则加密后请求服务端。</li>
</ol>
</blockquote>
<p>先说第一种带来的问题：生成的token永久不变，那么别人获取到一个token就可以无限制的进行请求。直到你关闭了这个接口为止。为后续安全设计增加了成本。</p>
<p>第二种问题就有点老火了，虽然看似token只在一定时间范围内有效了，但是其实更不安全了。首先客户端需要保存用户的用户名与密码，如果用户手机平时不注重安全，很容易被人窃取。</p>
<p>第三种设计方案，这是我原先干过的一件事，是这三种方案中最垃圾的设计。得出的教训就是：绝不能把任何加密的事情交给客户端。这样子灵活性大打折扣。举例：还是升级接口了，现在本来token生成只是服务端的事情，服务端随时可动态改变规则，现在由于客户端也参与进来了，这事儿就麻烦了，你一改，客户端也要跟着改。没有任何灵活性可言。切记：客户端就接收，然后转发回服务端就好了。别再客户端进行加密！！！</p>
<p>经过这些坑的历练，参考oauth2.0，我现在采用以下方案：</p>
<p>用户提交username + pwd后，服务端返回以下信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">    <span class="attr">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>access_token</strong> 是用来进行访问的接口的，<strong>expires_in</strong> 是他的过期时间，到达过期时间后，需要用 <strong>refresh_token</strong>  来请求服务端刷新 <strong>access_token</strong>。</p>
<p>这里几个重点是：<strong>refresh_token</strong> 仅能使用一次，使用一次后，将被废弃。另外这个 <strong>access_token</strong> 只在 <strong>expires_in</strong> 有效期内有效。</p>
<p><strong>注意：</strong> 这里的 expires_in 仅返回秒数就好了。别返回时间戳。因为各个平台计算s的时间戳，不一致，这样子做更方便处理。</p>
<h2 id="访问频率控制"><a href="#访问频率控制" class="headerlink" title="访问频率控制"></a>访问频率控制</h2><p>上面我们简单实现了功能，现在app的流量上来了，有些功能也很复杂，如果某个接口访问量太大，会导致服务器崩溃，需要分别对每个接口每次访问设置频率（也可以统一设置每个接口访问的频率）。</p>
<p>一般我的做法是加入一个中间件。每一个接口的访问频率做好一个对应的配置文件。比如：</p>
<ul>
<li>a接口 5s内可访问1次</li>
<li>b接口 10s内可访问1次（可能非常耗时，如果同时过多请求会导致服务器崩溃）</li>
</ul>
<p>那么就把 <strong>access_token</strong> 与这些关联起来。这里需要用到redis。当用户A进来访问了 a接口 那么设置这个token 5s内不能再次访问。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($redis-&gt;get($key)) &#123;</span><br><span class="line">    <span class="comment">// 无法访问，还未到时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置频率控制key</span></span><br><span class="line">$redis-&gt;setex($key, $expires, $value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问接口</span></span><br></pre></td></tr></table></figure>
<p>这里需要考虑几个问题：</p>
<p>设置的访问时间要合理。举例：客户端一般启动的时候会请求多个接口，那么当这些请求到达后，服务端可能拒绝其中一部分访问（因为在频率控制内）</p>
<p>一般来说不需要对所有的接口都进行频率控制，仅仅针对重要的内容以及性能上有要求的接口进行频率控制。</p>
<h2 id="账号安全考虑"><a href="#账号安全考虑" class="headerlink" title="账号安全考虑"></a>账号安全考虑</h2><p>现在又进一步了，需要考虑用户账号安全的问题。比如：QQ，有时候会提醒我们你的账号在香港登陆了。如果不是自己所为，赶快修改密码之类的。</p>
<p>实现这个功能，你需要记录每次登陆、启动时每个token对应的ip地址。如果ip地址与上次的ip不在同一个范围（这个规则由自己定，因为有的运营商ip经常变化，比如：长城）。就提醒用户是不是他自己所为，如果不是，就赶快修改密码。</p>
<p>现在很多app在开发之初，都是可以多个设备同时登陆。这样带来的安全问题也很多。如果要做成单个设备登陆，需要每个token对应一个deviceToken。</p>
<p>这一部分就不继续深入讨论下去了。</p>
<h2 id="防DNS劫持"><a href="#防DNS劫持" class="headerlink" title="防DNS劫持"></a>防DNS劫持</h2><p>安全工作做得再好，如果有人能够获得大量合法用户的token，来请求你的借口，你也无法识别，因为从行为来看，这一切都是合法用户再进行。</p>
<p>以前为了防止别人获取到合法的信息，我才弄出了很狗血的客户端加密方法。导致后期升级的时候，诸多问题。这个东西其实很简单，使用https来进行请求（可以个人关键接口使用）</p>
<h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><p>才开始做app服务端的时候，总想着token的设计。怎么才能生成一个好的token呢？现在想想真不知道当初怎么想的。</p>
<h2 id="token的生成"><a href="#token的生成" class="headerlink" title="token的生成"></a>token的生成</h2><p>首先搞明白这个token的作用就是一个令牌，用来标记一个用户的身份。那么首先他要唯一。其次他从客户端上传后，服务端能够验证这个token是由服务端生成的。</p>
<p>所以token生成只要满足以上目的，你随意就好了。当然别把敏感信息暴露出去了。</p>
<p>常用的一种生成方式：</p>
<ol>
<li>该用户的uid，如：8888</li>
<li>该用户的口令，如： 123123</li>
<li>用户对应的salt，如：abcd</li>
<li>过期时间戳，如：1468293948</li>
</ol>
<p>把上面几部分拼接起来：888:123123:abcd:1468293948</p>
<p>token = md5(‘888:123123:abcd:1468293948’);</p>
<h2 id="token的验证"><a href="#token的验证" class="headerlink" title="token的验证"></a>token的验证</h2><p>对于token也有两种方法进行验证。一是：服务端生成后，将token保存起来（redis或者mysql中）。客户端穿上来之后，检查是否有该token，如果有取出对应的信息，比如uid，验证是否匹配。</p>
<p>另一种方法是：根据上传的uid，生成对应的token，然后进行比较token结果是否一致（要保障该算法如果给定的值一定，结果必须唯一。常用md5）。</p>
<p>对于个人而言更倾向于第二种方案。第一种方案效率更高（可使用redis存储这个token），但是如果redis一但雪崩，就会造成所有用户登录失效，一定时间内不可登陆。初期越简单、越可靠更好。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一部分没有太多代码，主要是思路。还有涉及到H5的登陆问题也没有说到。下篇文章会把APP中登陆后，如果搞定H5登陆的问题进行阐述。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[php设计模式：状态模式的使用场景]]></title>
      <url>https://helei112g.github.io/2016/06/28/php%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<p>最初为了减少代码中的逻辑判断，使用了该模式，不过大家在实际中还是需要权衡，太多的类未必就比if{…}else{…}更好。</p>
<a id="more"></a>
<p>在这儿给大家说点事儿。我的博客搬家到github主页上了。<a href="https://helei112g.github.io">我的博客</a>。以后首发都在github上了。csdn也会继续更新。可能就是稍微慢一下。</p>
<p>另外最近搞了一个支付的开源项目。<a href="https://github.com/helei112g/payment" target="_blank" rel="external">这是项目地址</a>  目前已经支持：</p>
<ul>
<li>支付宝的 即时到帐、移动支付、加密退款接口。</li>
<li>微信的目前已经支持：app支付、扫码支付、H5支付</li>
</ul>
<p>项目还存在些bug，正在不断结合公司业务进行修改。后期可能会支持的越来越全面。</p>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>废话不多说了，回到本文主题： 状态模式</p>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
</blockquote>
<p>说实话，这定义真JB不是怎么读的懂。不过咱要试着去理解其中的精髓。谁让咱们有颗向上的心呢？</p>
<p>一句句来。</p>
<p>先说这一句： <strong>允许一个对象在其内部状态改变时改变它的行为</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($state)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;state = $state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">change</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;state == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'我是好人'</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="keyword">$this</span>-&gt;state == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'我要当坏人'</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 其他状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'爱好和平!'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下我要开始自己的理解了，这个理解不一定是上面定义的本意，但是绝对讲人话，有帮助，可实战。</p>
<p>如果 <code>state</code> 传入的值不同，则会得到不同的行为。那么这就是我理解的这一句话的意思。再说白话一点，根据不同的条件，执行不同的逻辑。</p>
<p><strong>对象看起来似乎修改了它的类</strong>  这一句更扯淡，真不知道这些人怎么想的，就不能说的通俗些？我觉得嘛，这个概念能懂就懂，不懂呢，你就这么办：那就是对于每一个条件中的逻辑，移入到不同的类中，这些类要实现一个统一的接口。还不懂？上代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface State()</span><br><span class="line">&#123;</span><br><span class="line">    // 注意这里的Context 我在后面会讲到。不等同于上面的 Context 类哦</span><br><span class="line">    public function handle(Context $context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 状态A</span><br><span class="line">class StateA implements State</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($context-&gt;term = 1) &#123;</span><br><span class="line">            // 处理逻辑，并终止程序</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $context.setState(new StateB());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 状态B</span><br><span class="line">class StateB implements State</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($context-&gt;term = 2) &#123;</span><br><span class="line">            // 处理逻辑，并终止程序</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $context.setState(new StateC());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 状态C</span><br><span class="line">class StateC implements State</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果还有其他状态，则继续往下走。如果没有，就在次终止程序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 新的Context类的实现</span><br><span class="line">class Context</span><br><span class="line">&#123;</span><br><span class="line">    private $state;// 用来保存 State 对象</span><br><span class="line">    </span><br><span class="line">    public function setState(State $state)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;state = $state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function request()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;state-&gt;handle($this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码基本上就已经演示了 <strong>状态模式</strong> 。有看官急了，写的什么狗屎？怎么用，哪儿可以用？别急，等我把这个逼装完。</p>
<h2 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h2><p>继续装逼，上类图。</p>
<p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/State.jpg" alt="类图"></p>
<p>从这个图中可以看出，纯种的状态模式，包括了以下三个角色：</p>
<ul>
<li>Context: 环境类。它呢需要在代码中传给具体的 State 类，这样State类才能改变它。记得这句 <strong>对象看起来似乎修改了它的类</strong> 吗？就着这句话再去理解下这个类。他保存有当前的状态。</li>
<li>State: 抽象的状态接口 。让具体的状态都要实现这个接口，Context依赖接口进行编程。</li>
<li>ConcreteState： 具体的状态类。专门用于处理某一个状态，如果处理不了就转发出去。</li>
</ul>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>上面讲那么多，不能真刀真枪的用到项目中，都是耍流氓。在我们的项目中其实有特别多的地方可以用到状态模式。</p>
<ul>
<li>如果项目中存在太多的 <code>if {...} elseif {...} else {...}</code> 。那么你应该考虑状态模式。<em>我觉得这个是重点考虑对象</em></li>
<li>如果每个状态中处理的业务逻辑特别复杂·那么建议考虑这种方式。</li>
<li>最后一点，如果代码中的状态相对固定。比如一个电商中购买商品的流程：未支付、已过期、待发货（已支付）、已发货、已收货。那么这种状态基本上定下来不会有太大变化，状态发生在内部中，顺序固定，不需要客户端进行处理。</li>
</ul>
<p>以上三种情况是我建议的方式。如果大家还有总结的经验，欢迎分享。</p>
<p>这里有个问题，待我写完 <strong>职责链模式</strong> 之后再来分享。因为这二者有相当多的共同之处。大家一定认真阅读我写的 <strong>使用场景</strong> 的最后一点。</p>
]]></content>
    </entry>
    
  
  
</search>
