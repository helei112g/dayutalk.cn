<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Golang技巧之默认值设置的高阶玩法]]></title>
      <url>http://dayutalk.cn/2020/06/22/Golang%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
      <content type="html"><![CDATA[<p>从别人的代码中吸取养分！让自己成长<br><a id="more"></a></p>
<p>最近使用 <code>GRPC</code> 发现一个设计特别好的地方，非常值得借鉴。</p>
<p>我们在日常写方法的时候，希望给某个字段设置一个默认值，不需要定制化的场景就不传这个参数，但是 <code>Golang</code> 却没有提供像 <code>PHP</code>、<code>Python</code> 这种动态语言设置方法参数默认值的能力。</p>
<h1 id="低阶玩家应对默认值问题"><a href="#低阶玩家应对默认值问题" class="headerlink" title="低阶玩家应对默认值问题"></a>低阶玩家应对默认值问题</h1><p>以一个购物车举例。比如我有下面这样一个购物车的结构体，其中 <code>CartExts</code> 是扩展属性，它有自己的默认值，使用者希望如果不改变默认值时就不传该参数。但是由于 <code>Golang</code> 无法在参数中设置默认值，只有以下几个选择：</p>
<ol>
<li>提供一个初始化函数，所有的 <code>ext</code> 字段都做为参数，如果不需要的时候传该类型的零值，这把复杂度暴露给调用者；</li>
<li>将 <code>ext</code> 这个结构体做为一个参数在初始化函数中，与 <code>1</code> 一样，复杂度在于调用者;</li>
<li>提供多个初始化函数，针对每个场景都进行内部默认值设置。</li>
</ol>
<p>下面看下代码具体会怎么做</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	CommonCart = <span class="string">"common"</span></span><br><span class="line">	BuyNowCart = <span class="string">"buyNow"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CartExts <span class="keyword">struct</span> &#123;</span><br><span class="line">	CartType <span class="keyword">string</span></span><br><span class="line">	TTL      time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DemoCart <span class="keyword">struct</span> &#123;</span><br><span class="line">	UserID <span class="keyword">string</span></span><br><span class="line">	ItemID <span class="keyword">string</span></span><br><span class="line">	Sku    <span class="keyword">int64</span></span><br><span class="line">	Ext    CartExts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultExt = CartExts&#123;</span><br><span class="line">	CartType: CommonCart,       <span class="comment">// 默认是普通购物车类型</span></span><br><span class="line">	TTL:      time.Minute * <span class="number">60</span>, <span class="comment">// 默认 60min 过期</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式一：每个扩展数据都做为参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCart</span><span class="params">(userID <span class="keyword">string</span>, Sku <span class="keyword">int64</span>, TTL time.Duration, cartType <span class="keyword">string</span>)</span> *<span class="title">DemoCart</span></span> &#123;</span><br><span class="line">	ext := DefaultExt</span><br><span class="line">	<span class="keyword">if</span> TTL &gt; <span class="number">0</span> &#123;</span><br><span class="line">		ext.TTL = TTL</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> cartType == BuyNowCart &#123;</span><br><span class="line">		ext.CartType = cartType</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;DemoCart&#123;</span><br><span class="line">		UserID: userID,</span><br><span class="line">		Sku:    Sku,</span><br><span class="line">		Ext:    ext,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：多个场景的独立初始化函数；方式二会依赖一个基础的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCartScenes01</span><span class="params">(userID <span class="keyword">string</span>, Sku <span class="keyword">int64</span>, cartType <span class="keyword">string</span>)</span> *<span class="title">DemoCart</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewCart(userID, Sku, time.Minute*<span class="number">60</span>, cartType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCartScenes02</span><span class="params">(userID <span class="keyword">string</span>, Sku <span class="keyword">int64</span>, TTL time.Duration)</span> *<span class="title">DemoCart</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewCart(userID, Sku, TTL, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码看起来没什么问题，但是我们设计代码最重要的考虑就是稳定与变化，我们需要做到 <strong>对扩展开放，对修改关闭</strong> 以及代码的 <strong>高内聚</strong>。那么如果是上面的代码，你在 <code>CartExts</code> 增加了一个字段或者减少了一个字段。是不是每个地方都需要进行修改呢？又或者 <code>CartExts</code> 如果有非常多的字段，这个不同场景的构造函数是不是得写非常多个？所以简要概述一下上面的办法存在的问题。</p>
<ol>
<li>不方便对 <code>CartExts</code> 字段进行扩展；</li>
<li>如果 <code>CartExts</code> 字段非常多，构造函数参数很长，难看、难维护；</li>
<li>所有的字段构造逻辑冗余在 <code>NewCart</code> 中，面条代码不优雅；</li>
<li>如果采用 <code>CartExts</code> 做为参数的方式，那么就将过多的细节暴露给了调用者。</li>
</ol>
<p>接下来我们来看看 <code>GRPC</code> 是怎么做的，学习优秀的范例，提升自我的代码能力。</p>
<blockquote>
<p>从这你也可以体会到代码功底牛逼的人，代码就是写的美！</p>
</blockquote>
<h1 id="GRPC-之高阶玩家设置默认值"><a href="#GRPC-之高阶玩家设置默认值" class="headerlink" title="GRPC 之高阶玩家设置默认值"></a>GRPC 之高阶玩家设置默认值</h1><blockquote>
<p>源码来自：grpc@v1.28.1 版本。为了突出主要目标，对代码进行了必要的删减。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dialOptions 详细定义在 google.golang.org/grpc/dialoptions.go</span></span><br><span class="line"><span class="keyword">type</span> dialOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">	insecure    <span class="keyword">bool</span></span><br><span class="line">    timeout     time.Duration</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientConn 详细定义在 google.golang.org/grpc/clientconn.go</span></span><br><span class="line"><span class="keyword">type</span> ClientConn <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">	authority    <span class="keyword">string</span></span><br><span class="line">	dopts        dialOptions <span class="comment">// 这是我们关注的重点，所有可选项字段都在这里</span></span><br><span class="line">    csMgr        *connectivityStateManager</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 grpc 链接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</span><br><span class="line">	cc := &amp;ClientConn&#123;</span><br><span class="line">		target:            target,</span><br><span class="line">		csMgr:             &amp;connectivityStateManager&#123;&#125;,</span><br><span class="line">		conns:             <span class="built_in">make</span>(<span class="keyword">map</span>[*addrConn]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		dopts:             defaultDialOptions(), <span class="comment">// 默认值选项</span></span><br><span class="line">		blockingpicker:    newPickerWrapper(),</span><br><span class="line">		czData:            <span class="built_in">new</span>(channelzData),</span><br><span class="line">		firstResolveEvent: grpcsync.NewEvent(),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改改选为用户的默认值</span></span><br><span class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">		opt.apply(&amp;cc.dopts)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的含义非常明确，可以认为 <code>DialContext</code> 函数是一个 grpc 链接的创建函数，它内部主要是构建 <code>ClientConn</code> 这个结构体，并做为返回值。<code>defaultDialOptions</code> 函数返回的是系统提供给 <strong>dopts</strong> 字段的默认值，如果用户想要自定义可选属性，可以通过可变参数 <strong>opts</strong> 来控制。</p>
<p>经过上面的改进，我们惊奇的发现，这个构造函数非常的优美，无论 <strong>dopts</strong> 字段如何增减，构造函数不需要改动；<code>defaultDialOptions</code> 也可以从一个公有字段变为一个私有字段，更加对内聚，对调用者友好。</p>
<p>那么这一切是怎么实现的？下面我们一起学习这个实现思路。</p>
<h2 id="DialOption-的封装"><a href="#DialOption-的封装" class="headerlink" title="DialOption 的封装"></a>DialOption 的封装</h2><p>首先，这里的第一个技术点是，<code>DialOption</code> 这个参数类型。我们通过可选参数方式优化了可选项字段修改时就要增加构造函数参数的尴尬，但是要做到这一点就需要确保可选字段的类型一致，实际工作中这是不可能的。所以又使出了程序界最高手段，一层实现不了，就加一层。</p>
<p>通过这个接口类型，实现了对各个不同字段类型的统一，让构造函数入参简化。来看一下这个接口。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DialOption <span class="keyword">interface</span> &#123;</span><br><span class="line">	apply(*dialOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口有一个方法，其参数是 <code>*dialOptions</code> 类型，我们通过上面 for 循环处的代码也可以看到，传入的是 <code>&amp;cc.dopts</code>。简单说就是把要修改的对象传入进来。<code>apply</code> 方法内部实现了具体的修改逻辑。</p>
<p>那么，这既然是一个接口，必然有具体的实现。来看一下实现。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空实现，什么也不做</span></span><br><span class="line"><span class="keyword">type</span> EmptyDialOption <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(EmptyDialOption)</span> <span class="title">apply</span><span class="params">(*dialOptions)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用到最多的地方，重点讲</span></span><br><span class="line"><span class="keyword">type</span> funcDialOption <span class="keyword">struct</span> &#123;</span><br><span class="line">	f <span class="function"><span class="keyword">func</span><span class="params">(*dialOptions)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">func</span> <span class="params">(fdo *funcDialOption)</span> <span class="title">apply</span><span class="params">(do *dialOptions)</span></span> &#123;</span><br><span class="line">	fdo.f(do)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFuncDialOption</span><span class="params">(f <span class="keyword">func</span>(*dialOptions)</span>) *<span class="title">funcDialOption</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;funcDialOption&#123;</span><br><span class="line">		f: f,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重点说 <code>funcDialOption</code> 这个实现。这算是一个高级用法，体现了在 Golang 里边函数是 <strong>一等公民</strong>。它有一个构造函数，以及实现了 <code>DialOption</code> 接口。</p>
<p><code>newFuncDialOption</code> 构造函数接收一个函数做为唯一参数，然后把传入的函数保存到 <code>funcDialOption</code> 的字段 <code>f</code> 上。再来看看这个参数函数的参数类型是 <code>*dialOptions</code> ，与 <code>apply</code> 方法的参数是一致的，这是设计的第二个重点。</p>
<p>现在该看 <code>apply</code> 方法的实现了。它非常简单，其实就是调用构造 <code>funcDialOption</code> 时传入的方法。可以理解为相当于做了一个代理。把 <code>apply</code> 要修改的对象丢到 <code>f</code> 这个方法中。所以重要的逻辑都是我们传入到 <code>newFuncDialOption</code> 这个函数的参数方法实现的。</p>
<p>现在来看看 <strong>grpc</strong> 内部有哪些地方调用了 <code>newFuncDialOption</code> 这个构造方法。</p>
<h2 id="newFuncDialOption-的调用"><a href="#newFuncDialOption-的调用" class="headerlink" title="newFuncDialOption 的调用"></a>newFuncDialOption 的调用</h2><p>由于 <code>newFuncDialOption</code> 返回的 <code>*funcDialOption</code> 实现了 <code>DialOption</code> 接口，因此关注哪些地方调用了它，就可以顺藤摸瓜的找到我们最初 <code>grpc.DialContext</code> 构造函数 <strong>opts</strong> 可以传入的参数。</p>
<blockquote>
<p>调用了该方法的地方非常多，我们只关注文章中列出的两个字段对应的方法：<code>insecure</code> 与 <code>timeout</code>。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 以下方法详细定义在 google.golang.org/grpc/dialoptions.go</span></span><br><span class="line"><span class="comment">// 开启不安全传输</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithInsecure</span><span class="params">()</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> newFuncDialOption(<span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">		o.insecure = <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 timeout</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(d time.Duration)</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> newFuncDialOption(<span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">		o.timeout = d</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来体验一下这里的精妙设计：</p>
<ol>
<li>首先对于每一个字段，提供一个方法来设置其对应的值。由于每个方法返回的类型都是 <code>DialOption</code> ，从而确保了 <code>grpc.DialContext</code> 方法可用可选参数，因为类型都是一致的；</li>
<li>返回的真实类型是 <code>*funcDialOption</code> ，但是它实现了接口 <code>DialOption</code>，这增加了扩展性。</li>
</ol>
<h2 id="grpc-DialContext-的调用"><a href="#grpc-DialContext-的调用" class="headerlink" title="grpc.DialContext 的调用"></a>grpc.DialContext 的调用</h2><p>完成了上面的程序构建，现在我们来站在使用的角度，感受一下这无限的风情。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">opts := []grpc.DialOption&#123;</span><br><span class="line">    grpc.WithTimeout(<span class="number">1000</span>),</span><br><span class="line">    grpc.WithInsecure(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn, err := grpc.DialContext(context.Background(), target, opts...)</span><br><span class="line"><span class="comment">// ... ...</span></span><br></pre></td></tr></table></figure>
<p>当然这里要介绍的重点就是 <code>opts</code> 这个 slice ，它的元素就是实现了 <code>DialOption</code> 接口的对象。而上面的两个方法经过包装后都是 <code>*funcDialOption</code> 对象，它实现了 <code>DialOption</code> 接口，因此这些函数调用后的返回值就是这个 slice 的元素。</p>
<p>现在我们可以进入到 <code>grpc.DialContext</code> 这个方法内部，看到它内部是如何调用的。遍历 <strong>opts</strong>，然后依次调用 <code>apply</code> 方法完成设置。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改改选为用户的默认值</span></span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">    opt.apply(&amp;cc.dopts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过这样一层层的包装，虽然增加了不少代码量，但是明显能够感受到整个代码的美感、可扩展性都得到了改善。接下来看一下，我们自己的 demo 要如何来改善呢？</p>
<h1 id="改善-DEMO-代码"><a href="#改善-DEMO-代码" class="headerlink" title="改善 DEMO 代码"></a>改善 DEMO 代码</h1><p>首先我们需要对结构体进行改造，将 <code>CartExts</code> 变成 <code>cartExts</code>， 并且需要设计一个封装类型来包裹所有的扩展字段，并将这个封装类型做为构造函数的可选参数。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	CommonCart = <span class="string">"common"</span></span><br><span class="line">	BuyNowCart = <span class="string">"buyNow"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cartExts <span class="keyword">struct</span> &#123;</span><br><span class="line">	CartType <span class="keyword">string</span></span><br><span class="line">	TTL      time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CartExt <span class="keyword">interface</span> &#123;</span><br><span class="line">	apply(*cartExts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里新增了类型，标记这个函数。相关技巧后面介绍</span></span><br><span class="line"><span class="keyword">type</span> tempFunc <span class="function"><span class="keyword">func</span><span class="params">(*cartExts)</span></span><br><span class="line"></span><br><span class="line">// 实现 <span class="title">CartExt</span> 接口</span><br><span class="line"><span class="title">type</span> <span class="title">funcCartExt</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">	f tempFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fdo *funcCartExt)</span> <span class="title">apply</span><span class="params">(e *cartExts)</span></span> &#123;</span><br><span class="line">	fdo.f(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFuncCartExt</span><span class="params">(f tempFunc)</span> *<span class="title">funcCartExt</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;funcCartExt&#123;f: f&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DemoCart <span class="keyword">struct</span> &#123;</span><br><span class="line">	UserID <span class="keyword">string</span></span><br><span class="line">	ItemID <span class="keyword">string</span></span><br><span class="line">	Sku    <span class="keyword">int64</span></span><br><span class="line">	Ext    cartExts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultExt = cartExts&#123;</span><br><span class="line">	CartType: CommonCart,       <span class="comment">// 默认是普通购物车类型</span></span><br><span class="line">	TTL:      time.Minute * <span class="number">60</span>, <span class="comment">// 默认 60min 过期</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCart</span><span class="params">(userID <span class="keyword">string</span>, Sku <span class="keyword">int64</span>, exts ...CartExt)</span> *<span class="title">DemoCart</span></span> &#123;</span><br><span class="line">	c := &amp;DemoCart&#123;</span><br><span class="line">		UserID: userID,</span><br><span class="line">		Sku:    Sku,</span><br><span class="line">		Ext:    DefaultExt, <span class="comment">// 设置默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历进行设置</span></span><br><span class="line">	<span class="keyword">for</span> _, ext := <span class="keyword">range</span> exts &#123;</span><br><span class="line">		ext.apply(&amp;c.Ext)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过这一番折腾，我们的代码看起来是不是非常像 grpc 的代码了？还差最后一步，需要对 <code>cartExts</code> 的每个字段包装一个函数。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCartType</span><span class="params">(cartType <span class="keyword">string</span>)</span> <span class="title">CartExt</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> newFuncCartExt(<span class="function"><span class="keyword">func</span><span class="params">(exts *cartExts)</span></span> &#123;</span><br><span class="line">		exts.CartType = cartType</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTTL</span><span class="params">(d time.Duration)</span> <span class="title">CartExt</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> newFuncCartExt(<span class="function"><span class="keyword">func</span><span class="params">(exts *cartExts)</span></span> &#123;</span><br><span class="line">		exts.TTL = d</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于使用者来说，只需如下处理：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exts := []CartExt&#123;</span><br><span class="line">    WithCartType(CommonCart),</span><br><span class="line">    WithTTL(<span class="number">1000</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NewCart(<span class="string">"dayu"</span>, <span class="number">888</span>, exts...)</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>是不是非常简单？我们再一起来总结一下这里代码的构建技巧：</p>
<ol>
<li>把可选项收敛到一个统一的结构体中；并且将该字段私有化；</li>
<li>定义一个接口类型，这个接口提供一个方法，方法的参数应该是可选属性集合的结构体的指针类型，因为我们要修改其内部值，所以一定要指针类型；</li>
<li>定义一个函数类型，该函数应该跟接口类型中的方法保持一致的参数，都使用可选项收敛的这个结构体指针作为参数；（非常重要）</li>
<li>定义一个结构体，并实现 <code>2</code> 中的接口类型；（这一步并非必须，但这是一种良好的编程风格）</li>
<li>利用实现了接口的类型，封装可选字段对应的方法；命令建议用 <strong>With + 字段名</strong> 的方式。</li>
</ol>
<p>按照上面的五步大法，你就能够实现设置默认值的高阶玩法。</p>
<p>如果你喜欢这个类型的文章，欢迎留言点赞！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[走进Golang之Channel的工作原理]]></title>
      <url>http://dayutalk.cn/2020/05/18/%E8%B5%B0%E8%BF%9BGolang%E4%B9%8BChannel%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>上篇文章讲了 channel 的基本使用，并且讲了一些使用时需要注意的一些事项，本文介绍这其中背后的一些原理。<br><a id="more"></a></p>
<p>我们本文依然不过过多涉及源码，主要还是讲原理。源码留到最后单独讲！</p>
<p><strong>参考资料</strong></p>
<ul>
<li>[1] <a href="https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8" target="_blank" rel="external">Diving Deep Into The Golang Channels.</a></li>
<li>[2] <a href="https://speakerdeck.com/kavya719/understanding-channels" target="_blank" rel="external">Understanding Channels</a></li>
<li>[3] <a href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html" target="_blank" rel="external">The Nature Of Channels In Go</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[走进Golang之Channel的使用]]></title>
      <url>http://dayutalk.cn/2020/05/17/%E8%B5%B0%E8%BF%9BGolang%E4%B9%8BChannel%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>没错，这个系列又开张了，哈哈^_^<br><a id="more"></a></p>
<p>对于 Golang 语言应用层面的知识，先讲如何正确的使用，然后再讲它的实现。</p>
<h1 id="channel-是什么"><a href="#channel-是什么" class="headerlink" title="channel 是什么"></a>channel 是什么</h1><blockquote>
<p>Don’t communicate by sharing memory, share memory by communicating.</p>
</blockquote>
<p>相信写过 Go 的同学都知道这句名言，可以说 channel 就是后边这句话的具体实现。我们来看一下到底 channel 是什么？</p>
<p>channel 是一个类型安全的队列（循环队列），能够控制 groutine 在它上面读写消息的行为，比如：阻塞某个 groutine ，或者唤醒某个 groutine。</p>
<p>不同的 groutine 可以通过 channel 交换任意的资源，由于 channel 能够控制 groutine 的行为，所以 CSP 模型才能在 Golang 中顺利实现，它确保了不同 groutine 之间的数据同步机制。</p>
<p>上面的话是不是听起来非常的不舒服？</p>
<p>好吧，简单说人话就是，channel 是用来在 <strong>不同的</strong> 的 goroutine 中交换数据的。一定要注意这里 <strong>不同的</strong> 三个字。千万不要把 channel 拿来在不同函数（同一个 goroutine 中）间交换数据。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>知道了定义，我们来看具体如何使用。</p>
<p>如何定义一个 channel 类型呢？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 定义了一个 int 类型的 channel，没有初始化，是 nil</span></span><br><span class="line"></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 定义+初始化了一个无缓冲的 int 类型 channel</span></span><br><span class="line">ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 定义+初始化了一个有缓冲的 int 类型 channel</span></span><br></pre></td></tr></table></figure>
<p>上面的定义方法我们都是定义的双向通道，对应的还有单向通道，但是单向通道我们一般只是做为函数参数来进行一些限制，并不会在定义、初始化时就搞一个单向通道出来。因为你定义一个单向通道没有任何实际价值，通道的存在本来就是用来交换数据的，单向通道只能满足发或者收。</p>
<p>下面我们一起来看一下具体的使用，以及使用中注意的一些点。</p>
<h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><p>不管是有缓冲的通道还是无缓冲的通道都是用来交换数据的，既然是交换数据，无非就是写入、读取。我们先从发送开始。</p>
<h3 id="无缓冲-channel"><a href="#无缓冲-channel" class="headerlink" title="无缓冲 channel"></a>无缓冲 channel</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">//ch&lt;-5 // 位置一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    num := &lt;-ch</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch&lt;-5 // 位置二</span></span><br></pre></td></tr></table></figure>
<p>如果我们打开 <strong>位置一</strong> 的注释，程序是无法获得预期执行的，由于该 channel 是无缓冲的，位置一的代码会陷入阻塞，下一行的 goroutine 根本没有机会执行。整个代码会陷入死锁。</p>
<p>正确的操作是，打开 <strong>位置二</strong> 的注释，因为上一行 goroutine 先行启动，他是一个独立的协程，不会阻塞主 groutine 的执行，但它内部会阻塞在 <code>num := &lt;-ch</code> 这行代码，直到主协程执行完 <code>ch&lt;-5</code> ，才会执行打印。所以这里也有一个非常重要的问题，主协程如果不等待子协程执行完就退出的话，会看不到执行结果。</p>
<p>这里先提一点，无缓冲的 channel 并不会用到内部结构体的 <code>buf</code> ，这部分具体会在源码部分讲解他们的数据存取、交换的方式。</p>
<h3 id="有缓冲-channel"><a href="#有缓冲-channel" class="headerlink" title="有缓冲 channel"></a>有缓冲 channel</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 注意这里</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">//ch&lt;-5 // 位置一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    num := &lt;-ch</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch&lt;-5 // 位置二</span></span><br></pre></td></tr></table></figure>
<p>代码基本没有改变，唯一的区别是 make 函数传入了第二个参数，这个值的含义是缓冲的大小。那么此时 <strong>位置一</strong> 与 <strong>位置二</strong> 都能够正常执行吗？</p>
<p>答案是肯定的，此时的代码，无论是那个位置，打开注释后都能够正常执行。原因就在于由于 channel 有了缓存区域，<strong>位置一</strong> 写入数据不会造成主协程的阻塞，那么下一行代码的子协程就可以正常启动，并直接将位置一写入 <code>buf</code> 的数据读取出来打印。</p>
<p>对于 <strong>位置二</strong> ，由于子协程先启动，但是会被阻塞在 <code>num := &lt;-ch</code> 这一行，因为此时 <code>buf</code> 中没有任何内容可读取（下期源码分析我们可以看代码实现），直到位置二执行完，唤醒子协程。</p>
<hr>
<p>发送需要注意几个问题：</p>
<ol>
<li><p>什么时候会被阻塞？</p>
<ul>
<li>向 <code>nil</code> 通道发送数据会被阻塞</li>
<li>向无缓冲 channel 写数据，如果读协程没有准备好，会阻塞</li>
<li>向有缓冲 channel 写数据，如果缓冲已满，会阻塞</li>
</ul>
</li>
<li><p>什么时候会 <code>panic</code>？</p>
<ul>
<li>closed的 channel，写数据会 panic</li>
</ul>
</li>
<li><p>就算是有缓冲的 channel ，也不是每次发送、接收都要经过缓存，如果发送的时候，刚好有等待接收的协程，那么会直接交换数据。</p>
</li>
</ol>
<h2 id="receive"><a href="#receive" class="headerlink" title="receive"></a>receive</h2><p>有写入，必然后读取。</p>
<p>还是上面的代码， <code>num := &lt;-ch</code> 就是从 channel 读取数据。对于读取就不按照有缓冲与无缓冲来讲解了，它们的主要问题是什么时候阻塞。通过上面写的例子自己再想想即可。</p>
<p>这里说下读取的两种形式。</p>
<p><strong>形式一</strong></p>
<blockquote>
<p>multi-valued assignment</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>
<p><code>ok</code> 是一个 bool 类型，可以通过它来判断 channel 是否已经关闭，如果关闭该值为 true ，此时 v 接收到的是 channel 类型的零值。比如： channel 是传递的 int， 那么 v 就是 0 ；如果是结构体，那么 v 就是结构体内部对应字段的零值。</p>
<p><strong>形式二</strong></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := &lt;-ch</span><br></pre></td></tr></table></figure>
<p>该方式对于关闭的 channel 无法掌控，我们示例中就是该种方式。</p>
<hr>
<p>接收需要注意几个问题：</p>
<ol>
<li><p>什么时候会被阻塞？</p>
<ul>
<li>从 <code>nil</code> 通道接收数据会被阻塞</li>
<li>从无缓冲 channel 读数据，如果写协程没有准备好，会阻塞</li>
<li>从有缓冲 channel 读数据，如果缓冲为空，会阻塞</li>
</ul>
</li>
<li><p>读取的 channel 如果被关闭，并不会影响正在读的数据，它会将所有数据读取完毕，并不会立即就失败或者返回零值</p>
</li>
</ol>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>对于 channel 的关闭，在什么地方去关闭呢？因为上面也讲到向 closed 的 channel 写或者继续 close 都会导致 panic问题。</p>
<p>一般的建议是谁写入，谁负责关闭。如果涉及到多个写入的协程、多个读取的协程？又该如何关闭？总的来说就是加入一个标记避免重复关闭。不过真的不建议搞的太复杂，否则后续维护代码会疯掉。</p>
<hr>
<p>关闭需要注意几个问题：</p>
<ol>
<li>什么时候会 <code>panic</code>？<ul>
<li>closed 的 channel，再次关闭 close 会 panic</li>
</ul>
</li>
</ol>
<h2 id="for-range"><a href="#for-range" class="headerlink" title="for-range"></a>for-range</h2><p>我们常常会用 <code>for-range</code> 来读取 channel的数据。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;(ch)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> val := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    fmt.Println(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该语句的一个特色是如果 channel 已经被关闭，它还是会继续执行，直到所有值被取完，然后退出执行。而如果通道没有关闭，但是channel没有可读取的数据，它则会阻塞在 range 这句位置，直到被唤醒。但是如果 channel 是 nil，那么同样符合我们上面说的的原则，读取会被阻塞，也就是会一直阻塞在 <code>range</code> 位置。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><code>select</code> 是跟 channel 关系最亲密的语句，它是被专门设计出来处理通道的，因为每个 case 后面跟的都是通道表达式，可以是读，也可以是写。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">q := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch, q <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        num := &lt;-ch</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    &#125;</span><br><span class="line">    q &lt;- <span class="number">1</span></span><br><span class="line">&#125;(ch, q)</span><br><span class="line"></span><br><span class="line">fibonacci := <span class="function"><span class="keyword">func</span><span class="params">(ch, q <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ch &lt;- x: <span class="comment">// 写入</span></span><br><span class="line">            x, y = y, x+y</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// 你觉得是否会影响 for 语句的循环？</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-q: <span class="comment">// 读取</span></span><br><span class="line">            fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fibonacci(ch, q)</span><br></pre></td></tr></table></figure>
<p>上面的代码是利用 channel 实现的一个斐波拉契数列。select 还可以有 default 语句，该语句会在其它 case 都被阻塞的情况下执行。</p>
<hr>
<p>关注的问题</p>
<ol>
<li>select 只要有默认语句，就不会被阻塞，换句话说，如果没有 default，然后 case 又都不能读或者写，则会被阻塞</li>
<li>nil 的 channel，不管读写都会被阻塞</li>
<li>select 不能够像 <code>for-range</code> 一样发现 channel 被关闭而终止执行，所以需要结合 <code>multi-valued assignment</code> 来处理</li>
<li>如果同时有多个 case 满足了条件，会使用伪随机选择一个 case 来执行</li>
<li>select 语句如果不配合 for 语句使用，只会对 case 表达式求值一次</li>
<li>每次 select 语句的执行，是会扫码完所有的 case 后才确定如何执行，而不是说遇到合适的 case 就直接执行了。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文内容很简单易懂，希望大家彻底掌握了 channel 的使用。一切源码的研究都是为了更好的使用，后面的文章将开始研究 channel 的源码实现。</p>
<p>本文几个重要问题再次总结下，也是经常面试的常考点。</p>
<ol>
<li>向 close 的 channel 写数据、再次 close 都会触发 <code>runtime panic</code>。</li>
<li>向 nil channel 写、读取数据，都会阻塞，可以利用这点来优化 for + select 的用法。</li>
<li>channel 的关闭最好在写入方处理，读的协程不要去关闭 channel，可以通过单向通道来表明 channel 在该位置的功能。</li>
<li>如果有多个写协程的 channel 需要关闭，可以使用额外的 channel 来标记，也可以使用 <code>sync.Once</code> 或者 <code>sync.Mutex</code> 来处理。</li>
<li>channel 不管是读写都是并发安全的，不会出现多个协程同时读或者写的情况，从而实现了 CSP。</li>
</ol>
<p><strong>参考资料</strong></p>
<ul>
<li>[1] <a href="https://colobu.com/2016/04/14/Golang-Channels/" target="_blank" rel="external">Go Channel 详解</a> </li>
<li>[2] <a href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html" target="_blank" rel="external">The Nature Of Channels In Go</a></li>
</ul>
<p><strong>下期预告</strong></p>
<p>channel 这些特性是如何在代码层面实现的？下期会先将 channel 内部两个重要的数据结构：循环队列实现的buf，以及单向链表实现的协程读写队列。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Golang的Debug工具delve介绍]]></title>
      <url>http://dayutalk.cn/2020/05/10/Golang%E7%9A%84Debug%E5%B7%A5%E5%85%B7delve%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>好久没有写工具类的使用介绍了，今天推荐下 <code>delve</code><br><a id="more"></a></p>
<p><code>delve</code> 的汉语意思是：钻研、探索；用这个来命名一个debug工具还是非常的形象。</p>
<p>本文主要介绍该工具的安装与常用使用方法。是一个step-by-step的文章。目标是帮助大家学会如何使用 <code>delve</code> 来debug自己的代码。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>官网的安装文档地址：<a href="https://github.com/go-delve/delve/tree/master/Documentation/installation" target="_blank" rel="external">https://github.com/go-delve/delve/tree/master/Documentation/installation</a></p>
<p>我再重复下如何在 <code>Mac</code> 上进行安装。</p>
<p>首先 <code>xcode-select --install</code> 把依赖的编译工具链安装一下。</p>
<p>然后通过下面的命令即可完成</p>
<blockquote>
<p>$ go get github.com/go-delve/delve/cmd/dlv</p>
</blockquote>
<p>这里有个注意点，大家如果使用modules的方式来管理项目，应该知道安装依赖包也是上面这个命令。所以执行上面的命令时，请确保自己不是在一个go modules的路径下。</p>
<p>到此，安装工作就可以完成了，可以在终端执行，可以看到如下画面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ /Users/dayu &gt;dlv version</span><br><span class="line">Delve Debugger</span><br><span class="line">Version: 1.4.0</span><br><span class="line">Build: $Id: 67422e6f7148fa1efa0eac1423ab5594b223d93b $</span><br></pre></td></tr></table></figure>
<h1 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h1><p>用中文来翻译下命令的含义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  dlv [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  attach      可以用来对一个正在运行的进行进行调试.</span><br><span class="line">  connect     连接到headless调试器.</span><br><span class="line">  core        用来调试core文件.</span><br><span class="line">  dap         [EXPERIMENTAL] 启动一个Debug Adaptor Protocol (DAP)的TCP服务器来通信.</span><br><span class="line">  debug       在当前包或者指定的包编译并debug程序.</span><br><span class="line">  exec        如果你已经编译好了二进制，可以用该命令启动调试.</span><br><span class="line">  help        帮助命令.</span><br><span class="line">  test        可以用来测试自己编写的测试源码文件.</span><br><span class="line">  trace       编译并跟踪程序.</span><br></pre></td></tr></table></figure>
<p><code>dlv</code> 的命令非常多，主要介绍下 <code>debug</code> 与 <code>attach</code> 的使用。其它命令大家可以尝试下，不过一般用的也非常少！dlv test 这个也非常有用，不过使用跟debug差不多。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>下面将主要介绍这 <code>debug</code> 与 <code>attach</code> 如何使用，这两个命令其实主要面对两种使用场景。</p>
<ol>
<li>用 Golang 写了一个命令行程序，想要debug一下；</li>
<li>写了一个 Grpc 或者 Http 服务，运行的进行进行debug；</li>
</ol>
<p>进入调试后，他们的命令非常相似，下面开始我们的 debug 之旅。</p>
<h2 id="Debug-Main包程序"><a href="#Debug-Main包程序" class="headerlink" title="Debug Main包程序"></a>Debug Main包程序</h2><p>先来看直接使用 <code>debug</code> 来调试代码。调试的代码样例：</p>
<p><img src="https://dayutalk.cn/img/20200510/debug-00.png" alt="debug调试代码"></p>
<p>此时在终端进入该文件所在路径，然后执行</p>
<blockquote>
<p>dlv debug</p>
</blockquote>
<p>然后会成功进入 delve 提供的debug交互界面，如下图所示。</p>
<p><img src="https://dayutalk.cn/img/20200510/debug-01.png" alt="debug交互"></p>
<p>图中展示了三个非常常用的命令。来分别解释下。</p>
<ul>
<li>b main.main</li>
</ul>
<p>这个命令的全拼是： <code>break main.main</code> 用来设置断点的。除了这种写法，常用的还有使用行号来设置断点 <code>b 9</code>。</p>
<ul>
<li>bp</li>
</ul>
<p>这个命令是用来查找已经设置的断点的。</p>
<p><img src="https://dayutalk.cn/img/20200510/debug-02.png" alt="断点查看"></p>
<p>查看已经设置的断点常常一个目的是用来寻找 <code>clear</code> 可以清除哪一个断点。</p>
<ul>
<li>c</li>
</ul>
<p>该命令是让程序运行起来。遇到设置的断点会停止。</p>
<hr>
<p>上面只是非常基础的三个命令，我们再来继续往下走。继续看这张执行示例图</p>
<p><img src="https://dayutalk.cn/img/20200510/debug-03.png" alt="调试"></p>
<p>这张图中的命令，都是非常常用的调试命令，来一起看看作用</p>
<ul>
<li>restart</li>
</ul>
<p>这个命令的主要作用就是一轮debug完成了，重新开始下一轮，上一次设置的断点会依然有效</p>
<ul>
<li>n</li>
</ul>
<p>这是执行下一步，也就是代码的下一行。它就是一行一行的往下，不会陷入内部去</p>
<ul>
<li>s</li>
</ul>
<p>该命令注意与 <code>n</code> 的区别，它是进入某个函数的内部，源码函数也能够跟踪进去，非常有利于我们学习。但是对于 <code>goroutine</code> 执行的函数你是无法进入的。这也很好理解，因为它的执行时机不可知。</p>
<ul>
<li>p </li>
</ul>
<p>这个是debug过程中非常重要的一个命令，打印变量的值。也是学习 go 语言的一个利器，图中可以看到一个 channel 初始化之后的内部结构体。这对我们理解源码非常有帮助。</p>
<hr>
<p>下面的命令图中没有演示，但觉得有必要说一下。</p>
<ul>
<li>so</li>
</ul>
<p>如果用了 <code>s</code> 陷入到内部函数，可以快速使用该命令跳出来，回到进入点。</p>
<ul>
<li>gr and grs</li>
</ul>
<p>这两个命令是用来查看 groutine 的。</p>
<p>他还有非常多的命令。我们可以在使用过程中随时使用 <code>help</code> 来进行查看。文末我也放了一张所有命令图的翻译。</p>
<h2 id="Debug运行的进程"><a href="#Debug运行的进程" class="headerlink" title="Debug运行的进程"></a>Debug运行的进程</h2><p>对于运行中的进程，主要说明下如何进入 <code>debug</code> 交互界面，进入后的操作与上面是一样的。</p>
<p>假如我们有一个 http 的进程在运行，看一下如何进行 debug。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	http.HandleFunc(&quot;/&quot;, Hello)</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(&quot;:8080&quot;, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Hello(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	a := &quot;test&quot;</span><br><span class="line"></span><br><span class="line">	fmt.Println(a)</span><br><span class="line"></span><br><span class="line">	time.Sleep(3 * time.Second)</span><br><span class="line"></span><br><span class="line">	fmt.Fprint(w, &quot;Hello World&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将这个 demo 给运行起来，然后找到他的进程号。执行下面的命令：</p>
<blockquote>
<p>dlv attach {pid}</p>
</blockquote>
<p>这个 pid 就是当前进程的进程号。</p>
<p>使用该方式要注意：设置完断点后记得用 <code>c</code> 让进程处于运行状态，否则对于 http 或者 grpc 的程序，没有办法继续接受请求，进而无法进入测试。</p>
<p><img src="https://dayutalk.cn/img/20200510/debug-04.png" alt="帮助文件的翻译]"></p>
<p><strong>参考资料</strong></p>
<ul>
<li>[1] <a href="https://github.com/go-delve/delve" target="_blank" rel="external">https://github.com/go-delve/delve</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[购物车之架构设计]]></title>
      <url>http://dayutalk.cn/2020/04/05/%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%B9%8B%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<p>来还债了，希望大家在疫情中都是平安的，回来的时候公司也还在！<br><a id="more"></a></p>
<blockquote>
<p>skr shop是一群底层码农，由于被工作中的项目折磨的精神失常，加之由于程序员的自傲：别人设计的系统都是一坨shit，我的设计才是宇宙最牛逼，于是乎决定要做一个只设计不编码的电商设计手册。</p>
</blockquote>
<p><strong>项目地址：<a href="https://github.com/skr-shop/manuals" target="_blank" rel="external">https://github.com/skr-shop/manuals</a></strong></p>
<p>在上一篇文章 <a href="https://dayutalk.cn/2019/12/09/%E8%B4%AD%E7%89%A9%E8%BD%A6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/">购物车设计之需求分析</a> 描述了购物车的通用需求。本文重点则在如何实现上进行架构上的设计（业务+系统架构）。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>架构设计可以分为三个层面：</p>
<ul>
<li>业务架构</li>
<li>系统架构</li>
<li>技术架构</li>
</ul>
<p>快速简单的说明下三个架构的意思；当我们拿到购物车需求时，我们说用Golang来实现，存储用Redis；这描述的是技术架构；我们对购物车代码项目进行代码分层，设计规范，以及依赖系统的规划这叫系统架构；</p>
<p>那业务架构是什么呢？业务架构本质上是对系统架构的文字语言描述；什么意思？我们拿到一个需求首先要跟需求方进行沟通，建立统一的认知。比如：规范名词（购物车中说的商品与商品系统中商品的含义是不同的）；建立大家都能明白的模型，购物车、用户、商品、订单这些实体之间的互动，以及各自具备什么功能。</p>
<p>在业务架构分析上有很多方法论，比如：领域驱动设计，但是它并不是唯一的业务架构分析方法，也并不是说最好的。适合你的就是最好的。我们常用的实体关系图、UML图也属于业务架构领域；</p>
<p>这里需要强点一点的是，不管你用什么方式来建模设计，有设计总比没设计强，其次一定要将建模的内容体现到你的代码中去。</p>
<p>本文在业务架构上的分析借助了 <code>DDD</code> （领域驱动设计）思想；还是那句话<code>适合的就是最好的</code>。</p>
<h1 id="业务架构"><a href="#业务架构" class="headerlink" title="业务架构"></a>业务架构</h1><p>通过前面的需求分析，我们已经明确我们的购物车要干什么了。先来看一下一个典型的用户操作购物车过程。</p>
<p><img src="https://dayutalk.cn/img/cart-sys-00.png" alt="用户旅程"></p>
<p>在这个过程中，用户使用购物车这个载体完成了商品的购买流程；不断流动的数据是商品，购物车这个载体是稳定的。这是我们系统中的稳定点与变化点。</p>
<p>商品的流动方式可能多种多样，比如从不同地方加入购物车，不同方式加入购物车，生命周期在购物车中也不一样；但是这个流程是稳定的，一定是先让购物车中存在商品，然后才能去结算产生订单。</p>
<p>商品在购物车中的生命周期如下：</p>
<p><img src="https://dayutalk.cn/img/cart-sys-01.jpg" alt="过程"></p>
<p>按照这个过程，我们来看一下每个阶段对应的操作。</p>
<p><img src="https://dayutalk.cn/img/cart-sys-02.jpg" alt="过程对应的操作"></p>
<p>这里注意一点，加车前这个操作其实我们可以放到购物车的添加操作中，但是由于这部分是非常不稳定且多变的。我们将其独立出来，方便后续进行扩展而不影响相对比较稳定的购物车阶段。</p>
<blockquote>
<p>上面这三个阶段，按照DDD中的概念，应该叫做实体，他们整体构成了购物车这个域；今天我们先不讲这些概念，就先略过，后面有机会单独发文讲解。</p>
</blockquote>
<h2 id="加车前"><a href="#加车前" class="headerlink" title="加车前"></a>加车前</h2><p>通过流程分析，我们总结出了系统需要具备的操作接口，以及这些接口对应的实体，现在我们先来看加车前主要要做些什么；</p>
<p>加车前其实主要就是对准备加入的购物车商品进行各个纬度的校验，检查是否满足要求。</p>
<p>在让用户加车前，我们首先解决的是用户从哪里卖，然后进行验证？因为同一个商品从不同渠道购买是存在不同情况的，比如：小米手机，我们是通过秒杀买，还是通过好友众筹买，或者商城直接购买，价格存在差异，但是实际上他是同一个商品；</p>
<p>第二个问题是是否具备购买资格，还是上面说的，秒杀、众筹这个加车操作，不是谁都可以添加的，得现有资格。那么资格的检查也是放到这里；</p>
<p>第三个问题是对这个购买的商品进行商品属性上的验证，如是否上下架，有库存，限购数量等等。</p>
<p>而且大家会发现，这里的验证条件可能是非常多变的。如何构建一个方便扩展的代码呢？</p>
<p><img src="https://dayutalk.cn/img/cart-sys-03.jpg" alt="加车的验证"></p>
<p>整个加车过程，重要的就是根据来源来区分不同的验证。我们有两种选择方式。</p>
<p>方式一：通过策略模式+门面模式的方式来搞定。策略就是根据不同的加车来源进行不同的验证，门面就是根据不同的来源封装一个个策略；</p>
<p>方式二：通过责任链模式，但是这里需要有一个变化，这个链在执行过程中，可以选择跳过某些节点，比如：秒杀不需要库存、也不需要众筹的验证；</p>
<p>通过综合的分析我选择了责任链的模式。贴一下核心代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 每个验证逻辑要实现的接口</span><br><span class="line">type Handler interface &#123;</span><br><span class="line">	Skipped(in interface&#123;&#125;) bool // 这里判断是否跳过</span><br><span class="line">	HandleRequest(in interface&#123;&#125;) error // 这里进行各种验证</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 责任链的节点</span><br><span class="line">type RequestChain struct &#123;</span><br><span class="line">	Handler</span><br><span class="line">	Next *RequestChain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置handler</span><br><span class="line">func (h *RequestChain) SetNextHandler(in *RequestChain) *RequestChain &#123;</span><br><span class="line">	h.Next = in</span><br><span class="line">	return in</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于设计模式，大家可以看我小伙伴的github：<a href="https://github.com/TIGERB/easy-tips/tree/master/go/src/patterns" target="_blank" rel="external">https://github.com/TIGERB/easy-tips/tree/master/go/src/patterns</a></p>
<h2 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h2><p>说完了加车前，现在来看购物车这一部分。我们在之前曾讨论过，购物车可能会有多种形态的，比如：存储多个商品一起结算，某个商品立即结算等。因此购物车一定会根据渠道来进行购物车类型的选择。</p>
<p>这部分的操作相对是比较稳定的。我们挑几个比较重要的操作来讲一下思路即可。</p>
<h3 id="加入购物车"><a href="#加入购物车" class="headerlink" title="加入购物车"></a>加入购物车</h3><p>通过把条件验证的前置，会发现在进行加车操作时，这部分逻辑已经变得非常的轻量了。要做的主要是下面几个部分的逻辑。</p>
<p><img src="https://dayutalk.cn/img/cart-sys-04.jpg" alt="加入购物车"></p>
<p>这里有几个取巧的地方，首先是获取商品的逻辑，由于在前面验证的时候也会用到，因此这里前面获取后会通过参数的方式继续往后传递，因此这里不需要在读库或者调用服务来获取；</p>
<p>其次这里需要把当前用户现有购物车数据获取到，然后将添加的这个商品添加进来。这是一个类似合并操作，原来这个商品是存在，相当于数量加一；需要注意这个商品跟现存的商品有没有父子关系，有没有可能加入后改变了某个活动规则，比如：原来买了2个送1个赠品，现在再添加了一个变成3个，送2个赠品；</p>
<blockquote>
<p>注意：这里的添加并不是在购物车直接改数量，可能就是在列表、详情页直接添加添加。</p>
</blockquote>
<p>通过将合并后的购物车数据，通过营销活动检查确认ok后，直接回写到存储中。</p>
<h3 id="合并购物车"><a href="#合并购物车" class="headerlink" title="合并购物车"></a>合并购物车</h3><p>为什么会有合并购物车这个操作？因为一般电商都是准许游客身份进行操作的，因此当用户登录后需要将二者进行合并。</p>
<p>这里的合并很多部分的逻辑是可以与加入购物车复用的逻辑。比如：合并后的数据都需要检查是否合法，然后覆写回存储中。因此大家可以看到这里的关联性。设计的方法在某种程度上要通用。</p>
<h3 id="购物车列表"><a href="#购物车列表" class="headerlink" title="购物车列表"></a>购物车列表</h3><p>购物车列表这是一个非常重要的接口，原则上购物车接口会提供两种类型，一种简版，一种完全版本；</p>
<p>简版的列表接口主要是用在类似PC首页右上角之类获取简单信息；完全版本就是在购物车列表中会用到。</p>
<p>在实际实现中，购物车绝不仅仅是一个读取接口那么简单。因为我们都知道不管是商品信息、活动信息都是在不断的发生变化。因此每次的读取接口必然需要检查当前购物车中数据的合法性，然后发现不一致后需要覆写原存储的数据。</p>
<p><img src="https://dayutalk.cn/img/cart-sys-05.jpg" alt="购物车列表"></p>
<p>也有一些做法会在每个接口都去检查数据的合法性，我建议为了性能考虑，部分接口可以适当放宽检查，在获取列表时再进行完整的检查。比如添加接口，我只会检测我添加的商品的合法性，绝不会对整个购物车进行检查。因为该操作之后一般都会调用列表操作，那么此时还会进行校验，二者重复操作，因此只取后者。</p>
<h2 id="结算"><a href="#结算" class="headerlink" title="结算"></a>结算</h2><p>结算包括两部分，结算页的详情信息与提交订单。结算页可以说是在购物车列表上的一个包装，因为结算页与列表页最大的不同是需要用户选择配送地址（虚拟商品另说），此时会产生更明确的价格信息，其他基本一致。因此在设计购物车列表接口的时候，一定要考虑充分的通用性。</p>
<p>这里另外一个需要注意的是：立即购买，我们也会通过结算页接口来实现，但是内部其实还是会调用添加接口，将商品添加到购物车中；有三个需要注意的地方，首先是这个添加操作是服务内部完成的，对于服务调用方是不需要感知这个加入操作的存在；其次是这个购物车在Redis中的Key是独立于普通购物车的，否则二者的商品耦合在一起非常难于操作处理；最后立即购买的购物车要考虑账号多终端登录的时候，彼此数据不能互相影响，这里可以用每个端的uuid来作为购物车的标记避免这种情况。</p>
<p>购物车的最后一步是生成订单，这一步最要紧的是需要给购物车加锁，避免提交过程中数据被篡改，多说一句，很多人写的Redis分布式锁代码都存在缺陷，大家一定要注意原子性的问题，这类文章网络上很多不再赘述。</p>
<p>加锁成功之后，我们这里有多种做法，一种是按照DB涉及组织数据开始写表，这适用于业务量要求不大，比如订单每秒下单量不超过2000K的；那如果你的系统并发要求非常高怎么办？</p>
<p>其实也很简单，高性能的三大法宝之一：异步；我们提交的时候直接将数据快照写入MQ中，然后通过异步的方式进行消费处理，可以通过通过控制消费者的数量来提升处理能力。这种方法虽然性能提升，但是复杂度也会上升，大家需要根据自己的实际情况来选择。</p>
<p>关于业务架构的设计，到此告一段落，接下来我们来看系统架构。</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>系统结构主要包含，如何将业务架构映射过来，以及输出对应输入参数、输出参数的说明。由于输入、输出针对各自业务来确定的，而且没有什么难度，我们这里就只说如何将业务架构映射到系统架构，以及系统架构中最核心的Redis数据结构选择以及存储的数据结构设计。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>下面的代码目录是按照 <code>Golang</code> 来进行设计的。我们来看看如何将上面的业务架构映射到代码层面来。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── addproducts.<span class="keyword">go</span></span><br><span class="line">├── cartlist.<span class="keyword">go</span></span><br><span class="line">├── mergecart.<span class="keyword">go</span></span><br><span class="line">├── entity</span><br><span class="line">│   ├── cart</span><br><span class="line">│   │   ├── add.<span class="keyword">go</span></span><br><span class="line">│   │   ├── cart.<span class="keyword">go</span></span><br><span class="line">│   │   └── list.<span class="keyword">go</span></span><br><span class="line">│   ├── order</span><br><span class="line">│   │   ├── checkout.<span class="keyword">go</span></span><br><span class="line">│   │   ├── order.<span class="keyword">go</span></span><br><span class="line">│   │   └── submit.<span class="keyword">go</span></span><br><span class="line">│   └── precart</span><br><span class="line">├── event</span><br><span class="line">│   └── sendorder.<span class="keyword">go</span></span><br><span class="line">├── facade</span><br><span class="line">│   ├── activity.<span class="keyword">go</span></span><br><span class="line">│   └── product.<span class="keyword">go</span></span><br><span class="line">└── repo</span><br></pre></td></tr></table></figure>
<p>外层有 <code>entity</code>、<code>event</code>、<code>facade</code>、<code>repo</code>这四个目录，职责如下：</p>
<p><strong>entity</strong>: 存放的是我们前面分析的购物领域的三个实体；所有主要的操作都在这三个实体上；</p>
<p><strong>event</strong>: 这是用来处理产生的事件，比如刚刚说的如果我们提交订单采用异步的方式，那么该目录就该完成的是如何把数据发送到MQ中去；</p>
<p><strong>facade</strong>: 这儿目录是干嘛的呢？这主要是因为我们的服务还需要依赖像商品、营销活动这些服务，那么我们不应该在实体中直接调用它，因为第三方可能存在变动，或者有增加、减少，我们在这里进行以下简单的封装(设计模式中的门面模式)；</p>
<p><strong>repo</strong>: 这个目录从某种程度上可以理解为 <code>Model</code>层，在整个领域服务中，如果与持久化打交道，都通过它来完成。</p>
<p>最后外层的几个文件，就是我们所提供的领域服务，供应用层来进行调用的。</p>
<blockquote>
<p>为了保证内容的紧凑，我这里放弃了对整个微服务的目录介绍，只单独介绍了领域服务，后续会单独成文介绍下微服务的整个系统架构。</p>
</blockquote>
<p>通过上面的划分，我们完成了两件事情：</p>
<ol>
<li><p>业务架构分析的结构在系统代码中都有映射，他们彼此体现。这样最大的好处是，保证设计与代码的一致性，看了文档你就知道对应的代码在哪里；</p>
</li>
<li><p>每个目录各自的关注点都进行了分离，更内聚，更容易开发与维护。</p>
</li>
</ol>
<h2 id="Redis存储"><a href="#Redis存储" class="headerlink" title="Redis存储"></a>Redis存储</h2><p>现在来看，我们选择Redis作为购物商品数据的存储，我们要解决两个问题，一是我们需要存哪些数据？二是我们用什么结构来存？</p>
<p>网络上很多写购物车的都是只保存一个商品id，真实场景是很难满足需求的。你想想，一个商品id如何记住用户选择的赠品？用户上次选择的活动？以及购买的商品渠道？</p>
<p>综合比较通用的场景，我给出一个参考结构：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 购物车数据</span></span><br><span class="line"><span class="keyword">type</span> ShoppingData <span class="keyword">struct</span> &#123;</span><br><span class="line">	Item       []*Item <span class="string">`json:"item"`</span></span><br><span class="line">	UpdateTime <span class="keyword">int64</span>   <span class="string">`json:"update_time"`</span></span><br><span class="line">	Version    <span class="keyword">int32</span>   <span class="string">`json:"version"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个商品item元素</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	ItemId       <span class="keyword">string</span>          <span class="string">`json:"item_id"`</span></span><br><span class="line">	ParentItemId <span class="keyword">string</span>          <span class="string">`json:"parent_item_id,omitempty"`</span> <span class="comment">// 绑定的父item id</span></span><br><span class="line">	OrderId      <span class="keyword">string</span>          <span class="string">`json:"order_id,omitempty"`</span>       <span class="comment">// 绑定的订单号</span></span><br><span class="line">	Sku          <span class="keyword">int64</span>           <span class="string">`json:"sku"`</span></span><br><span class="line">	Spu          <span class="keyword">int64</span>           <span class="string">`json:"spu"`</span></span><br><span class="line">	Channel      <span class="keyword">string</span>          <span class="string">`json:"channel"`</span></span><br><span class="line">	Num          <span class="keyword">int32</span>           <span class="string">`json:"num"`</span></span><br><span class="line">	Status       <span class="keyword">int32</span>           <span class="string">`json:"status"`</span></span><br><span class="line">	TTL          <span class="keyword">int32</span>           <span class="string">`json:"ttl"`</span>                     <span class="comment">// 有效时间</span></span><br><span class="line">	SalePrice    <span class="keyword">float64</span>         <span class="string">`json:"sale_price"`</span>              <span class="comment">// 记录加车时候的销售价格</span></span><br><span class="line">	SpecialPrice <span class="keyword">float64</span>         <span class="string">`json:"special_price,omitempty"`</span> <span class="comment">// 指定价格加购物车</span></span><br><span class="line">	PostFree     <span class="keyword">bool</span>            <span class="string">`json:"post_free,omitempty"`</span>     <span class="comment">// 是否免邮</span></span><br><span class="line">	Activities   []*ItemActivity <span class="string">`json:"activities,omitempty"`</span>    <span class="comment">// 参加的活动记录</span></span><br><span class="line">	AddTime      <span class="keyword">int64</span>           <span class="string">`json:"add_time"`</span></span><br><span class="line">	UpdateTime   <span class="keyword">int64</span>           <span class="string">`json:"update_time"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 活动</span></span><br><span class="line"><span class="keyword">type</span> ItemActivity <span class="keyword">struct</span> &#123;</span><br><span class="line">	ActID    <span class="keyword">string</span> <span class="string">`json:"act_id"`</span></span><br><span class="line">	ActType  <span class="keyword">string</span> <span class="string">`json:"act_type"`</span></span><br><span class="line">	ActTitle <span class="keyword">string</span> <span class="string">`json:"act_title"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点说一下 <code>Item</code> 这个结构，<code>item_id</code> 这个字段是标记购物车中某个商品的唯一标记，因为我们之前说过，同一个sku由于渠道不同，那么在购物车中会是两个不同的item；接下来的 <code>parent_item_id</code> 字段是用来标记父子关系的，这里将可能存在的树结构转成了顺序结构，我们不管是父商品还是子商品，都采用顺序存储，然后通过这个字段来进行关联；有些同学可能会奇怪，为什么会存order id这个字段呢？大家关注下自己的日常业务，比如：再来一单、定金预售等，这种一定是与某个订单相关联的，不管是为了资格验证还是数据统计。剩下的字段都是一些非常常规的字段，就不在一一介绍了；</p>
<blockquote>
<p>字段的类型，大家根据自己的需要进行修改。</p>
</blockquote>
<p>接下来该说怎么选择Redis的存储结构了，Redis常用的 <code>Hash Table、集合、有序集合、链表、字符串</code> 五种，我们一个个来分析。</p>
<p>首先购车一定有一个key来标记这个购物车属于哪个用户的，为了简化，我们的key假设是：<code>uid:cart_type</code>。</p>
<p>我们先来看如果用 <code>Hash Table</code>；我们添加时，需要用到如下命令：<code>HSET uid:cart_type sku ShoppingData</code>；看起来没问题，我们可以根据sku快速定位某个商品然后进行相关的修改等，但是注意，ShoppingData是一个json串，如果用户购物车中有非常多的商品，我们用 <code>HGETALL uid:cart_type</code> 获取到的时间复杂度是O(n)，然后代码中还需要一一反序列化，又是O(n)的复杂度。</p>
<p>如果用<code>集合</code>，也会遇到类似的问题，每个购物车看做一个集合，集合中的每个元素是 ShoppingData ，取到代码中依然需要逐一反序列化(反序列化是成本)，关于有序集合与链表就不在分析，大家可以按照上面的思路去尝试下问题所在。</p>
<p>看起来我们没得选，只有使用<code>String</code>，那我们来看一下<code>String</code>的契合度是什么样子。首先<code>SET uid:cart_type ShoppingDataArr</code>；我们把购物车所有的数据序列化成一个字符串存储，每次取出来的时间复杂度是O(1)，序列化、反序列化都只需要一次。看来是非常不错的选择。但是在使用中大家还是有几点需要注意。</p>
<ol>
<li>单个Value不能太大，要不然就会出现大key问题，所以一般购物车有上限限制，比如item不能超过多少个；</li>
<li>对redis的操作性能提升上来了，但是代码的就是修改单个item时的不便，必须每次读取全部然后找到对应的item进行修改；这里我们可以把从redis中的数据读取出来后，在内存中构建一个HashTable，来减少每次遍历的复杂度；</li>
</ol>
<p>网上也看到很多Redis数据结构组合使用来保存购物车数据的，但是无疑增加了网络开销，相比起来还是String最经济划算。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此对于购物车的实现设计算是完结了，其中关于订单表的设计会单独放到订单模块去讲。</p>
<p>对于整个购物车服务，虽然没有写的详细到某个具体的接口，但是分析到这一步，我相信大家心中都是有沟壑的，能够结合自己的业务去实现它。</p>
<p>文中有些很有意思的地方，建议大家动手去做做看，有任何问题，我们随时交流。</p>
<ul>
<li>改编版的责任链模式</li>
<li>Redis的分布式事务锁实现</li>
</ul>
<p>接下来终于要到订单部分的设计了，希望大家继续关注我们。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[再见2019，不畏将来，不念过往]]></title>
      <url>http://dayutalk.cn/2019/12/29/%E5%86%8D%E8%A7%812019%EF%BC%8C%E4%B8%8D%E7%95%8F%E5%B0%86%E6%9D%A5%EF%BC%8C%E4%B8%8D%E5%BF%B5%E8%BF%87%E5%BE%80/</url>
      <content type="html"><![CDATA[<p>不乱于心，不困于情。 不畏将来，不念过往。 如此，安好！<br><a id="more"></a></p>
<p>上面这句话出自 <code>丰子恺的《不宠无惊过一生》</code> ，这这句是一种生活的境界，如若真能做到，算是活到了人生至高境界！</p>
<p>回顾2019年，犹如东逝之水，奔流而不复回；用此为文总结一下点点滴滴，以此来为2020查漏补缺。</p>
<h1 id="关于公众号"><a href="#关于公众号" class="headerlink" title="关于公众号"></a>关于公众号</h1><p>今年总共写了 <strong>10篇</strong> 文章，数量上远远少于去年立的flag；不过今年文章的整体质量上是有所提升的。绝大部分都是花费了至少2周的时间去总结、学习然后才成文，每篇的写字时间也是至少5个小时才完成。今年也尝试写了一些技术之外的东西，虽说这样显得公众号可能有些不伦不类，不过我写这些文字的初衷更多是为自己留下一些记录。</p>
<p>下面来总结下今年的文章。首先是 <code>Skr Shop</code> 系列到目前止于小伙伴们共完成了 <strong>8篇</strong>，总计 <strong>842个star</strong>；距离我们年初定的 <strong>800star</strong> 算是完成KPI。</p>
<p>[Skr-Shop]<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483940&amp;idx=1&amp;sn=4d63b0571f3284084f2a2d783f2c35cf&amp;chksm=e8080c03df7f851535a092b853b60a59360db9d520f3d2bdf560fdd54f7c99a490c850b43acc&amp;scene=21#wechat_redirect" target="_blank" rel="external">通用抽奖工具之需求分析</a></p>
<p>[Skr-Shop]<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483935&amp;idx=1&amp;sn=078f1f9250a84487b2d0221dcc7e4bf4&amp;chksm=e8080c38df7f852efa895c19eee47e5f992f897238fde7fb9d7692d2c9d19c5c3f007153a3b5&amp;scene=21#wechat_redirect" target="_blank" rel="external">营销体系开篇</a></p>
<p>[Skr-Shop]<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483929&amp;idx=1&amp;sn=f8a9ffc1b8a86d38c1b169e7860a04f2&amp;chksm=e8080c3edf7f852853720ea49cc2fd3e00bfb37299d20b4104bb976352e672de32480744fe50&amp;scene=21#wechat_redirect" target="_blank" rel="external">购物车设计之需求分析</a></p>
<p>[Skr-Shop]<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483830&amp;idx=1&amp;sn=e1493f8dbdbbf76c4506eb359a5c675f&amp;chksm=e8080f91df7f868724d3b9f7822e95c033a085865a740cb48c53d177d4dafd42f4afde389a78&amp;scene=21#wechat_redirect" target="_blank" rel="external">coder，你会设计交易系统吗？（实干篇）</a></p>
<p>[Skr-Shop]<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483827&amp;idx=1&amp;sn=082b84cde5a9c898a731558b4921b47f&amp;chksm=e8080f94df7f86826350cd115a4ec7b0ec92af5b8e7611a6df99799e35d002fdabcd99453e98&amp;scene=21#wechat_redirect" target="_blank" rel="external">coder，你会设计交易系统吗？（概念篇）</a></p>
<p>[Skr-Shop]<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483813&amp;idx=1&amp;sn=72eb9da120e1c21d809d7d187ffc531c&amp;chksm=e8080f82df7f8694f73b11ed54e62a2e47b6f96dcba03d24902d9b0b1f44016af24f517ba1bb&amp;scene=21#wechat_redirect" target="_blank" rel="external">电商设计手册之基础商品信息</a></p>
<p>[Skr-Shop]<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483799&amp;idx=1&amp;sn=43b89c20dba087799ce0feef53b2a918&amp;chksm=e8080fb0df7f86a693e657b250a7055a5e722a0921ea000eea4d9b018adc8dae8f56e575cd48&amp;scene=21#wechat_redirect" target="_blank" rel="external">支付开发，不得不知的国内、国际第三方支付流程</a></p>
<p>[Skr-Shop]<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483813&amp;idx=1&amp;sn=72eb9da120e1c21d809d7d187ffc531c&amp;chksm=e8080f82df7f8694f73b11ed54e62a2e47b6f96dcba03d24902d9b0b1f44016af24f517ba1bb&amp;scene=21#wechat_redirect" target="_blank" rel="external">电商设计手册之用户体系</a></p>
<p>很多人觉得业务没有意思，但互联网的基础就是业务从线下到线上的转移，如何带给用户体验更好、更稳定的服务是最重要的事情。2020年还会继续努力完善这个系列，也真的希望这个系列针对能够对做电商、系统设计的人有帮助。</p>
<hr>
<p>在技术方面写了 <strong>3篇</strong> 协议相关的文章；有 <strong>2篇</strong> Golang相关的。这算是对工作技能的一些总结。</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483909&amp;idx=1&amp;sn=91fd874327fcfb6e1c30f7f769bf0864&amp;chksm=e8080c22df7f8534fe75478cb03d7dfd7ca01f1419bd1c4a5c8b1d762e56e9513a5a650982e3&amp;scene=21#wechat_redirect" target="_blank" rel="external">走进Golang之运行与Plan9汇编</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483896&amp;idx=1&amp;sn=b4aade25df77872cf4f9c1457e3530e1&amp;chksm=e8080fdfdf7f86c938e8e1144f987157eb00f2583803b1b42f35a505f55596f4bb93b9bebaf6&amp;scene=21#wechat_redirect" target="_blank" rel="external">走进Golang之编译器原理</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483860&amp;idx=1&amp;sn=e8c63e79791216368da43521a8eb1da3&amp;chksm=e8080ff3df7f86e522edd1b6a465338a9d4a547a5c94c8d8e648afc917a02e77056ba45464db&amp;scene=21#wechat_redirect" target="_blank" rel="external">高并发架构的HTTP知识介绍</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483854&amp;idx=1&amp;sn=c5e860d64f98d1a108ff4e6434e8aff3&amp;chksm=e8080fe9df7f86ffb50b521b79507c8bd4b1613c4cb4144ee6e445d60bcf1c5743faa74eee11&amp;scene=21#wechat_redirect" target="_blank" rel="external">高并发架构的TCP知识的介绍</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483839&amp;idx=1&amp;sn=39167e6704703c5a2201b9d32bcd9d54&amp;chksm=e8080f98df7f868ebbae8b4be0e6f470c201193a64829556b81b5878f305fc058e7ce88d1e31&amp;scene=21#wechat_redirect" target="_blank" rel="external">高并发架构的CDN知识介绍</a></p>
<p>3篇协议相关的文章内容是相当干，面试、实际工作都很有用，不过标题当时定的有些招摇过市，不过当时是想的写一些列相关高并发相关的文章，结果写了3篇就半途而废，导致无法自圆其说，有人说我标题党，我也认。后面2篇是因为自己接触Golang有将近两三年的时间，希望通过<code>走进Golang</code>这一个系列来完成知识的回顾与深入。作为一个程序员最重要的就是语言、数据结构、算法，所以这个系列会坚持写下去。这两篇文章也在 <code>Go中国</code> 与 <code>Go语言中文网</code>获得转发，也算是对自己学习的一种认可。</p>
<p>还有一篇是 </p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzIyNDgxMTg0OA==&amp;mid=2247483876&amp;idx=1&amp;sn=7b9c92f01499b3588728663c2213673a&amp;chksm=e8080fc3df7f86d57758b5f5d8a4e00f8c1cb008a5c3a2f5f0a0fa4d6d89397f41f7aea251ca&amp;scene=21#wechat_redirect" target="_blank" rel="external">今天，应该为了明天而活</a></p>
<p>这篇文章算是一篇读后感《财富自由之路》；最近这几年读了很多关于投资理财的书籍，自己感觉也慢慢树立了自己的投资理念。从一开始随机买，随机卖；到现在有组合的概念。这其中有几本书起到至关重要的作用。</p>
<p>《财务自由之路》，《钱：7步创造终身收入》，《哈利.布朗的永久投资组合》</p>
<h1 id="关于理财"><a href="#关于理财" class="headerlink" title="关于理财"></a>关于理财</h1><p>上面说了最近几年看了很多理财的东西，我想关于这部分多说一点。首先是为什么要理财？不是为了暴富，是为了将来；因为你一旦开始理财就会养成储蓄的习惯，而为了让储蓄的钱不断产生价值，直到某个临界点实现理财收入全覆盖你的日常开支（这是我的目标）。为了让储蓄的钱不断产生收益，我们需要学习正确的方法来操作。要不然放进去的时候是1w，取出来变1k。</p>
<p>关于学习理财，强烈推荐上面的三本书，微信读书里边就有。当然你也可以通过下面的链接购买纸质版本。下面给大家看一下我自己搭建的两个投资组合的收益情况。</p>
<p>先来看看我自己设立的财务安全的组合（这个组合的意思是：未来收益可以覆盖我的生活支出，换句话说只要我的生活成本不变，这个组合可以让我不用工作）。</p>
<p><img src="https://dayutalk.cn/img/zongjie-01.jpeg" alt="财务安全"></p>
<p>这里边的组成主要是在且慢跟投的长赢计划，自己购买的几个指数基金组合，还有部分A股股票（这部分后面会用其它资产替换掉），以及部分港股打新收益。这个组合今年的最大回撤是 <code>3.87%</code>。</p>
<p><img src="https://dayutalk.cn/img/zongjie-02.jpeg" alt="宝宝小金库"></p>
<p>这一个组合是我将宝宝的所有零花钱给他存起来。宝宝是今年九月份出生的，所以目前这个组合实际情况还有待检验。这是完全按照《哈利.布朗的永久投资组合》提供的组合来创建的，股票、黄金、债券、现金各占25%。目前为止的最大回撤是 <code>0.76%</code>，当然这个数据由于时间太短没什么参考价值，明年再看。</p>
<p>对于每一个人，我觉得理财首先是必须要去做的，而且越早越好，并且理财中的学习过程非常有趣。这里推荐给大家一个桥水基金老大 <strong>Ray Dalio</strong> 的一个关于经济机器是怎样运行的视频，大家感受一下。</p>
<iframe src="//player.bilibili.com/player.html?aid=52328643&cid=91586931&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h1 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h1><p>说完了公众号、理财，最后谈一谈工作。</p>
<p>今年在公司的每一件任务基本上都完成了，距离2019年初定的OKR也基本达成；但是反思一下工作中其实有很多做得不够好，或者说自己感觉到乏力；因为涉及的人越来越多，想把每一件事情做到精致该如去保证？自己也在不断探索如何去提高自己。现在真的是有点明白，为什么大公司喜欢收购。</p>
<p>总的来说2019年的工作都比较顺利，完成了一次晋升、一次涨薪，但是做的事情基本上都还在我的舒适区。</p>
<p>工作是大多数人创造美好生活的唯一途径，也是证明自己价值的一个最佳平台；该如何发挥自己的价值？公司不会适应你，只能自己去适应公司（或者找到与自己个性匹配的公司，不过可能性为0）。如何在规则既定的前提下最大化公司与个人价值，我想我得在2020年继续去探索。</p>
<h1 id="2020，你好"><a href="#2020，你好" class="headerlink" title="2020，你好"></a>2020，你好</h1><p>2019最幸福的事情不过于宝宝的诞生，宝宝的诞生让每一件事情都有了不一样的意义；2019最多的纠结是公司要求的能力与自己想要提高的能力发生冲突；2019最大的收获是对于学习方法有了新的认知，也在不断受益于此。</p>
<p>2020年工作上希望自己有机会有能力去挑战一些舒适区之外的事情，总要做一些一眼看不到结果、未知不可预测的事情才会更有意思。</p>
<p>理财上继续学习、按照现有的策略不断执行检查、调整更适合自己的方法。</p>
<p>技术上2020年最重要的就是把<code>走进Golang</code>这个技术系列写完，然后<code>Skr Shop</code>这个业务系列不断更新，简单定个计划的话每个月两种类型各1篇，一年算下来也有24篇文章（不知道明年底会不会打脸😂）。</p>
<p>最后想说读书真的很重要，因为只有读书才能打开视野，看到不一样的东西。当然如果你有机会实战那就更棒了！2020相信我们都会更棒。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[购物车设计之需求分析]]></title>
      <url>http://dayutalk.cn/2019/12/09/%E8%B4%AD%E7%89%A9%E8%BD%A6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>有人说，年底了还不更新？这不，skr shop购物车系列更新啦！久等了^-^<br><a id="more"></a></p>
<blockquote>
<p>skr shop是一群底层码农，由于被工作中的项目折磨的精神失常，加之由于程序员的自傲：别人设计的系统都是一坨shit，我的设计才是宇宙最牛逼，于是乎决定要做一个只设计不编码的电商设计手册。</p>
</blockquote>
<p><strong>项目地址：<a href="https://github.com/skr-shop/manuals" target="_blank" rel="external">https://github.com/skr-shop/manuals</a></strong></p>
<p>对于一个电商来讲，购物车是整个购买流程最重要的一步。因为电商发展到今天购物车不仅仅只是为了完成打包下单的功能；也是收藏、对比、促销提醒、相关推荐的重要展示窗口。如此多的能力我们该如何设计保证购物车的高性能、以及良好的扩展能力来满足未来的发展呢？</p>
<p>今天开始我们就以一个假定的场景来输出一个购物车设计：某某电商平台，是一个多租户模式（我们前面的诸多设计都是多租户模式），用户可以把商品加入到购物车，并切按照商户纬度来展示、排序。当然购物车也支持常规的各种操作：选择、删除、清空、商品失效等。并且有相关的促销能够提醒用户。同时为了监控、运营，要支撑购物车数据同步到监控、数仓等能力。</p>
<p>本文会从用户使用的角度以及服务端两个角度来讲解系统的能力。本篇我们的主要目的是说清楚购物车的能力以及一些逻辑。下一篇会进行购物车模型设计以及接口定义。</p>
<h1 id="用户视角"><a href="#用户视角" class="headerlink" title="用户视角"></a>用户视角</h1><p>我们先来定义一下在用户侧用户操作购物车的功能有哪些？</p>
<p><img src="https://dayutalk.cn/img/user-cart-c.png" alt="用户则需求"></p>
<p>一个购物车基本的能力基本上都在上图中，下面我们一一来分解。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>我们从用户的角度来看，购物车对于用户来说可以添加商品到购物车（加购物车、立即购买都属于一种添加方式）；加入进购物车后，不想要了可以删除该商品（删一个、删多个、清空）；想多买可以修改购买数量，发现钱不够可以减少购买数量；或者发现红色的比白色更漂亮，可以在购物车方便的进行更换规格；对于一些价格很贵的商品，能够在购物车添加一些保障服务（其实是绑定的虚拟商品）；在要去结算的时候，还会提供选择能力让用户决定哪些商品真的本次要购买。</p>
<p>通过上面的描述我们可以看到这个过程是有其内在联系的。这里说一下关于选中功能，业界有两种做法，各有优劣，我们来看一下。淘宝的产品选中状态是保存在客户端的，并且默认不选中，刷新、重新打开APP状态会消失；京东、苏宁这一类是保存在服务端，会记录用户选中状态。针对这两种情况各有优劣。</p>
<p><strong>客户端：</strong></p>
<ol>
<li>性能，选中/不选中的逻辑直接放在本地做，减少网络请求</li>
<li>体验，多端不能同步，但是购物车相对来说更像是一个收藏夹，每次用户自己选择也无可厚非</li>
<li>计算，价格计算时需要上传本地选中商品（也可以本地计算）</li>
<li>实现，主要靠客户端实现，与服务端无关，研发解耦合</li>
</ol>
<p><strong>服务端：</strong></p>
<ol>
<li>性能，每次操作选中都需要调用服务端，而该操作可能很频繁，除了网络损耗，服务端也需要考虑该如何快速找到修改的商品</li>
<li>体验，多端同步状态，记录历史状态</li>
<li>计算，服务端可获取数据，请求时无须上传额外数据</li>
<li>实现，服务端与客户端需要商定如何交互，以及返回数据（每次选中会导致价格变化），耦合在一起</li>
</ol>
<p>个人认为这两种方式并无谁具备明显优势，完全是一种基于业务模式以及团队情况来做选择。我们这里后续的设计会基于在服务端保存商品选中状态。</p>
<p>在整个操作逻辑中，有个两个比较重要的地方单独说明一下：购买方式与购物车内修改购买属性</p>
<h3 id="购买方式"><a href="#购买方式" class="headerlink" title="购买方式"></a>购买方式</h3><p>主要的购买方式有立即购买、加入购物车、拼团购三种方式。</p>
<p>首先普通的加入购物车没什么太多要说的。重点来看下立即购买与拼团。</p>
<p>立即购买在于操作上来说就是选择商品后直接到了订单确认页面，没有购物车中去结算这一步。但是它的实现却可以依赖购物车的逻辑来做，我们来看一下使用购物车与不使用购物车实现这个逻辑有什么差别？</p>
<p>如果使用购物车来实现，也就是用户点击立即购买时，商品本质上还是加入到购物车中，但这个购物车却与原型的购物车不同，因为该购物车只能加一个商品，并且每次操作都会被覆盖。在视角效果上也是直接从商品详情页面跳转到订单确认页面。来看看这种方式的好处</p>
<ol>
<li>与购物车在订单确认、下单逻辑上一致，内部可以直接通过购物车获取数据</li>
<li>需要一个独立的专门用于一键购买的购物车来实现，内存有消耗</li>
</ol>
<p>另外一种实现方式使用一个新的数据结构，因为一般来说一键购买更简单，它只需要商品信息、价格信息即可。每次交互均可以根据sku_id来获取。</p>
<ol>
<li>订单确认、下单逻辑上需要进行改造，每次请求之间要传递约定参数</li>
<li>节省内存，上下交互通过sku_id来保证</li>
</ol>
<p>我们会采用使用在服务端一键购买以独立的购物车形式来实现。购物车的数据模型一致，保证了后续处理流程上的一致。</p>
<p>对于拼团，他其实分为两部分，首先是开团这个动作，当团成立后。我们可以选择将成团的商品加入普通购物车，同时可以加购其它商品。也可以选择将成团商品加入一键购买的购物车，保证成团商品只能买一个。拼团模式更像是加入购物车的一个前置条件。本质上它对于购物车的设计没有影响。</p>
<h3 id="购物车内修改购买属性"><a href="#购物车内修改购买属性" class="headerlink" title="购物车内修改购买属性"></a>购物车内修改购买属性</h3><p>这里主要是指可以在购物车便捷的操作一些需要在spu纬度操作的事情，比如：变更规格（也就是更换sku），以及选择绑定到spu纬度的服务（保险、延保等）。</p>
<p>我们重点说一下选择绑定的服务。例如：我们买一个手机，厂家提供了延保、各种其它附加服务，一般情况这种服务都是虚拟商品。但是这有个特殊情况。这些保障服务首先不能单独购买，其次他是跟主商品的数量息息相关。比如买两个手机，如果选择了加购服务，那么这些服务的数量必须是2，这会是一个联动关系。</p>
<p>这些保障服务是不能进行单独购买的，它一定要跟特定的商品捆绑销售。</p>
<p>服务端在存储这部分数据时一定需要考虑如何保存这种层级关系，这部分我们后面模型设计的时候大家会看到。</p>
<p><img src="https://dayutalk.cn/img/product-relations.png" alt="绑定商品关系"></p>
<h2 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h2><p>促销提醒很简单，返回的购物车数据，每一个商品应该携带当前的促销信息。这部分重点在于怎么获取促销信息，会在服务端看到。</p>
<p>然后说下购物车数量的提醒，也就是显示当前购物车商品的数量。一般来说进入到APP就会调用一个接口，获取用户的未读消息数、购物车商品数等。这里是需要非常高的读取速度。那么这种需求该如何满足呢？</p>
<p><strong>方案一：</strong> 我们可以设计一个结构保存了用户相关的这种提醒信息数量，每次直接读取这个数据即可。不需要去跟消息服务、购物车服务打交道拿这些数据。</p>
<p><strong>方案二：</strong> 在消息、购物车的模型中均设计一个保存总数量的字段，在读取数据的接口中，通过并发的方式调用这些服务拿到数据后进行聚合，这样在速度上只取决于最慢的服务。</p>
<p>这里我们的设计会采用 <strong>方案二</strong>，因为这样在某种程度上效率可以得到保证，同时整个系统的结构数据的一致性更容易得到保障。当然这里有个细节一定要注意，并发读取一定要设计超时，不要因为某个服务读数问题而导致拖累整个接口的性能。</p>
<p>接下来再来看看促销，这部分除了提醒，还需要提供对应的入口，让用户完成促销的操作。比如说某个商品有券，那么可以直接提供入口去领取；可凑单，有入口进入凑单列表并选择商品等。这部分需要解决的问题是服务端该如何及时从商品纬度拿到这些促销活动。</p>
<p>从用户的视角看完了，我们再来站在研发的角度看看服务端有哪些事情要做</p>
<h1 id="研发视角"><a href="#研发视角" class="headerlink" title="研发视角"></a>研发视角</h1><p>还是先来看看需求的汇总图：</p>
<p><img src="https://dayutalk.cn/img/user-cart-s.png" alt="服务端则需求"></p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>对于存储，首选肯定是内存存储，至于要不要落库，我觉得没有必要。说下我的理由：</p>
<ol>
<li>购物车的数据相对变化非常频繁，落库成本比较高，如果异步方式落库，很难保障一致性</li>
<li>极端情况，cache奔溃了，仅仅需要用户重新加入购物车，并且我们可以通过cache的持久化机制来保证数据的恢复</li>
</ol>
<p>所以对于购物车，我们只会把数据完全保存在内存中。</p>
<h2 id="商品销售类型发生变化"><a href="#商品销售类型发生变化" class="headerlink" title="商品销售类型发生变化"></a>商品销售类型发生变化</h2><p>现在我们来讨论 <strong>商品销售类型发生变化</strong> 这个问题。这是什么意思呢？大家想一下：比如我把A商品加入到购物车，但是一直没有结算。这时运营说针对A商品搞一个活动，拿出10个库存5折购。那么问题来了，对于之前购物车中就有该商品的用户该如何处理？<strong>这里解决的主要问题是：购物车有该商品的用户不能直接以5折买</strong>。几种方案，我们来看一下：</p>
<p><strong>方案一：</strong> 促销配置后，所有购物车中有该商品的用户失效或删除，这个方案首先被pass，操作成本太高，并且用户体验差</p>
<p><strong>方案二：</strong> 购物车中要区分同一个SKU，不同销售类型。也就是说在我们的购物车中不是按照SKU的纬度来加商品，而是通过 <strong>SKU+售卖类型</strong> 来生成一个唯一识别码。</p>
<p>可以看到 <strong>方案二</strong> 解决了同一个sku在购物车并存的问题，并且库存之前互相不影响。不过这里又有一个问题？商品的售卖类型（或者说这个标记），该怎么什么地方设置？好像商品系统可以设计、促销系统也可以设置。我们的逻辑中会在促销系统中进行配置。因为商品属于基础逻辑，如果一改就是全局库存受到影响。活动结束后很难做到自动正常售卖。因此这个标记应该落到活动中进行设置（活动设置时会通过促销系统获取该商品之前的活动是否互斥，以确保配置的活动不会互相矛盾）。</p>
<h2 id="依赖系统"><a href="#依赖系统" class="headerlink" title="依赖系统"></a>依赖系统</h2><p>购物车系统依赖了非常多的其它系统。</p>
<ul>
<li>商品系统</li>
<li>库存系统</li>
<li>促销系统</li>
<li>结算系统</li>
</ul>
<p>这些依赖的系统，有的是为了传输数据，有的是为了获取数据。我们按照这两个纬度来看一下。</p>
<h3 id="促销提醒与计算"><a href="#促销提醒与计算" class="headerlink" title="促销提醒与计算"></a>促销提醒与计算</h3><p>服务端要解决的是促销的提醒与价格计算问题。</p>
<p>现来说计算，针对这部分最佳的方式是，调用结算中心的价格计算。我们来看一下购物车中的价格计算与订单结算时的价格计算的差异。</p>
<p>首先购物车中计算价格时不知道用户的地址，这会影响运费的计算；再是不知道用券的情况。那么其实如果解决了这两个问题，我们就可以让价格计算出自同一个逻辑，仅仅是部分入参不同罢了。因此我们这里计算时可以按照最高运费来计算，同时用券默认在购物车都不使用券。对于促销问题这里是可以通过促销系统确认选中的商品可以享受哪些价格的。因此促销的价格应该计算在内。</p>
<p>接下来在再来说说如何为用户高效的提供促销的信息。先从我们的配置视野出发。</p>
<p>我们在配置一个促销活动或者发一张券时，都是将多个商品归到一个促销活动或者券的下面。如果按照活动、券的纬度来获取商品效率相对比较高。</p>
<p><img src="https://dayutalk.cn/img/activity-product.png" alt="活动-商品"></p>
<p>但是在购物车的场景中发生了一个变化。我们是需要从商品纬度获取到该商品的所有活动信息（全平台活动、店铺活动）；<br>那么购物车中为了展示这些信息该怎么做？很常规的一个做法（也确实不少公司是这样）：把所有活动信息取出来，遍历出所有跟该商品相关的信息。这种做法效率很低，并且无法满足大规模的应用场景，比如双十一期间。</p>
<p>因此这里为了满足该需求，促销系统需要提供一个能力按照商品获取对应促销（活动、券）。因此一般来讲促销系统配置的活动不能仅仅是按照活动纬度存储，同时还需要生成一份商品纬度的促销信息。</p>
<p><img src="https://dayutalk.cn/img/product-activity.png" alt="商品-活动"></p>
<h2 id="购物车数据分析"><a href="#购物车数据分析" class="headerlink" title="购物车数据分析"></a>购物车数据分析</h2><p>对于购物车数据来说，前端会通过埋点记录加入购物车数据的情况，但是前端埋点一般是记录触发了某个前端操作，但是并不知道该操作是否成功与否。以及无法及时了解当前整体购物车的数据情况。</p>
<p>为了让运营团队更完整的了解购物车当前情况，我们通过后端打本地日志，然后通过日志收集的方式将日志同步给数据、监控等服务。</p>
<h2 id="失效与排序"><a href="#失效与排序" class="headerlink" title="失效与排序"></a>失效与排序</h2><p>还有两个小部分没有讲到，一是商品该如何失效，比如：库存没有了、下架了；二是购物车中的商品是多个店铺的，排序的策略是什么？</p>
<p>由于本文我们还只是讨论需求，不涉及具体的模型设计，因此只是介绍方案。首先是商品失效，这很像一个软删除操作，一旦设置，用户侧看到的商品将是无法进行结算的，只能进行删除操作。</p>
<p>对于排序我们会采用的设计是：根据某个店铺在购物车中最后发生操作的时间，最新的操作肯定在最上面。</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>通过上面我们基本上搞清楚了购物车设计中我们要做什么，依赖的系统要提供什么能力。下篇开始进入数据模型的设计、前后端接口设计。</p>
<p>如果你对购物车上面的需求还有哪些补充，欢迎留言。我们一起来完善。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[走进Golang之运行与Plan9汇编]]></title>
      <url>http://dayutalk.cn/2019/11/09/%E8%B5%B0%E8%BF%9BGolang%E4%B9%8B%E8%BF%90%E8%A1%8C%E4%B8%8EPlan9%E6%B1%87%E7%BC%96/</url>
      <content type="html"><![CDATA[<p>费了老大劲，又搞定了一篇，很长看完需要耐心。如果不想看，一定要看看第五张图，对函数执行过程非常有帮助。</p>
<a id="more"></a>
<p>本文目录速览：</p>
<ul>
<li><a href="#Golang的运行环境">Golang的运行环境</a><ul>
<li><a href="#内存">内存</a></li>
<li><a href="#操作系统、CPU、内存互相配合">操作系统、CPU、内存互相配合</a></li>
</ul>
</li>
<li><a href="#Go程序的调用规约">Go程序的调用规约</a><ul>
<li><a href="#函数在栈上的分布">函数在栈上的分布</a></li>
<li><a href="#Go的调用实例">Go的调用实例</a></li>
</ul>
</li>
<li><a href="#Go的汇编plan9">Go的汇编plan9</a><ul>
<li><a href="#查看go应用代码对应的翻译函数">查看go应用代码对应的翻译函数</a></li>
<li><a href="#逃逸分析">逃逸分析</a></li>
<li><a href="#传值还是传指针">传值还是传指针</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<p>通过上一篇<a href="https://dayutalk.cn/2019/10/24/%E8%B5%B0%E8%BF%9BGolang%E4%B9%8B%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86/">走进Golang之汇编原理</a>，我们知道了目标代码的生成经历了那些过程。今天我们一起来学习一下生成的目标代码如何在计算机上执行。以及通过查阅 <code>Golang</code> 的 Plan9 汇编来了解Golang的一些内部秘密。</p>
<h1 id="Golang的运行环境"><a href="#Golang的运行环境" class="headerlink" title="Golang的运行环境"></a>Golang的运行环境</h1><p>当我们把编译后的Go代码运行起来，它会以进程的方式出现在系统中。然后开始处理请求、数据，我们会看到这个进程占用了内存消耗、cpu占比等等信息。本文就是要来解释在程序的运行过程中，内存、CPU、操作系统（当然还有其它的硬件，文中关系不大，就不说了）是如何进行配合，完成了我们代码所指定的事情。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>首先，我们先来说说内存。先来看一个我们运行的go进程。</p>
<p>代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, sayHello)</span><br><span class="line"></span><br><span class="line">	err := http.ListenAndServe(<span class="string">":9999"</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"fibonacci: %d\n"</span>, fibonacci(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">	_, _ = fmt.Fprint(w, <span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> num &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fibonacci(num<span class="number">-1</span>) + fibonacci(num<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下执行情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayu.com &gt;ps aux</span><br><span class="line"></span><br><span class="line">USER               PID   %CPU  %MEM      VSZ     RSS    TT  STAT   STARTED    TIME     COMMAND</span><br><span class="line">xxxxx              3584  99.2  0.1     4380456  4376   s003  R+    8:33下午   0:05.81  ./myhttp</span><br></pre></td></tr></table></figure>
<p>这里我们先来不关注其它指标，先来看 <code>VSZ</code> 与 <code>RSS</code>。</p>
<ul>
<li>VSZ: 是指虚拟地址，他是程序实际操作的内存。包含了分配还没有使用的内存。</li>
<li>RSS: 是实际的物理内存，包含了栈内存与堆内存。</li>
</ul>
<p>每一个进程都是运行在自己的内存沙盒里，程序被分配的地址都是 “虚拟内存”，物理内存对程序开发者来说实际是不可见的，而且虚拟地址比进程实际的物理地址要大的多。我们经常编程中取指针对应的地址实际就是虚拟地址。这里一定要注意区分虚拟内存与物理内存。来一张图感受一下。</p>
<p><img src="https://dayutalk.cn/img/go-hb-0.jpg" alt="虚拟内存与物理内存"></p>
<p>这张图主要是为了说明两个问题：</p>
<ol>
<li>程序使用的是虚拟内存，但是操作系统会把虚拟内存映射到物理内存；你会发现自己机器上所有进程的 VSZ 总和要比实际物理内存大得多；</li>
<li>物理内存可以被多个进程共享，甚至一个进程内的不同地址可能映射的都是同一个物理内存地址。</li>
</ol>
<p>上面搞明白了程序中的内存具体是指什么，接下来说明程序是如何使用内存的（虚拟内存），内存说白了就是比硬盘存取速度更快的一个硬件，为了方便内存的管理，操作系统把分配给进程的内存划分成了不同的功能块。像我们经常说的：代码区，静态数据区，堆区，栈区等。</p>
<p>这里借用一张网络上的图来看一下。</p>
<p><img src="https://dayutalk.cn/img/go-hb-1.jpeg" alt="go语言内存的划分"></p>
<p>这里就是我们程序（进程）在虚拟内存中的分布。</p>
<p>代码区：存放的就是我们编译后的机器码，一般来说这个区域只能是只读。</p>
<p>静态数据区：存放的是全局变量与常量。这些变量的地址编译的时候就确定了（这也是使用虚拟地址的好处，如果是物理地址，这些地址编译的时候是不可能确定的）。Data与BSS都属于这一部分。这部分只有程序中止（kill掉、crasg掉等）才会被销毁。</p>
<p>栈区：主要是 <code>Golang</code> 里边的函数、方法以及其本地变量存储的地方。这部分伴随函数、方法开始执行而分配，运行完后就被释放，特别注意这里的释放并不会清空内存。后面文章讲内存分配的时候再详细说；还有一个点需要记住栈一般是从高地址向低地址方向分配，换句话说：高地址属于栈低，低地址属于栈顶，它分配方向与堆是相反的。</p>
<p>堆区：像 <code>C/C++</code> 语言，堆完全是程序员自己控制的。但是 <code>Golang</code> 里边由于有GC机制，我们写代码的时候并不需要关心内存是在栈还是堆上分配。<code>Golang</code> 会自己判断如果变量的生命周期在函数退出后还不能销毁或者栈上资源不够分配等等情况，就会被放到堆上。堆的性能会比栈要差一些。原因也留到内存分配相关的文章再给大家介绍。</p>
<p>内存的结构搞明白了，我们的程序被加载到内存还需要操作系统来指挥才能正确运行。</p>
<p>补充一个比较重要的概念：</p>
<blockquote>
<p>寻址空间：一般指的是CPU对于内存寻址的能力，通俗地说，就是能最多用到多少内存的一个问题。比如：32条地址线（32位机器），那么总的地址空间就有 2^32 个，如果是64位机器，就是 2^64 个寻址空间。可以使用 <code>uname -a</code> 来查看自己系统支持的位数字。</p>
</blockquote>
<h2 id="操作系统、CPU、内存互相配合"><a href="#操作系统、CPU、内存互相配合" class="headerlink" title="操作系统、CPU、内存互相配合"></a>操作系统、CPU、内存互相配合</h2><p>为了讲清楚程序运行与调用，我们得先理清楚操作系统、内存、CPU、寄存器这几者之间的关系。</p>
<ul>
<li>CPU: 计算机的大脑，它才能理解并执行指令；</li>
<li>寄存器：严格讲寄存器是CPU的组成部分，它主要负责CPU在计算时临时存储数据；当然CPU还有多级的高速缓存，与我们这里相关度不大，就略过，大家知道其目的是为了弥补内存与CPU速度的差距即可；</li>
<li>内存：像上面内存被划分成不同区，每一部分存了不同的数据；当然这些区的划分、以及虚拟内存与物理内存的映射都是操作系统来做的；</li>
<li>操作系统：控制各种硬件资源，为其它运行的程序提供操作接口（系统调用）及管理。</li>
</ul>
<p>这里操作系统是一个软件，CPU、寄存器、内存（物理内存）都是实打实的硬件。操作系统虽然也是一堆代码写出来的。但是她是硬件对其它应用程序的接口。总的来讲操作系统通过系统调用控制所有的硬件资源，他把其它的程序调度到CPU上让其它程序执行，但是为了让每个程序都有机会使用CPU，CPU又通过时间中断把控制权交给操作系统。</p>
<p>让操作系统可以控制我们的程序，我们编写的程序需要遵循操作系统的规定。这样操作系统才能控制程序执行、切换进程等操作。</p>
<p>最后我们的代码被编译成机器码之后，本质就是一条条的指令。我们期望的就是CPU去执行完这些指令进而完成任务。而操作系统又能够帮助我们让CPU来执行代码以及提供所需资源的调用接口（系统调用）。是不是非常简单？</p>
<h1 id="Go程序的调用规约"><a href="#Go程序的调用规约" class="headerlink" title="Go程序的调用规约"></a>Go程序的调用规约</h1><p>在上面我们知道整个虚拟内存被我们划分为：代码区、静态数据区、栈区、堆区。接下来要讲的Go程序的调用规约（其实就是函数、方法运行的规则），主要是涉及上面所说的栈部分（堆部分会在内存分配的文章里边去讲）。以及计算机软硬各个部分如何配合。接下来我们就来看一下程序的基本单位函数跟方法是怎么执行与相互调用的。</p>
<h2 id="函数在栈上的分布"><a href="#函数在栈上的分布" class="headerlink" title="函数在栈上的分布"></a>函数在栈上的分布</h2><p>这一部分，我们先来了解一些理论，然后接着用一个实际的例子来分析一下。先通过一张图来看一下在 <code>Golang</code> 中函数是如何在栈上分布的。</p>
<p>几个涉及到的专业用语：</p>
<ul>
<li>栈：这里说的栈跟上面的解释含义一致。无论是进程、线程、goroutine都有自己的调用栈；</li>
<li>栈帧：可以理解是函数调用时在栈上为函数所分配的区域；</li>
<li>调用者：caller，比如：a函数调用了b函数，那么a就是调用者</li>
<li>被调者：callee，还是上面的例子，b就是被调者</li>
</ul>
<p><img src="https://dayutalk.cn/img/go-hb-2.png" alt="栈帧"></p>
<p>这幅图所展示的就是一个 <code>栈帧</code> 的结构。也可以说栈桢是栈给一个函数分配的栈空间，它包括了函数调用者地址、本地变量、返回值地址、调用者参数等信息。</p>
<p>这里有几个注意点，图中的 <code>BP</code>、<code>SP</code>都表示对应的寄存器。</p>
<ul>
<li>BP：基址指针寄存器(extended base pointer)，也叫帧指针，存放着一个指针，表示函数栈开始的地方。</li>
<li>SP：栈指针寄存器(extended stack pointer)，存放着一个指针，存储的是函数栈空间的栈顶，也就是函数栈空间分配结束的地方，注意这里是硬件寄存器，不是Plan9中的伪寄存器。</li>
</ul>
<p><code>BP</code> 与 <code>SP</code> 放在一起，一个表示开始（栈顶）、一个表示结束（栈低）。</p>
<p>有了上面的基础知识，接着下面用实际的例子来验证一下。</p>
<h2 id="Go的调用实例"><a href="#Go的调用实例" class="headerlink" title="Go的调用实例"></a>Go的调用实例</h2><p>才开始，我们就从一个简单的函数开始来分析一下整个函数的调用过程（下面涉及到 <code>Plan9</code> 汇编，请别慌，大部分都能够看懂，并且我也会写注释）。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">3</span></span><br><span class="line">	b := <span class="number">2</span></span><br><span class="line">	returnTwo(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnTwo</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(c, d <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	tmp := <span class="number">1</span> <span class="comment">// 这一行的主要目的是保证栈桢不为0，方便分析</span></span><br><span class="line">	c = a + b</span><br><span class="line">	d = b - tmp</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面有两个函数，<code>main</code> 定义了两个本地变量，然后调用 <code>returnTwo</code> 函数。<code>returnTwo</code> 函数有两个参数与两个返回值。设计两个返回值主要是一起来看一下 <code>golang</code> 的多返回值是如何实现的。接下来我们把上面的代码对应的汇编代码展示出来。</p>
<p><img src="https://dayutalk.cn/img/go-hb-3.png" alt="main函数"></p>
<p>有几行代码需要特别解释下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00000 (test1.go:3)       TEXT    &quot;&quot;.main(SB), ABIInternal, $56-0</span><br></pre></td></tr></table></figure>
<p>这一行中的重点信息：<code>$56-0</code>。<strong>56</strong> 表示的该函数栈桢大小（两个本地变量，两个参数是int类型，两个返回值是int类型，1个保存base pointer，合计7 * 8 = 56）；0表示 <code>mian</code> 函数的参数与返回值大小。待会可以在 <code>returnTwo</code> 中去看一下它的返回值又是多少。</p>
<p>接下来在看一下计算机是怎么在栈上分配大小的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x000f 00015 (test1.go:3)       SUBQ    $56, SP // 分配，56的大小在上面第一行定义了</span><br><span class="line">... ...</span><br><span class="line">0x004b 00075 (test1.go:7)       ADDQ    $56, SP // 释放掉，但是并未清空</span><br></pre></td></tr></table></figure>
<p>这两行，一个是分配，一个是释放。为什么用了 <code>SUBQ</code> 指令就能进行分配呢？而 <code>ADDQ</code> 是释放？记得我们前面说过吗？ <code>SP</code> 是一个指针寄存器，并且指向栈顶，栈又是从高地址向低地址分配。那么对它做一次减法，是不是表示从高地址向低地址方向移动指针了呢？释放也是同样的道理，一次加法操作又把 <code>SP</code> 恢复到初始状态。</p>
<p>再来看一下对 <code>BP</code> 寄存器的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0013 00019 (test1.go:3)       MOVQ    BP, 48(SP) // 保存BP</span><br><span class="line">0x0018 00024 (test1.go:3)       LEAQ    48(SP), BP // BP存放了新的地址</span><br><span class="line">... ...</span><br><span class="line">0x0046 00070 (test1.go:7)       MOVQ    48(SP), BP // 恢复BP的地址</span><br></pre></td></tr></table></figure>
<p>这三行代码是不是感觉很变扭？写来写去让人云里雾里的。我先用文字描述一下，后面再用图来解释。</p>
<blockquote>
<p>我们先做如下假设：此时 BP 指向的 <strong>值</strong> 是：0x00ff，48(SP) 的 <strong>地址</strong> 是：0x0008。</p>
</blockquote>
<ul>
<li>第一条指令 <code>MOVQ    BP, 48(SP)</code> 是把 <code>0x00ff</code> 写入到 <code>48(SP)</code>的位置；</li>
<li>第二条指令 <code>LEAQ    48(SP), BP</code> 是更新寄存器指针，让 <code>BP</code> 保存 <code>48(SP)</code> 这个位置的地址，也就是 <code>0x00ff</code> 这个值。</li>
<li>第三条指令 <code>MOVQ    48(SP), BP</code> ，因为一开始 <code>48(SP)</code> 保存了最开始 <code>BP</code> 的所存的值 <code>0x00ff</code>，所以这里是又把 <code>BP</code> 恢复回去了。</li>
</ul>
<p>这几行代码的作用至关重要，正因为如此在执行的时候，我们才能找到函数开始的地方以及回到调用函数的位置，它才可以继续往下执行（如果觉得饶，先放过，后面有图，看完后再回来理解）。接着来看一下 <code>returnTwo</code> 函数。</p>
<p><img src="https://dayutalk.cn/img/go-hb-4.png" alt="returnTwo函数汇编"></p>
<p>这里 <code>NOSPLIT|ABIInternal, $0-32</code> 说明，该函数的栈桢大小是0，由于有两个int参数，以及2个int返回值，合计为 <code>4*8 = 32</code> 字节大小，是不是跟上面的 <code>main</code> 函数对上了？。</p>
<p>这里有没有对 <code>returnTwo</code> 函数的栈桢大小是0表示迷惑呢？难道这个函数不需要栈空间吗？其实主要原因是：golang的参数传递与返回值都是要求使用栈来进行的（这也是为什么go能够支持多参数返回的原因）。所以参数与返回值所需空间都由 <code>caller</code> 来提供。</p>
<p>接下来，我们用完整的图来演示一下这个调用过程。</p>
<p><img src="https://dayutalk.cn/img/go-hb-5.png" alt="函数调用"></p>
<blockquote>
<p>这个图就画了将近1个小时，希望对大家理解有帮助。</p>
</blockquote>
<p>整个的流程是：初始化 —-&gt; call main function —-&gt; call returnTwo function —-&gt; returnTwo return —-&gt; main return。</p>
<p>通过这张图，在结合我上面的文字解释，相信大家能够理解了。不过这里还有几个注意点：</p>
<ul>
<li><strong>BP</strong> 与 <strong>SP</strong> 是寄存器，它保存的是栈上的地址，所以执行中可以对 <code>SP</code> 做运算找到下一个指令的位置；</li>
<li>栈被回收 <code>ADDQ    $56, SP</code> ，只是改变了 <code>SP</code> 指向的位置，内存中的数据并不会清空，只有下次被分配使用的时候才会清空；</li>
<li>callee的参数、返回值内存都是caller分配的；</li>
<li>returnTwo ret的时候，<strong>call returnTwo的next指令</strong> 所在栈位置会被弹出，也就是图中 <code>0x0d00</code> 地址所保存的指令，所以 returnTwo 函数返回后，<code>SP</code> 又指向了 <code>0x0d08</code> 地址。</li>
</ul>
<hr>
<p>由于上面涉及到一些 <code>Plan9</code> 的知识，就顺带一起介绍一些它的语法，如果直接讲语法会很枯燥，下面会结合一些实际中会用到的情况来介绍。既有收获又能学会语法。</p>
<h1 id="Go的汇编plan9"><a href="#Go的汇编plan9" class="headerlink" title="Go的汇编plan9"></a>Go的汇编plan9</h1><p>我们整个程序的编译最终会被翻译成机器码，而汇编可以算是机器码的文本形式，他们之间可以一一对应。所以如果我们能够看懂汇编一点点就能够分析出很多实际问题。</p>
<p>开发go语言的都是当前世界最TOP的那群程序员，他们选择了持续装逼，不用标准的 <strong>AT&amp;T</strong> 也不用 <strong>Intel</strong> 汇编器，偏要自己搞一套，没办法，谁让人家牛呢！Golang的汇编是基于 <code>Plan9</code> 汇编的，个人觉得要完全学懂太复杂了，因为这涉及到很多底层知识。不过如果只是要求看懂还是能够做到的。下面我们就举一些例子来试试看。</p>
<blockquote>
<p>PS: 这东西完全学懂也没有必要，投入产出比太低了，对于一个应用工程师能够看懂就行。</p>
</blockquote>
<p>在正式开始前，我们还是补充一些必要信息，上文已经涉及过一些，为了完整这里在整体介绍一下。</p>
<p><strong>几个重要的伪寄存器：</strong></p>
<ul>
<li>SB：是一个虚拟寄存器，保存了静态基地址(static-base) 指针，即我们程序地址空间的开始地址；</li>
<li>NOSPLIT：向编译器表明不应该插入 <code>stack-split</code> 的用来检查栈需要扩张的前导指令；</li>
<li>FP：使用形如 symbol+offset(FP) 的方式，引用函数的输入参数；</li>
<li>SP：plan9 的这个 SP 寄存器指向当前栈帧的局部变量的开始位置，使用形如 symbol+offset(SP) 的方式，引用函数的局部变量，注意：这个寄存器与上文的寄存器是不一样的，这里是伪寄存器，而我们展示出来的都是硬件寄存器。</li>
</ul>
<p>其它还有一些操作指令，根据名字多半都能够看出来，就不再介绍，直接开始干。</p>
<h2 id="查看go应用代码对应的翻译函数"><a href="#查看go应用代码对应的翻译函数" class="headerlink" title="查看go应用代码对应的翻译函数"></a>查看go应用代码对应的翻译函数</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line"><span class="string">""</span>.test STEXT size=<span class="number">151</span> args=<span class="number">0x18</span> locals=<span class="number">0x40</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       TEXT    <span class="string">""</span>.test(SB), ABIInternal, $<span class="number">64</span><span class="number">-24</span> <span class="comment">// 栈帧大小，与参数、返回值大小</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       MOVQ    (TLS), CX</span><br><span class="line">        <span class="number">0x0009</span> <span class="number">00009</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       CMPQ    SP, <span class="number">16</span>(CX)</span><br><span class="line">        <span class="number">0x000d</span> <span class="number">00013</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       JLS     <span class="number">141</span></span><br><span class="line">        <span class="number">0x000f</span> <span class="number">00015</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       SUBQ    $<span class="number">64</span>, SP</span><br><span class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       MOVQ    BP, <span class="number">56</span>(SP)</span><br><span class="line">        <span class="number">0x0018</span> <span class="number">00024</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       LEAQ    <span class="number">56</span>(SP), BP</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="number">0x001d</span> <span class="number">00029</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       MOVQ    $<span class="number">0</span>, <span class="string">""</span>.~r0+<span class="number">72</span>(SP)</span><br><span class="line">        <span class="number">0x0026</span> <span class="number">00038</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       XORPS   X0, X0</span><br><span class="line">        <span class="number">0x0029</span> <span class="number">00041</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       MOVUPS  X0, <span class="string">""</span>.~r0+<span class="number">80</span>(SP)</span><br><span class="line">        <span class="number">0x002e</span> <span class="number">00046</span> (test1.<span class="keyword">go</span>:<span class="number">7</span>)       PCDATA  $<span class="number">2</span>, $<span class="number">1</span></span><br><span class="line">        <span class="number">0x002e</span> <span class="number">00046</span> (test1.<span class="keyword">go</span>:<span class="number">7</span>)       LEAQ    <span class="keyword">type</span>.<span class="keyword">string</span>(SB), AX</span><br><span class="line">        <span class="number">0x0035</span> <span class="number">00053</span> (test1.<span class="keyword">go</span>:<span class="number">7</span>)       PCDATA  $<span class="number">2</span>, $<span class="number">0</span></span><br><span class="line">        <span class="number">0x0035</span> <span class="number">00053</span> (test1.<span class="keyword">go</span>:<span class="number">7</span>)       MOVQ    AX, (SP)</span><br><span class="line">        <span class="number">0x0039</span> <span class="number">00057</span> (test1.<span class="keyword">go</span>:<span class="number">7</span>)       MOVQ    $<span class="number">10</span>, <span class="number">8</span>(SP)</span><br><span class="line">        <span class="number">0x0042</span> <span class="number">00066</span> (test1.<span class="keyword">go</span>:<span class="number">7</span>)       MOVQ    $<span class="number">10</span>, <span class="number">16</span>(SP)</span><br><span class="line">        <span class="number">0x004b</span> <span class="number">00075</span> (test1.<span class="keyword">go</span>:<span class="number">7</span>)       CALL    runtime.makeslice(SB) <span class="comment">// 对应的底层runtime function</span></span><br><span class="line">        ... ...</span><br><span class="line">        <span class="number">0x008c</span> <span class="number">00140</span> (test1.<span class="keyword">go</span>:<span class="number">8</span>)       RET</span><br><span class="line">        <span class="number">0x008d</span> <span class="number">00141</span> (test1.<span class="keyword">go</span>:<span class="number">8</span>)       NOP</span><br><span class="line">        <span class="number">0x008d</span> <span class="number">00141</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       PCDATA  $<span class="number">0</span>, $<span class="number">-1</span></span><br><span class="line">        <span class="number">0x008d</span> <span class="number">00141</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       PCDATA  $<span class="number">2</span>, $<span class="number">-1</span></span><br><span class="line">        <span class="number">0x008d</span> <span class="number">00141</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">        <span class="number">0x0092</span> <span class="number">00146</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       JMP     <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>根据对应的代码行数与名字，很明显的可以看到应用层写的 <code>make</code> 对应底层是 <code>makeslice</code>。</p>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>这里先说一下逃逸分析的概念。这里牵扯到栈、堆分配的问题。如果变量被分配到栈上，会伴随函数调用结束自动回收，并且分配效率很高；其次分配到堆上，则需要GC进行标记回收。所谓逃逸就是指变量从栈上逃到了堆上（很多人对这个概念都不清楚就在谈逃逸分析，面试遇到了好几次😓）。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">	t := <span class="number">3</span></span><br><span class="line">	<span class="keyword">return</span> &amp;t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"><span class="string">""</span>.test STEXT size=<span class="number">98</span> args=<span class="number">0x8</span> locals=<span class="number">0x20</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       TEXT    <span class="string">""</span>.test(SB), ABIInternal, $<span class="number">32</span><span class="number">-8</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       MOVQ    (TLS), CX</span><br><span class="line">        <span class="number">0x0009</span> <span class="number">00009</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       CMPQ    SP, <span class="number">16</span>(CX)</span><br><span class="line">        <span class="number">0x000d</span> <span class="number">00013</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       JLS     <span class="number">91</span></span><br><span class="line">        <span class="number">0x000f</span> <span class="number">00015</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       SUBQ    $<span class="number">32</span>, SP</span><br><span class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       MOVQ    BP, <span class="number">24</span>(SP)</span><br><span class="line">        <span class="number">0x0018</span> <span class="number">00024</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       LEAQ    <span class="number">24</span>(SP), BP</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="number">0x001d</span> <span class="number">00029</span> (test1.<span class="keyword">go</span>:<span class="number">6</span>)       MOVQ    $<span class="number">0</span>, <span class="string">""</span>.~r0+<span class="number">40</span>(SP)</span><br><span class="line">        <span class="number">0x0026</span> <span class="number">00038</span> (test1.<span class="keyword">go</span>:<span class="number">7</span>)       PCDATA  $<span class="number">2</span>, $<span class="number">1</span></span><br><span class="line">        <span class="number">0x0026</span> <span class="number">00038</span> (test1.<span class="keyword">go</span>:<span class="number">7</span>)       LEAQ    <span class="keyword">type</span>.<span class="keyword">int</span>(SB), AX</span><br><span class="line">        <span class="number">0x002d</span> <span class="number">00045</span> (test1.<span class="keyword">go</span>:<span class="number">7</span>)       PCDATA  $<span class="number">2</span>, $<span class="number">0</span></span><br><span class="line">        <span class="number">0x002d</span> <span class="number">00045</span> (test1.<span class="keyword">go</span>:<span class="number">7</span>)       MOVQ    AX, (SP)</span><br><span class="line">        <span class="number">0x0031</span> <span class="number">00049</span> (test1.<span class="keyword">go</span>:<span class="number">7</span>)       CALL    runtime.newobject(SB) <span class="comment">// 堆上分配空间，表示逃逸了</span></span><br><span class="line">        ... ...</span><br></pre></td></tr></table></figure>
<p>这里如果是对 <code>slice</code> 使用汇编进行逃逸分析，并不会很直观。因为只会看到调用了 <code>runtime.makeslice</code> 函数，该函数内部其实又调用了 <code>runtime.mallocgc</code> 函数，这个函数会分配的内存其实就是堆上的内存（如果栈上足够保存，是不会看到对 <code>runtime.makslice</code> 函数的调用）。</p>
<p>实际go也提供了更方便的命令来进行逃逸分析：<code>go build -gcflags=&quot;-m&quot;</code>，如果真的是做逃逸分析，建议使用该命令，别折腾用汇编。</p>
<h2 id="传值还是传指针"><a href="#传值还是传指针" class="headerlink" title="传值还是传指针"></a>传值还是传指针</h2><p>对于golang中的基本类型：字符串、整型、布尔类型就不多说了，肯定是值传递，那么对于结构体、指针到底是值传递还是指针传递呢？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jack := &amp;Student&#123;<span class="string">"jack"</span>, <span class="number">30</span>&#125;</span><br><span class="line">    test(jack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s *Student)</span> *<span class="title">Student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line"><span class="string">""</span>.test STEXT nosplit size=<span class="number">20</span> args=<span class="number">0x10</span> locals=<span class="number">0x0</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (test1.<span class="keyword">go</span>:<span class="number">14</span>)      TEXT    <span class="string">""</span>.test(SB), NOSPLIT|ABIInternal, $<span class="number">0</span><span class="number">-16</span></span><br><span class="line">        ... ...</span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (test1.<span class="keyword">go</span>:<span class="number">14</span>)      MOVQ    $<span class="number">0</span>, <span class="string">""</span>.~r1+<span class="number">16</span>(SP) <span class="comment">// 初始返回值为0</span></span><br><span class="line">        <span class="number">0x0009</span> <span class="number">00009</span> (test1.<span class="keyword">go</span>:<span class="number">15</span>)      PCDATA  $<span class="number">2</span>, $<span class="number">1</span></span><br><span class="line">        <span class="number">0x0009</span> <span class="number">00009</span> (test1.<span class="keyword">go</span>:<span class="number">15</span>)      PCDATA  $<span class="number">0</span>, $<span class="number">1</span></span><br><span class="line">        <span class="number">0x0009</span> <span class="number">00009</span> (test1.<span class="keyword">go</span>:<span class="number">15</span>)      MOVQ    <span class="string">""</span>.s+<span class="number">8</span>(SP), AX <span class="comment">// 将引用地址复制到 AX 寄存器</span></span><br><span class="line">        <span class="number">0x000e</span> <span class="number">00014</span> (test1.<span class="keyword">go</span>:<span class="number">15</span>)      PCDATA  $<span class="number">2</span>, $<span class="number">0</span></span><br><span class="line">        <span class="number">0x000e</span> <span class="number">00014</span> (test1.<span class="keyword">go</span>:<span class="number">15</span>)      PCDATA  $<span class="number">0</span>, $<span class="number">2</span></span><br><span class="line">        <span class="number">0x000e</span> <span class="number">00014</span> (test1.<span class="keyword">go</span>:<span class="number">15</span>)      MOVQ    AX, <span class="string">""</span>.~r1+<span class="number">16</span>(SP) <span class="comment">// 将 AX 的引用地址又复制到返回地址</span></span><br><span class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (test1.<span class="keyword">go</span>:<span class="number">15</span>)      RET</span><br></pre></td></tr></table></figure>
<p>通过这里可以看到在go里边，只有值传递，因为它底层还是通过拷贝对应的值。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天的文章到此结束，本次主要讲了下面几个点：</p>
<ol>
<li>计算机软硬资源之间的相互配合；</li>
<li><code>Golang</code> 编写的代码，函数与方法是怎么执行的，主要讲了栈上分配与相关调用；</li>
<li>使用 <code>Plan9</code> 分析了一些常见的问题。</li>
</ol>
<p>希望本文对大家在理解、学习Go的路上有一些帮助。</p>
<p><strong>参考资料</strong></p>
<ul>
<li>[1] <a href="https://blog.learngoprogramming.com/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed" target="_blank" rel="external">A visual guide to Go Memory Allocator from scratch</a></li>
<li>[2] <a href="https://golang.org/doc/asm" target="_blank" rel="external">A Quick Guide to Go’s Assembler</a></li>
<li>[3] <a href="https://studygolang.com/articles/2917" target="_blank" rel="external">A Quick Guide to Go’s Assembler 中文版</a></li>
<li>[4] <a href="https://xargin.com/go-and-plan9-asm/" target="_blank" rel="external">go 和 plan9 汇编</a></li>
<li>[5] <a href="https://xargin.com/plan9-assembly/" target="_blank" rel="external">plan9 assembly 完全解析</a></li>
<li>[6] <a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8" target="_blank" rel="external">寄存器 wiki</a></li>
<li>[7] <a href="https://segmentfault.com/a/1190000019753885" target="_blank" rel="external">Go 函数调用 ━ 栈和寄存器视角</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[走进Golang之编译器原理]]></title>
      <url>http://dayutalk.cn/2019/10/24/%E8%B5%B0%E8%BF%9BGolang%E4%B9%8B%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>为了学好Golang底层知识装逼，折腾了一下编译器相关知识。下面的内容并不会提升你的生产技能点，但可以提高你的装逼指数。请按需进入！<br><a id="more"></a></p>
<p>本文目录速览：</p>
<ul>
<li><a href="#认识-go-build">认识 go build</a></li>
<li><a href="#编译器原理">编译器原理</a><ul>
<li><a href="#词法分析">词法分析</a></li>
<li><a href="#语法分析">语法分析</a></li>
<li><a href="#语义分析">语义分析</a></li>
<li><a href="#中间码生成">中间码生成</a></li>
<li><a href="#代码优化">代码优化</a></li>
<li><a href="#机器码生成">机器码生成</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<h1 id="认识-go-build"><a href="#认识-go-build" class="headerlink" title="认识 go build"></a>认识 go build</h1><p>当我们敲下 <code>go build</code> 的时候，我们的写的源码文件究竟经历了哪些事情？最终变成了可执行文件。</p>
<p>这个命令会编译go代码，今天就来一起看看go的编译过程吧！</p>
<p>首先先来认识以下go的代码源文件分类</p>
<ul>
<li>命令源码文件：简单说就是含有 main 函数的那个文件，通常一个项目一个该文件，我也没想过需要两个命令源文件的项目</li>
<li>测试源码文件：就是我们写的单元测试的代码，都是以 <code>_test.go</code> 结尾</li>
<li>库源码文件：没有上面特征的就是库源码文件，像我们使用的很多第三方包都属于这部分</li>
</ul>
<p><code>go build</code> 命令就是用来编译这其中的 <strong>命令源码文件</strong> 以及它依赖的 <strong>库源码文件</strong>。下面表格是一些常用的选项在这里集中说明以下。</p>
<table>
<thead>
<tr>
<th>可选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>将命令源码文件与库源码文件全部重新构建，即使是最新的</td>
</tr>
<tr>
<td>-n</td>
<td>把编译期间涉及的命令全部打印出来，但不会真的执行，非常方便我们学习</td>
</tr>
<tr>
<td>-race</td>
<td>开启竞态条件的检测，支持的平台有限制</td>
</tr>
<tr>
<td>-x</td>
<td>打印编译期间用到的命名，它与 -n 的区别是，它不仅打印还会执行</td>
</tr>
</tbody>
</table>
<p>接下来就用一个 hello world 程序来演示以下上面的命令选项。</p>
<p><img src="https://dayutalk.cn/img/go-byq-0.png" alt="go的演示代码"></p>
<p>如果对上面的代码执行 <code>go build -n</code> 我们看一下输出信息：</p>
<p><img src="https://dayutalk.cn/img/go-byq-1.png" alt="编译代码"></p>
<p>来分析下整个执行过程</p>
<p><img src="https://dayutalk.cn/img/go-byq-2.png" alt="编译器编译过程"></p>
<p>这一部分是编译的核心，通过 <code>compile</code>、 <code>buildid</code>、 <code>link</code> 三个命令会编译出可执行文件 <code>a.out</code>。</p>
<p>然后通过 <code>mv</code> 命令把 a.out 移动到当前文件夹下面，并改成跟项目文件一样的名字（这里也可以自己指定名字）。</p>
<p>文章的后面部分，我们主要讲的就是 <code>compile</code>、 <code>buildid、</code> <code>link</code> 这三个命令涉及的编译过程。</p>
<h1 id="编译器原理"><a href="#编译器原理" class="headerlink" title="编译器原理"></a>编译器原理</h1><p>这是go编译器的<a href="https://github.com/golang/go/tree/master/src/cmd/compile" target="_blank" rel="external">源码路径</a></p>
<p><img src="https://dayutalk.cn/img/go-byq-3.png" alt="编译器流程"></p>
<p>如上图所见，整个编译器可以分为：编译前端与编译后端；现在我们看看每个阶段编译器都做了些什么事情。先来从前端部分开始。</p>
<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>词法分析简单来说就是将我们写的源代码翻译成 <code>Token</code>，这是个什么意思呢？</p>
<p>为了理解 <code>Golang</code> 从源代码翻译到 <code>Token</code> 的过程，我们用一段代码来看一下翻译的一一对应情况。</p>
<p><img src="https://dayutalk.cn/img/go-byq-4.png" alt="源码到token"></p>
<p>图中重要的地方我都进行了注释，不过这里还是有几句话多说一下，我们看着上面的代码想象以下，如果要我们自己来实现这个“翻译工作”，程序要如何识别 <code>Token</code> 呢？</p>
<p>首先先来给Go的token类型分个类：变量名、字面量、操作符、分隔符以及关键字。我们需要把一堆源代码按照规则进行拆分，其实就是分词，看着上面的例子代码我们可以大概制定一个规则如下：</p>
<ol>
<li>识别空格，如果是空格可以分一个词；</li>
<li>遇到 <code>(</code> 、<code>)</code>、’&lt;’、’&gt;’ 等这些特殊运算符的时候算一个分词；</li>
<li>遇到 “ 或者 数字字面量算分词。</li>
</ol>
<p>通过上面的简单分析，其实可以看出源代码转 <code>Token</code> 其实没有非常复杂，完全可以自己写代码实现出来。当然也有很多通过正则的方式实现的比较通用的词法分析器，像 <code>Golang</code> 早期就用的是 <code>lex</code>，在后面的版本中才改用了用go来自己实现。</p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>经过词法分析后，我们拿到的就是 <code>Token</code> 序列，它将作为语法分析器的输入。然后经过处理后生成 <code>AST</code> 结构作为输出。</p>
<p>所谓的语法分析就是将 <code>Token</code> 转化为可识别的程序语法结构，而 <code>AST</code> 就是这个语法的抽象表示。构造这颗树有两种方法。</p>
<ol>
<li><p>自上而下<br>这种方式会首先构造根节点，然后就开始扫描 <code>Token</code>，遇到 <code>STRING</code> 或者其它类型就知道这是在进行类型申明，<code>func</code> 就表示是函数申明。就这样一直扫描直到程序结束。</p>
</li>
<li><p>自下而上<br>这种是与上一种方式相反的，它先构造子树，然后再组装成一颗完整的树。</p>
</li>
</ol>
<p>go语言进行语法分析使用的是自下而上的方式来构造 <code>AST</code>，下面我们就来看一下go语言通过 <code>Token</code> 构造的这颗树是什么样子。</p>
<p><img src="https://dayutalk.cn/img/go-byq-5.svg" alt="go的AST树"></p>
<p>这其中有意思的地方我全部用文字标注出来了。你会发现其实每一个 <code>AST</code> 树的节点都与一个 <code>Token</code> 实际位置相对应。</p>
<p>这颗树构造后，我们可以看到不同的类型是由对应的结构体来进行表示的。这里如果有语法、词法错误是不会被解析出来的。因为到目前为止说白了都是进行的字符串处理。</p>
<h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>编译器里边都把语法分析后的阶段叫做 <strong>语义分析</strong>，而go的这个阶段叫 <strong>类型检查</strong>；但是我看了以下go自己的文档，其实做的事情没有太大差别，我们还是按照主流规范来写这个过程。</p>
<p>那么语义分析（类型检查）究竟要做些什么呢？</p>
<p><code>AST</code> 生成后，语义分析将使用它作为输入，并且的有一些相关的操作也会直接在这颗树上进行改写。</p>
<p>首先就是 <code>Golang</code> 文档中提到的会进行类型检查，还有类型推断，查看类型是否匹配，是否进行隐式转化（go没有隐式转化）。如下面的文字所说：</p>
<blockquote>
<p>The AST is then type-checked. The first steps are name resolution and type inference, which determine which object belongs to which identifier, and what type each expression has. Type-checking includes certain extra checks, such as “declared and not used” as well as determining whether or not a function terminates.</p>
</blockquote>
<p>大意是：生成AST之后是类型检查（也就是我们这里说的语义分析），第一步是进行名称检查和类型推断，签定每个对象所属的标识符，以及每个表达式具有什么类型。类型检查也还有一些其它的检查要做，像“声明未使用”以及确定函数是否中止。</p>
<blockquote>
<p>Certain transformations are also done on the AST. Some nodes are refined based on type information, such as string additions being split from the arithmetic addition node type. Some other examples are dead code elimination, function call inlining, and escape analysis.</p>
</blockquote>
<p>这一段是说：AST也会进行转换，有些节点根据类型信息进行精简，比如从算术加法节点类型中拆分出字符串加法。其它一些例子像dead code的消除，函数调用内联和逃逸分析。</p>
<p>上面两段文字来自 <a href="https://github.com/golang/go/tree/master/src/cmd/compile" target="_blank" rel="external">golang compile</a></p>
<p>这里多说一句，我们常常在debug代码的时候，需要禁止内联，其实就是操作的这个阶段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 编译的时候禁止内联</span><br><span class="line">go build -gcflags &apos;-N -l&apos;</span><br><span class="line"></span><br><span class="line">-N 禁止编译优化</span><br><span class="line">-l 禁止内联,禁止内联也可以一定程度上减小可执行程序大小</span><br></pre></td></tr></table></figure>
<hr>
<p>经过语义分析之后，就可以说明我们的代码结构、语法都是没有问题的。所以编译器前端主要就是解析出编译器后端可以处理的正确的AST结构。</p>
<p>接下来我们看看编译器后端又有哪些事情要做。</p>
<p>机器只能够理解二进制并运行，所以编译器后端的任务简单来说就是怎么把AST翻译成机器码。</p>
<h2 id="中间码生成"><a href="#中间码生成" class="headerlink" title="中间码生成"></a>中间码生成</h2><p>既然已经拿到AST，机器运行需要的又是二进制。为什么不直接翻译成二进制呢？其实到目前为止从技术上来说已经完全没有问题了。</p>
<p>但是，<br>我们有各种各样的操作系统，有不同的CPU类型，每一种的位数可能不同；寄存器能够使用的指令也不同，像是复杂指令集与精简指令集等；在进行各个平台的兼容之前，我们还需要替换一些底层函数，比如我们使用make来初始化slice，此时会根据传入的类型替换为：<code>makeslice64</code> 或者 <code>makeslice</code>。当然还有像painc、channel等等函数的替换也会在中间码生成过程中进行替换。这一部分的替换操作可以在<a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/builtin/runtime.go" target="_blank" rel="external">这里查看</a></p>
<p>中间码存在的另外一个价值是提升后端编译的重用，比如我们定义好了一套中间码应该是长什么样子，那么后端机器码生成就是相对固定的。每一种语言只需要完成自己的编译器前端工作即可。这也是大家可以看到现在开发一门新语言速度比较快的原因。编译是绝大部分都可以重复使用的。</p>
<p>而且为了接下来的优化工作，中间代码存在具有非凡的意义。因为有那么多的平台，如果有中间码我们可以把一些共性的优化都放到这里。</p>
<p>中间码也是有多种格式的，像 <code>Golang</code> 使用的就是SSA特性的中间码(IR)，这种形式的中间码，最重要的一个特性就是最在使用变量之前总是定义变量，并且每个变量只分配一次。</p>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>在go的编译文档中，我并没找到独立的一步进行代码的优化。不过根据我们上面的分析，可以看到其实代码优化过程遍布编译器的每一个阶段。大家都会力所能及的做些事情。</p>
<p>通常我们除了用高效代码替换低效的之外，还有如下的一些处理：</p>
<ul>
<li>并行性，充分利用现在多核计算机的特性</li>
<li>流水线，cpu有时候在处理a指令的时候，还能同时处理b指令</li>
<li>指令的选择，为了让cpu完成某些操作，需要使用指令，但是不同的指令效率有非常大的差别，这里会进行指令优化</li>
<li>利用寄存器与高速缓存，我们都知道cpu从寄存器取是最快的，从高速缓存取次之。这里会进行充分的利用</li>
</ul>
<h2 id="机器码生成"><a href="#机器码生成" class="headerlink" title="机器码生成"></a>机器码生成</h2><p>经过优化后的中间代码，首先会在这个阶段被转化为汇编代码（Plan9），而汇编语言仅仅是机器码的文本表示，机器还不能真的去执行它。所以这个阶段会调用汇编器，汇编器会根据我们在执行编译时设置的架构，调用对应代码来生成目标机器码。</p>
<p>这里比有意思的是，<code>Golang</code> 总说自己的汇编器是跨平台的。其实他也是写了多分代码来翻译最终的机器码。因为在入口的时候他会根据我们所设置的 <code>GOARCH=xxx</code> 参数来进行初始化处理，然后最终调用对应架构编写的特定方法来生成机器码。这种上层逻辑一致，底层逻辑不一致的处理方式非常通用，非常值得我们学习。我们简单来一下这个处理。</p>
<p>首先看入口函数 <code>cmd/compile/main.go:main()</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> archInits = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(*gc.Arch)</span></span>&#123;</span><br><span class="line">    <span class="string">"386"</span>:      x86.Init,</span><br><span class="line">    <span class="string">"amd64"</span>:    amd64.Init,</span><br><span class="line">    <span class="string">"amd64p32"</span>: amd64.Init,</span><br><span class="line">    <span class="string">"arm"</span>:      arm.Init,</span><br><span class="line">    <span class="string">"arm64"</span>:    arm64.Init,</span><br><span class="line">    <span class="string">"mips"</span>:     mips.Init,</span><br><span class="line">    <span class="string">"mipsle"</span>:   mips.Init,</span><br><span class="line">    <span class="string">"mips64"</span>:   mips64.Init,</span><br><span class="line">    <span class="string">"mips64le"</span>: mips64.Init,</span><br><span class="line">    <span class="string">"ppc64"</span>:    ppc64.Init,</span><br><span class="line">    <span class="string">"ppc64le"</span>:  ppc64.Init,</span><br><span class="line">    <span class="string">"s390x"</span>:    s390x.Init,</span><br><span class="line">    <span class="string">"wasm"</span>:     wasm.Init,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从上面的map根据参数选择对应架构的处理</span></span><br><span class="line">    archInit, ok := archInits[objabi.GOARCH]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把对应cpu架构的对应传到内部去</span></span><br><span class="line">    gc.Main(archInit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>cmd/internal/obj/plist.go</code> 中调用对应架构的方法进行处理</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Flushplist</span><span class="params">(ctxt *Link, plist *Plist, newprog ProgAlloc, myimportpath <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> text &#123;</span><br><span class="line">        mkfwd(s)</span><br><span class="line">        linkpatch(ctxt, s, newprog)</span><br><span class="line">        <span class="comment">// 对应架构的方法进行自己的机器码翻译</span></span><br><span class="line">        ctxt.Arch.Preprocess(ctxt, s, newprog)</span><br><span class="line">        ctxt.Arch.Assemble(ctxt, s, newprog)</span><br><span class="line"></span><br><span class="line">        linkpcln(ctxt, s)</span><br><span class="line">        ctxt.populateDWARF(plist.Curfn, s, myimportpath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程下来，可以看到编译器后端有很多工作需要做的，你需要对某一个指令集、cpu的架构了解，才能正确的进行翻译机器码。同时不能仅仅是正确，一个语言的效率是高还是低，也在很大程度上取决于编译器后端的优化。特别是即将进入AI时代，越来越多的芯片厂商诞生，我估计以后对这方面人才的需求会变得越来越旺盛。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下学习编译器这部分古老知识带给我的几个收获：</p>
<ol>
<li>知道整个编译由几个阶段构成，每个阶段做什么事情；但是更深入的每个阶段实现的一些细节还不知道，也不打算知道；</li>
<li>就算是编译器这种复杂，很底层的东西也是可以通过分解，让每一个阶段独立变得简单、可复用，这对我在做应用开发有一些意义；</li>
<li>分层是为了划分指责，但是某些事情还需要全局的去做，比如优化，其实每一个阶段都会去做；对于我们设计系统也是有一定参考意义的；</li>
<li>了解到 <code>Golang</code> 对外暴露的很多方法其实是语法糖（如：make、painc etc.），编译器会帮我忙进行翻译，最开始我以为是go代码层面在运行时去做的，类似工厂模式，现在回头来看自己真是太天真了；</li>
<li>对接下来准备学习Go的运行机制、以及Plan9汇编进行了一些基础准备。</li>
</ol>
<p>本文的很多信息都来自下面的资料。</p>
<ul>
<li>[1] <a href="https://github.com/golang/go/tree/master/src/cmd/compile" target="_blank" rel="external">golang compile</a></li>
<li>[2] <a href="https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa" target="_blank" rel="external">golang ssa</a></li>
<li>[3] <a href="https://halfrost.com/go_command/" target="_blank" rel="external">golang command</a></li>
<li>[4] <a href="https://draveness.me/golang/compile/golang-compile-intro.html" target="_blank" rel="external">golang compile 介绍</a></li>
<li>[5] <a href="https://segmentfault.com/a/1190000016523685" target="_blank" rel="external">golang 编译流程分析</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[今天，应该为了明天而活]]></title>
      <url>http://dayutalk.cn/2019/10/10/%E4%BB%8A%E5%A4%A9%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%B8%BA%E4%BA%86%E6%98%8E%E5%A4%A9%E8%80%8C%E6%B4%BB/</url>
      <content type="html"><![CDATA[<p>读完了《财富自由之路》，迫不及待的想记录下自己此时的一些想法<br><a id="more"></a><br>《财富自由之路》这本书在手已经很久了，一直没有翻阅。今年国庆哪儿也没去，就在家翻完了。越看越心惊，真真体会到穷人与富人最大的差别是思想的差别。希望这本书洗礼了我的落后思想，让我自由起来。</p>
<h1 id="财务自由"><a href="#财务自由" class="headerlink" title="财务自由"></a>财务自由</h1><p>经常说财务自由，但是什么叫财务自由？以前经常看到有些专家说：北上广财务自由是多少标准、其它二线又是多少钱才算财务自由。这种说法是非常不正确不负责任的。</p>
<p>马云爸爸财务自由的标准跟我的财务自由标准能一样吗？<br>对于我，可能就是住个200平的房子，每天能吃上猪肉，每周能下次馆子可能就是财务自由了。马爸爸呢可能要练练太极、定期辟谷，要支付私人飞机、别墅等等费用。所以财务自由的金钱标准应该是因人而异的。并且在谈财务自由之前还有几个阶段你得先达到，才有资格谈财务自由。</p>
<p>财务保障，是我们需要达到的第一个阶段。简单说这个阶段就是当你没有任何收入来源了，你要吃穿住行每个月得化多少钱？比如说正常每个月你吃饭、房贷、车辆费等等开支是1w，那么你的财务保障标准就是：<strong>1w * 6 = 6w </strong>。所以这个阶段的要请求未满足就不要妄谈下一个财务目标。<br>为了更快速的进入下一个财务阶段，如果你每个月的必要开支越少你就能够越快的进入财务自由的目标实现。所以你需要通过记账，分析个人收入、支出情况来优化自己的开支，尽快完成这个目标。</p>
<p>财务安全，如果现在已经攒够了财务保障的6w，那么恭喜来到了财务安全的阶段。这个阶段与财务保障的最大区别是，财务保障的钱花完就没有了，你准备了6个月的备用金，如果6个月还没有解决问题，那么你就破产了。而财务安全则意味着你再也不需要为钱担心，你本金产生的利息完全覆盖你每个月的支出。这里你可以计算一下你理想的生活每个月是支出多少（当然还是越少越容易实现）？然后还是按照 <strong>年化8%</strong> 来计算一下所需要的本金。</p>
<blockquote>
<p>每月生活需要1w * （12/0.08） = 所需总金额150w</p>
</blockquote>
<p>所以财务安全的目标就是尽可能快的存够这么多钱，然后你就解放了自己，可以达到下个财务阶段。</p>
<p>财务自由，财务自由是关于梦想的实现。财务安全是对于基本生活的保障。可能你还有很多其它想做的事情，比如：有些人喜欢到处留学、爬山；有些喜欢钓鱼，有些喜欢做慈善。财务安全之后你应该考虑一下自己的梦想，看一下你如果为了满足梦想，需要每月多少的金钱支出。这些梦想包括不限于：房子、车子、度假、学习、慈善等。还是按照年化收益8%来计算一下所需本金。</p>
<blockquote>
<p>每月生活需要10w * （12/0.08） = 所需总金额1500w</p>
</blockquote>
<p>至此，对于每一个目标应该需要多少钱，我们都进行了清楚的计算。接下来的目标无法就是两个：</p>
<ol>
<li>怎么攒够每个阶段的本金；</li>
<li>怎么做到年化收益率8%甚至更高。</li>
</ol>
<p>目前市面上有很多书都谈的是怎么让你年化收益达到多少，其实重点是先怎么攒够这些本金。建议大家阅读《财富自由之路》，获得更多心法。</p>
<h1 id="财富积累的分类"><a href="#财富积累的分类" class="headerlink" title="财富积累的分类"></a>财富积累的分类</h1><p>为了攒够本金，我们先看看自己赚钱是在什么领域。我们又能做什么去更快的提高收入？</p>
<p>我们可以将工作的领域分为：</p>
<ul>
<li>雇员</li>
<li>自由职业者</li>
<li>投资者</li>
<li>企业家</li>
<li>专家</li>
</ul>
<p>我们现在的教育体制培养的都是：雇员、自由职业者这两类。这两类都是为后面三类人进行服务的。<br>在这5类领域中，前两个领域的收入远不如后面三者。为了挣更多的钱，我们有以下的办法：</p>
<ol>
<li>提升自己所在领域的收入</li>
<li>自己领域成为王者，然后跨界</li>
<li>转换到更赚钱的领域去</li>
</ol>
<p>比如作为一个雇员，我们可以努力提升自己的专业技能，每年获得最大幅度的涨薪；然后成为自己领域的大牛，这个时候可以尝试专家、投资者等角色，也许工资还是自己最主要的收入来源，但是其它领域也有收入产生；到最后你可能发现自己更适合成为一个专家、一个投资者，甚至创办自己的企业成为企业家。至于每一个领域该怎么提高收入、如何转换领域，我们需要自己去找到对应的成功者，先模仿，再超越。</p>
<p>不管我们是处在上面五种领域的哪种领域，都需要创造出价值才能对自己形成收入，而所有的价值分类又可分为：</p>
<ul>
<li>产品价值</li>
<li>知识价值</li>
<li>服务价值</li>
<li>创意价值</li>
</ul>
<p>作者书中每一个步骤都要求我们自己去思考，自己的长处，自己能够提供什么样的价值来换取报酬呢？我们可以按照这个价值分类来检查自己的能力。发掘出自身的更多价值。</p>
<p>通过上面这些分析我们知道收入从何处可以创造，但是 <strong>收入不等于财富</strong>，为什么这么讲？你会发现月工资5k的时候你能够生活，3w的时候也能够生活，每个月都不会攒下什么钱。<br>为什么？因为虽然你收入增加了，但是你的支出也在水涨船高。所以一定要有纪律控制自己的生活水平进行维持。有时候经常说有钱人真吝啬，人家那叫自律。正所谓欲望越少，越自由吧！所以控制好支出水平。</p>
<h1 id="如何去实现目标"><a href="#如何去实现目标" class="headerlink" title="如何去实现目标"></a>如何去实现目标</h1><p>以前看过一本书《活在当下》，现在回想这绝对是一种消极的生活态度。勇敢的人绝对是为未来而活。</p>
<p>上面财务安全、自由的目标都是需要付出一定的代价才可能实现的。为了实现它你一定要有一个清晰的目标、清晰的截止时间。<br>定下目标后你得问问自己这个目标如果我实现了会是什么样？不实现又如何？很多时候我们都是一种晚上想想千条路，早上起来走老路的态度活着。总归起来就是我们虽然定了目标但是自己并没有想清楚这个目标意味着什么，自己愿意为这个目标付出什么样的代价，或者这个目标没有分阶段定制。</p>
<p>书中介绍了一些方法来制定一个切实可行的目标，以及通过不断记录自己取得成功的事情来明确自己的优势所在，然后在这些领域不断发力创造更高收入。<br>然后把自己的目标具体化，不要说我要赚够1个亿，我要办一家公司。把这些东西具体化，清楚赚够1个亿后你的生活是什么样子，可以通过寻找榜样，看富人的生活，然后用他们作为自己的模版，不断去奋斗。对于大的目标我们需要拆分成小的、短期的阶段目标，并列出具体的事情需要怎么去做。然后每一件事情主动去承担责任，用一句心灵鸡汤的话去总结就是：成功的人找方法，失败的人找理由。</p>
<p>对于赚钱要做的事情，一定要事半功倍，我们要去做可以多次赚钱的事情，而不是一次。比如现在的知识付费方式，你录制一个课程，卖出多分创造更多收益。并且一定要牢记控制支出，不要动用自己的储蓄，不要动用自己的储蓄，不要动用自己的储蓄！储蓄是未来财务安全、自由的绝对保障。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个财务自由的过程很像升级打怪，我们不断状态自己的收入，控制自己的支出，积累自己的储蓄。然后让储蓄去生钱。当储蓄产生的钱能够完全覆盖我们的支出的时候，就是财务安全与自由。</p>
<p>很多理财计划是针对如何让储蓄生钱；而如何积累储蓄，我们要从提高收入，控制支出去做。对于自己制定的目标要明白需要付出的代价，并且有决心去实现它。</p>
<p>最后提供一个做事的五步思考法。</p>
<ol>
<li>我想要做什么事情</li>
<li>这件事情做成后的价值是什么</li>
<li>这件事情我怎么才能做成</li>
<li>目前是什么阻止了我去做这件事情</li>
<li>我怎么知道这个事情做成了呢？</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[高并发架构的HTTP知识介绍]]></title>
      <url>http://dayutalk.cn/2019/06/22/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E7%9A%84HTTP%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>拖延症患者的毛病需要治疗了，不过基础的协议部分内容终于要完结了！<br><a id="more"></a></p>
<p>我们前面说过了 <a href="https://dayutalk.cn/2019/04/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E7%9A%84CDN%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/">CDN的知识</a>，也通过抓包分析了 <a href="https://dayutalk.cn/2019/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E7%9A%84TCP%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/">TCP建立链接的过程</a>。今天一起聊一聊应用层的协议 <code>HTTP/HTTPS</code>；这是应用工程师日常中接触最久的协议了。但是你真的了解他吗？</p>
<p>今天我们不讲 <code>HTTP协议</code> 的几种请求方式，主要介绍HTTP及HTTPS整个发送数据的过程。</p>
<h1 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h1><p>还记得前面讲的 DNS 的过程吗？通过DNS我们拿到了服务端的IP地址，然后通过TCP协议，完成了浏览器与应用服务器的连接建立。HTTP协议是建立在TCP协议之上的（上层协议必然依赖下层协议），连接建立后，自然是开始通信。那么通信的格式是什么呢？</p>
<p><img src="https://dayutalk.cn/img/blog-httpmsg01.png" alt="blog-httpmsg01"></p>
<p>看上面这张图，HTTP的请求与响应格式基本如此。我们分开来说。</p>
<p>对于 <strong>请求消息</strong> ，由三部分构成：请求行、请求头、请求的Body；所谓的请求行，就是：<code>POST / HTTP/1.1</code> 这部分内容。接下来的就是请求头，也就是我们常说的HTTP头；然后换行后紧接着的内容就是请求的Body，也就是正儿八经发送给应用的参数。</p>
<p>对于 <strong>响应消息</strong> ，也是由三部分构成：状态行、响应头、响应的Body；关于响应行就是标记本次请求获得的结果是什么，这里主要有：20X、30X、40X、50X这几个范围的状态码，需要熟记。响应头里边重要的主要有跟缓存相关的东西，这部分内容会知道浏览器、CDN等缓存体的缓存行为，需要有一定的了解；最后的实体就是你请求的想要的结构，比如：HTML、Json等等。</p>
<h1 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h1><p>消息构建后，如何发送进行传输呢？我们上面图片中看到的是字符串内容，HTTP本身是不能进行网络传输的，它必须依赖的底层的TCP协议建立的连接来发送数据。因此它实际上就是把这些构建好的字符串传给下层的TCP，至于TCP如何传输的可以看上篇文章，这里不展开了。</p>
<p>WebService 收到数据后会对数据进行处理然后交给应用服务器，应用服务器自然是将请求的Body作为输入，然后根据要求产生输出。输出的行为受到请求头中部分信息的控制，比如：格式(Content-Type)、编码(Accept-Charset)等。而产生的输出各个地方也会根据响应头进行处理。</p>
<p>看到这里大家有没有发现几个问题：HTTP依赖底层的TCP连接，也就是每个HTTP都需要进行三次握手，效率是不是会非常慢？这种方式总需要浏览器端主动发起链接，服务端想主动推送些什么很无能为力；</p>
<p>针对上面这些问题，<code>HTTP2.0</code> 协议也就诞生了，当然上面这些问题在 <code>HTTP1.1</code> 时代也有些解决方案。<code>HTTP2.0</code> 主要解决了协议头进行压缩，传输同样含义的内容，占用带宽更少速度更快；将上面的单向链接的方式改成二进制流的方式，服务端有能力主动推送数据；一个链接里边支持传输多种数据流。</p>
<p>关于 <code>HTTP2.0</code> 的内容不是文本主要想说的，大家可以自行了解下。接下来又到了 <strong>核心部分</strong>，关于 <code>HTTPS</code> 为什么安全、以及如何加密的解释。这部分内容算是面试的重要考点。</p>
<h1 id="HTTPS为什么可靠"><a href="#HTTPS为什么可靠" class="headerlink" title="HTTPS为什么可靠"></a>HTTPS为什么可靠</h1><p>现在大网站基本都适用了HTTPS协议，那么它跟HTTP是什么关系呢？它其实就是HTTP加上TLS(SSL)安全层，合在一起就叫 HTTPS。为什么有了这层处理数据就安全了呢？</p>
<p>很简单，要想安全就得加密。加密的方式现在无非就是：<code>对称加密</code> 与 <code>非对称加密</code>。</p>
<p><strong>对称加密：</strong> 加密与解密都是使用相同的密钥，因此这种方式加密数据，密钥一定不能丢失。</p>
<p><strong>非对称加密：</strong> 有两把密钥，私钥与公钥。使用私钥加密的数据必须使用公钥进行解密，反之依然。</p>
<h1 id="安全的代价"><a href="#安全的代价" class="headerlink" title="安全的代价"></a>安全的代价</h1><p>看起来 非对称加密 非常安全。不过对称加密的效率非常高。HTTPS正是综合使用这两种加密方式，让整个传输过程变得安全。接下来看看这个过程是如何完成的。</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>我们先来看看，如果HTTPS只使用 <code>对称加密</code>，能否满足安全的需要呢？由于这种情况只有一个密钥，服务端怎么把这个密钥交给客户端呢？线上传输肯定会泄漏。</p>
<p>所以单单有对称加密是不能满足需求。看来得换个路子。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>使用非对称加密的私钥加密数据，发给客户端。客户端用公钥解密就得到了数据。看起来好像没有什么问题。</p>
<p>但是这里有个问题，由于服务端发出来的数据是使用的私钥，由于公钥是公开，这相当于没有加密。大家都能够看到。并且服务端发出去的公钥这个过程也可能被串改啊，你怎么知道你收到的公钥就是服务器给你的呢？就跟现在很多诈骗公司一样，看起来有模有样，实则就是一皮包公司。</p>
<h2 id="第三方公正"><a href="#第三方公正" class="headerlink" title="第三方公正"></a>第三方公正</h2><p>为了解决上述问题，出现了一个所谓的 <code>CA</code> 机构，它怎么解决这个信任问题呢？它将服务器的公钥放到 <code>CA证书</code> 里边传给客户端（这里指浏览器），浏览器拿到后验证一下这个证书是否真实有效，因为CA机构是有限可追溯的。就跟你的护照一样，可辨别真伪，所以CA证书证明了有效，那么CA证书中携带的公钥自然也证明了自己的身份。</p>
<p>是不是看起来整个过程非常麻烦？没有办法为了安全，这点代价非常值得。这也是为什么我们常常说HTTPS的效率略低于HTTP的原因。</p>
<h1 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h1><p>了解完上面的知识，我们来看看HTTPS到底是如何工作的？</p>
<p><img src="https://dayutalk.cn/img/blog-httpscomm02.png" alt="blog-httpscomm02"></p>
<ol>
<li>客户端发起了一个https请求，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数random_c，扩展字段等信息。这个过程此时是明文的。</li>
<li>然后服务器会进行回复，根据客户端支持的算法信息、套件等，服务器选择一个告诉客户端，我们就用这个吧，同时也会返回一个随机数random_s，后面协商密钥有用。</li>
<li>服务端响应客户端，这个响应中包含了证书的链接，用于交换密钥。</li>
<li>客户端对收到的数据进行检查，先把证书给拉下来，然后检查各种指标，如果不合法，会看到浏览器提醒不安全。</li>
</ol>
<p>如果验证通过，就会生成一个 <code>随机数字 Pre-master</code>，并用证书公钥加密（<strong>非对称加密</strong>），发送给服务器。</p>
<ol>
<li><p>此时的客户端已经有了生成证书的全部内容，它会计算协商的密钥（<strong>对称密钥</strong>），然后告诉服务端以后通信都采用协商的通信密钥和加密算法进行加密通信。紧接着会用协商的密钥加密一段数据发给服务端，看看是否能够正常。</p>
</li>
<li><p>上面这步里边，客户端发送了三个请求。服务器先将收到的 <code>Pre-master</code> 用自己的私钥解密出来。然后验证客户端用对称加密发过来的数据，如果通过，则也会告知客户端后续的通信都采用协商的密钥与算法进行加密通信。</p>
</li>
<li><p>并且服务端也会用对称加密生成一段加密信息给客户端让客户端试试（<strong>对称密钥</strong>）。</p>
</li>
<li><p>客户端使用对称密钥正确完成解密。握手结束。开始使用对称密钥的方式进行数据传输。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于不让文章显得过于复杂，我只介绍了最简单的单向认证。这种安全性并不是最高，单日常中也足够了。</p>
<p>本文从源头讲了为什么只有对称加密搞不定这件事；一步步演化出HTTPS的整个过程。</p>
<p>首先，为了效率，整个过程只采用了一次非对称加密来加密 <code>Pre-master</code>；</p>
<p>其次，客户端、服务端分别使用了一次对称加密来进行密钥有效性的验证，来防止中间人攻击；</p>
<p>最后，也说了为什么整个过程需要CA机构的参与。</p>
<p>参考连接：</p>
<ul>
<li><a href="https://www.wosign.com/faq/faq2016-0309-04.htm" target="_blank" rel="external">https://www.wosign.com/faq/faq2016-0309-04.htm</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[高并发架构的TCP知识介绍]]></title>
      <url>http://dayutalk.cn/2019/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E7%9A%84TCP%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>这是关于高并发架构网络协议基础知识的第二篇，编程路上的基础心法！<br><a id="more"></a></p>
<p>做为一个有追求的程序员，不能只满足增删改查，我们要对系统全方面无死角掌控。掌握了这些基本的网络知识后，相信一方面日常排错中会事半功倍，另一方面日常架构中不得不考虑的高并发问题，理解了这些底层协议也是会如虎添翼。</p>
<p>本文不会单纯给大家讲讲TCP三次握手、四次挥手就完事了。如果只是哪样的话，我直接贴几个连接就完事了。我希望把实际工作中的很多点能够串起来讲给大家。当然为了文章完整，我依然会从 <strong>三次握手</strong> 起头。</p>
<h2 id="再说TCP状态变更过程"><a href="#再说TCP状态变更过程" class="headerlink" title="再说TCP状态变更过程"></a>再说TCP状态变更过程</h2><p>不管是三次握手、还是四次挥手，他们都是完成了TCP不同状态的切换。进而影响各种数据的传输情况。下面从三次握手开始分析。</p>
<blockquote>
<p>本文图片有部分来自网络，若有侵权，告知即焚</p>
</blockquote>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>来看看三次握手的图，估计大家看这图都快看吐了，不过为什么每次面试、回忆的时候还是想不起呢？我再来抄抄这锅剩饭吧！<br><img src="https://dayutalk.cn/img/tcp-1st_f9lfkr8yh.png" alt="tcp-1st"></p>
<p>首先当服务端处于 <strong>listen</strong> 状态的时候，我们就可以再客户端发起监听了，此时客户端会处于 <strong>SYN_SENT</strong> 状态。服务端收到这个消息会返回一个 <strong>SYN</strong> 并且同时 <strong>ACK</strong> 客户端的请求，之后服务端便处于 <strong>SYN_RCVD</strong> 状态。这个时候客户端收到了服务端的 <strong>SYN&amp;ACK</strong>，就会发送对服务端的 <strong>ACK</strong>，之后便处于 <strong>ESTABLISHED</strong> 状态。服务端收到了对自己的 <strong>ACK</strong> 后也会处于 <strong>ESTABLISHED</strong> 状态。</p>
<p>经常在面试中可能有人提问：为什么握手要3次，不是2次或者4次呢？</p>
<p>首先说4次握手，其实为了保证可靠性，这个握手次数可以一直循环下去；但是这没有一个终止就没有意义了。所以3次，保证了各方消息有来有回就足够了。当然这里可能有一种情况是，客户端发送的 <strong>ACK</strong> 在网络中被丢了。那怎么办？</p>
<ol>
<li>其实大部分时候，我们连接建立完成就会立刻发送数据，所以如果服务端没有收到 <strong>ACK</strong> 没关系，当收到数据就会认为连接已经建立；</li>
<li>如果连接建立后不立马传输数据，那么服务端认为连接没有建立成功会周期性重发 <strong>SYN&amp;ACK</strong> 直到客户端确认成功。</li>
</ol>
<p>再说为什么2次握手不行呢？2次握手我们可以想象是没有三次握手最后的 <strong>ACK</strong>, 在实际中确实会出现客户端发送 <strong>ACK</strong> 服务端没有收到的情况（上面的情况一），那么这是否说明两次握手也是可行的呢？<br>看下情况二，2次握手当服务端发送消息后，就认为建立成功，而恰巧此时又没有数据传输。这就会带来一种资源浪费的情况。比如：客户端可能由于延时发送了多个连接情况，当服务端每收到一个请求回复后就认为连接建立成功，但是这其中很多求情都是延时产生的重复连接，浪费了很多宝贵的资源。</p>
<p>因此综上所述，从资源节省、效率3次握手都是最合适的。话又回来三次握手的真实意义其实就是协商传输数据用的：<strong>序列号与窗口大小</strong>。</p>
<p>下面我们通过抓包再来看一下真实的情况是否如上所述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20:33:26.583598 IP 192.168.0.102.58165 &gt; 103.235.46.39.80: Flags [S], seq 621839080, win 65535, options [mss 1460,nop,wscale 6,nop,nop,TS val 1050275400 ecr 0,sackOK,eol], length 0</span><br><span class="line">20:33:26.660754 IP 103.235.46.39.80 &gt; 192.168.0.102.58165: Flags [S.], seq 1754967387, ack 621839081, win 8192, options [mss 1452,nop,wscale 5,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,sackOK,eol], length 0</span><br><span class="line">20:33:26.660819 IP 192.168.0.102.58165 &gt; 103.235.46.39.80: Flags [.], ack 1754967388, win 4096, length 0</span><br></pre></td></tr></table></figure>
<p><strong>抓包：</strong> <code>sudo tcpdump -n host www.baidu.com -S</code></p>
<blockquote>
<ul>
<li><code>S</code> 表示 SYN</li>
<li><code>.</code> 表示 ACK</li>
<li><code>P</code> 表示 传输数据</li>
<li><code>F</code> 表示 FIN</li>
</ul>
</blockquote>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>挥手，就是说数据传完了，同志们再见！</p>
<p><img src="https://dayutalk.cn/img/tcp-3th.png" alt="tcp-3th"></p>
<p>这里有个问题需要注意下，其实客户端、服务端都能够主动发起关闭操作，谁调用 <code>close()</code> 就先发送关闭的请求。当然一般的流程，发起建立连接的一方会主动发起关闭请求（http中）。</p>
<p>关于4次挥手的过程，我就不多解释了，这里有两个重要的状态我需要解释下，这都是我亲自经历过的线上故障，<strong>close_wait</strong> 与 <strong>time_wait</strong>。</p>
<p>先给大家一个命令，统计tcp的各种状态情况。下面表格内容就来自这个命令的统计。</p>
<blockquote>
<p>netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’</p>
</blockquote>
<table>
<thead>
<tr>
<th>Tcp状态</th>
<th>连接数</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLOSE_WAIT</td>
<td>505</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>808</td>
</tr>
<tr>
<td>TIME_WAIT</td>
<td>3481</td>
</tr>
<tr>
<td>SYN_SENT</td>
<td>1</td>
</tr>
<tr>
<td>SYN_RECV</td>
<td>1</td>
</tr>
<tr>
<td>LAST_ACK</td>
<td>2</td>
</tr>
<tr>
<td>FIN_WAIT2</td>
<td>2</td>
</tr>
<tr>
<td>FIN_WAIT1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p><strong>大量的CLOSE_WAIT</strong> 这个在我之前的一篇文章 <a href="https://dayutalk.cn/2018/12/08/%E7%BA%BF%E4%B8%8A%E5%A4%A7%E9%87%8FCLOSE_WAIT%E5%88%86%E6%9E%90/">线上大量CLOSE_WAIT原因分析</a> 已经有过介绍，它会导致大量的socket无法释放。而每个socket都是一个文件，是会占用资源的。这个问题主要是代码问题。它出现在被动关闭的一方（习惯称为server）。</p>
<p><strong>大量的TIME_WAIT</strong> 这个问题在日常中经常看到，流量一高就出现大量的该情况。该状态出现在主动发起关闭的一方。该状态一般等待的时间设为 2MSL后自动关闭，<strong>MSL是Maximum Segment Lifetime，报文最大生存时间</strong>，如果报文超过这个时间，就会被丢弃。处于该状态下的socket也是不能被回收使用的。线上我就遇到这种情况，每次大流量的时候，每台机器处于该状态的socket就多达10w+，远远比处于 <code>Established</code> 状态的socket多的多，导致很多时候服务响应能力下降。这个一方面可以通过调整内核参数处理，另一方面避免使用太多的短链接，可以采用连接池来提升性能。另外在代码层面可能是由于某些地方没有关闭连接导致的，也需要检查业务代码。</p>
<p>上面两个状态一定要牢记发生在哪一方，这方便我们快速定位问题。</p>
<p>最后这里还是放上挥手时的抓包数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">20:33:26.750607 IP 192.168.0.102.58165 &gt; 103.235.46.39.80: Flags [F.], seq 621839159, ack 1754967720, win 4096, length 0</span><br><span class="line">20:33:26.827472 IP 103.235.46.39.80 &gt; 192.168.0.102.58165: Flags [.], ack 621839160, win 776, length 0</span><br><span class="line">20:33:26.827677 IP 103.235.46.39.80 &gt; 192.168.0.102.58165: Flags [F.], seq 1754967720, ack 621839160, win 776, length 0</span><br><span class="line">20:33:26.827729 IP 192.168.0.102.58165 &gt; 103.235.46.39.80: Flags [.], ack 1754967721, win 4096, length 0</span><br></pre></td></tr></table></figure></p>
<p>不多不少，刚好4次。</p>
<h3 id="TCP状态变更"><a href="#TCP状态变更" class="headerlink" title="TCP状态变更"></a>TCP状态变更</h3><p>网络上有一张TCP状态机的图，我觉得太复杂了，用自己的方式搞个简单点的容易理解的。我从两个角度来说明状态的变更。</p>
<ul>
<li>一个是客户端</li>
<li>一个是服务端</li>
</ul>
<p>看下面两张图的时候，请一定结合上面三次握手、四次挥手的时序图一起看，加深理解。</p>
<h4 id="客户端状态变更"><a href="#客户端状态变更" class="headerlink" title="客户端状态变更"></a>客户端状态变更</h4><p><img src="https://dayutalk.cn/img/tcp-4th.png" alt="tcp-4th"></p>
<p>通过这张图，大家是否能够清晰明了的知道 TCP 在客户端上的变更情况了呢？</p>
<h4 id="服务端状态变更"><a href="#服务端状态变更" class="headerlink" title="服务端状态变更"></a>服务端状态变更</h4><p><img src="https://dayutalk.cn/img/tcp-5th.png" alt="tcp-5th"></p>
<p>这一张图描述了 TCP 状态在服务端的变迁。</p>
<h2 id="TCP的流量控制与拥塞控制"><a href="#TCP的流量控制与拥塞控制" class="headerlink" title="TCP的流量控制与拥塞控制"></a>TCP的流量控制与拥塞控制</h2><p>我们常说TCP是面向连接的，UDP是无连接的。那么TCP这个面向连接主要解决的是什么问题呢？</p>
<p>这里继续把三次握手的抓包数据贴出来分析下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20:33:26.583598 IP 192.168.0.102.58165 &gt; 103.235.46.39.80: Flags [S], seq 621839080, win 65535, options [mss 1460,nop,wscale 6,nop,nop,TS val 1050275400 ecr 0,sackOK,eol], length 0</span><br><span class="line">20:33:26.660754 IP 103.235.46.39.80 &gt; 192.168.0.102.58165: Flags [S.], seq 1754967387, ack 621839081, win 8192, options [mss 1452,nop,wscale 5,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,sackOK,eol], length 0</span><br><span class="line">20:33:26.660819 IP 192.168.0.102.58165 &gt; 103.235.46.39.80: Flags [.], ack 1754967388, win 4096, length 0</span><br></pre></td></tr></table></figure>
<p>上面我们说到 <code>TCP</code> 的三次握手最重要的就是协商传输数据用的序列号。那这个序列号究竟有些什么用呢？这个序号能够帮助后续两端进行确认数据包是否收到，解决顺序、丢包问题；另外我们还可以看到有一个 <strong>win</strong> 字段，这是双方交流的窗口大小，这在每次传输数据过程中也会携带。主要是告诉对方，我窗口是这么大，别发多了或者别发太少。</p>
<p>总结下，TCP的几个特点是：</p>
<ul>
<li>顺序问题，依靠序号</li>
<li>丢包问题，依靠序号</li>
<li>流量控制，依靠滑动窗口</li>
<li>拥塞控制，依靠拥塞窗口+滑动窗口</li>
<li>连接维护，三次握手/四次挥手</li>
</ul>
<h3 id="顺序与丢包问题"><a href="#顺序与丢包问题" class="headerlink" title="顺序与丢包问题"></a>顺序与丢包问题</h3><p>这个问题其实应该很好理解。由于数据在传输前我们已经有序号了，这里注意一下这个序号是随机的，重复的概率极低，避免了程序发生乱入的可能性。</p>
<p>由于我们每个数据包有序号，虽然发送与到达可能不是顺序的，但是TCP层收到数据后，可以根据序号进行重新排列；另外在这个排列过程中，发现有了1，2，3，5，6这几个包，一检查就知道4要么延时未到达，要么丢包了，等待重传。</p>
<p>这里需要重要说明的一点是。为了提升效率，TCP其实并不是收到一个包就发一个ack。那是如何ACK的呢？还是以上面为例，TCP收到了1,2,3,5,6这几个包，它可能会发送一个 <code>ack ，seq=3</code> 的确认包，这样次一次确认了3个包。但是它不会发送 5,6 的ack。因为4没有收到啊！一旦4延时到达或者重发到达，就会发送一个 <code>ack, seq=6</code>，又一次确认了3个包。</p>
<h3 id="流量控制与拥塞控制"><a href="#流量控制与拥塞控制" class="headerlink" title="流量控制与拥塞控制"></a>流量控制与拥塞控制</h3><p>这两个概念说实话，让我理解了挺长时间，主要是对它们各自控制的内容以及相互之间是否有作用一直没有闹清楚。</p>
<p>先大概说下：</p>
<ul>
<li>流量控制：是根据接收方的窗口大小来感知我这次能够传多少数据给对方；—— 滑动窗口</li>
<li>拥塞控制：而拥塞控制主要是避免网络拥塞，它考虑的问题更多。根据综合因素来觉得发多少数据给对方；—— 滑动窗口&amp;拥塞窗口</li>
</ul>
<p>举个例子说下，比如：A给B发送数据，通过握手后，A知道B一次可以收1000的数据（B有这么大的处理能力），那么这个时候滑动窗口就可以设置成1000。那是不是最后真的可以一次发这么多数据给B呢？还不是，这时候得问问拥塞窗口，老兄，现在网络情况怎么样？一次运1000的数据有压力吗？拥塞窗口一通计算说不行，现在是高峰期，最多只能有600的货上路。最终这次传数据的时候就是 600 的标注。大家也可以关注抓包数据的 <strong>win</strong> 值，一直在动态调整。</p>
<p>当然另外一种情况是滑动窗口比拥塞窗口小，虽然运输能力强，但是接收能力有限，这时候就要取滑动窗口的值来实际发生。所以它们二者之间是有关系的。</p>
<p>所以具体到每次能够发送多少数据，有这么一个公式：</p>
<blockquote>
<p>LastByteSend - LastByteAcked &lt;= min{cwnd,rwnd}</p>
</blockquote>
<ul>
<li>LastByteSend 是最后一个发送的字节的序号</li>
<li>LastByteAcked 最后一个被确认的字节的序号</li>
</ul>
<p>这两个相减得到的是本次能够发送的数据，这个数据一定小于或等于 cwnd 与 rwnd 中最小的一个值。相信大家能够理清楚。</p>
<p>那么这部分知识对于实际工作中有什么作用呢？指导意义就是：如果你的业务很重要、很核心一定不要混布；二是如果你的服务忽快忽慢，而确信依赖服务没有问题，检查下机器对应的网络情况；三是窗口这个速度控制机制，在我们进行服务设计的时候，非常具有参考意义。是不是有点消息队列的感觉？（很多消息队列都是匀速的，我们是否可以加一个窗口的概念来进行优化呢？）</p>
<h2 id="是什么限制了你的连接"><a href="#是什么限制了你的连接" class="headerlink" title="是什么限制了你的连接"></a>是什么限制了你的连接</h2><p>到了最关键的地方了，精华我都是留到最后讲。下面放一张网上找的socket操作步骤图，画的太好了我就直接用了。<br><img src="https://dayutalk.cn/img/tcp-6th.jpg" alt="tcp-6th"></p>
<p>我们假设我的服务端就是 <code>Nginx</code> ，我来尝试解读一下。当客户端调用 <code>connect()</code> 时候就会发起三次握手，这次握手的时候有几个元素唯一确定了这次通信（或者说这个socket），<strong>[源IP:源Port， 目的IP:目的Port]</strong> ，当然这个socket还不是最终用来传输数据的socket，一旦握手完成后，服务端会在返回一个 <strong>socket</strong> 专门用来后续的数据传输。这里暂且把第一个socket叫 <strong>监听socket</strong>，第二个叫 <strong>传输socket</strong> 方便后文叙述。</p>
<p>为什么要这么设计呢？大家想一想，如果监听的socket还要负责数据的收发，请问这个服务端的效率如何提升？什么东西、谁都往这个socket里边丢，太复杂！</p>
<h3 id="提高连接常用套路"><a href="#提高连接常用套路" class="headerlink" title="提高连接常用套路"></a>提高连接常用套路</h3><p>到了这一步，我们现在先停下来算算自己的服务器机器能够有多少连接呢？这个极限又是如何一步步被突破呢？</p>
<p>先说 <strong>监听socket</strong> ，服务器的port一般都是固定的，服务器的ip当然也是固定的（单机）。那么上面的结构 <strong>[源IP:源Port， 目的IP:目的Port]</strong> 其实只有客户端的ip与端口可以发生变化。假设客户端用的是IPv4，那么理论连接数是：2^32(ip数) * 2^16(端口数) = 2^48。</p>
<p>看起来这个值蛮大的。但是真的能够有这么多连接吗？不可能的，因为每一个socket都需要消耗内存；以及每一个进程的文件描述符是有上限的。这些都限制了最终的连接数。</p>
<p>那么如何进行调和呢？我知道的操作有：多进程、多线程、IO多路服用、协程等手段组合使用。</p>
<h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>也就是监听是一个进程，一旦accept后，对于 <strong>传输socket</strong> 我们就fork一个新的子进程来处理。但是这种方式太重，fork一个进程、销毁一个进程都是特别费事的。单机对进程的创建上限也是有限制的。</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>线程比进程要轻量级的多，它会共享父进程的很多资源，比如：文件描述符、进程空间，它就是多了一个引用。因此它的创建、销毁更加容易。每一个 <strong>传输socket</strong> 在这里就交给了线程来处理。</p>
<p>但是不管是多进程、还是多线程都存在一个问题，一个连接对应一个进程或者协程。这都很难逃脱 <strong>C10K</strong> 的问题。那么该怎么办呢？</p>
<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>IO多路复用是什么意思呢？在上面单纯的多进程、多线程模型中，一个进程或线程只能处理一个连接。用了IO多路复用后，我一个进程或线程就能处理多个连接。</p>
<p>我们都知道 <code>Nginx</code> 非常高效，它的结构是：master + worker，worker 会在 80、443端口上来监听请求。它的worker一般设置为 cpu 的cores数，那么这么少的子进程是如何解决超多连接的呢？这里其实每个worker就采用了 epoll 模型（当然IO多路复用还有个select，这里就不说了）。</p>
<p>处于监听状态的worker，会把所有 <strong>监听socket</strong> 加入到自己的epoll中。当这些socket都在epoll中时，如果某个socket有事件发生就会立即被回调唤醒（这涉及epoll的红黑树，讲不清楚不细说了）。这种模式，大大增加了每个进程可以管理的socket数量，上限直接可以上升到进程能够操作的最大文件描述符。</p>
<p>一般机器可以设置百万级别文件描述符，所以单机单进程就是百万连接，<strong>epoll是解决C10K的利器，很多开源软件用到了它。</strong></p>
<blockquote>
<p>这里说下，并不是所有的worker都是同时处于监听端口的状态，这涉及到nginx惊群、抢自旋锁的问题，不再本文范围内不多说。</p>
</blockquote>
<h3 id="关于ulimit"><a href="#关于ulimit" class="headerlink" title="关于ulimit"></a>关于ulimit</h3><p>在文章的最后，补充一些单机文件描述符设置的问题。我们常说连接数受限于文件描述符，这是为什么？</p>
<p>因为在linux上一切皆文件，故每一个socket都是被当作一个文件看待，那么每个文件就会有一个文件描述符。在linux中每一个进程中都有一个数组保存了该进程需要的所有文件描述符。这个文件描述符其实就是这个数组的 <code>key</code> ，它的 <code>value</code> 是一个指针，指向的就是打开的对应文件。</p>
<p>关于文件描述符有两点注意：</p>
<ol>
<li>它对应的其实是一个linux上的文件</li>
<li>文件描述符本身这个值在不同进程中是可以重复的</li>
</ol>
<p>另外补充一点，单机设置的ulimit的上线受限与系统的两个配置：</p>
<blockquote>
<p>fs.nr_open，进程级别</p>
<p>fs.file-max，系统级别</p>
</blockquote>
<p>fs.nr_open 总是应该小于等于 fs.file-max，这两个值的设置也不是随意可以操作，因为设置的越大，系统资源消耗越多，所以需要根据真实情况来进行设置。</p>
<hr>
<p>至此，本篇长文就完结了。这跟上篇 <a href="https://dayutalk.cn/2019/04/25/%E4%BB%8E%E5%B8%B8%E8%A7%81%E6%9E%B6%E6%9E%84%E8%B0%88CDN%E4%B8%8EDNS/">高并发架构的CDN知识介绍</a> 属于一个系列，高并发架构需要理解的网络基础知识。</p>
<p>后面还会写一下 HTTP/HTTPS 的知识。然后关于高并发网络相关的东西就算完结。我会开启下一个篇章。</p>
<hr>
<p>如果你想对网络协议了解更多，推荐一个课程：<br><img src="https://dayutalk.cn/img/tcp-7th.jpeg" alt="tcp-7th"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[高并发架构的CDN知识介绍]]></title>
      <url>http://dayutalk.cn/2019/04/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E7%9A%84CDN%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>来印度工作了，想家的时候，写了这篇CDN，请理解<br><a id="more"></a></p>
<p>对一次网络请求过程的了解程度，一是展现你的专业知识；二是深刻的理解，让你在大型网站架构中做出更适合、可靠的架构。而DNS是这一切的出发点，本文结合一张常用架构图，来描述一下这个过程。</p>
<h1 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h1><p>大型的web服务，我们的部署架构一般如下图。先上图再解释。<br><img src="https://dayutalk.cn/img/Architecture.jpg" alt="大流量架构图"></p>
<p>这里来解释下，为什么要这样架构。<br>首先客户端的请求会通过 <code>DNS</code> 获取到对应的服务器IP（实际上是LB的ip地址），这一层会有 <strong>DNS的负载均衡</strong>，并且如果是静态站资源会进入到CDN，这里DNS与CDN如何完成接棒的过程，后面会详细解释。<br>当请求到达LB层的时候（应用层协议是HTTP协议），这一层又会做一次负载均衡（可能用LVS或者Nginx做）。这里我们有两种不同的处理方式，一条路径会进入到代理集群，一条路径直接进入到应用集群。这是为什么？</p>
<h2 id="LB到代理集群"><a href="#LB到代理集群" class="headerlink" title="LB到代理集群"></a>LB到代理集群</h2><p>通过最顶层的LB负责均衡后到达代理机器，这里不直接进入到应用集群，还要搞一层代理的目的主要是方便我们在代理集群进行各种高级（骚）操作。</p>
<p>比如：请求日志收集，自定义缓存，自定义的负载均衡，自定义的路由规则制定（跨机房，路由分组）</p>
<h2 id="LB到应用集群"><a href="#LB到应用集群" class="headerlink" title="LB到应用集群"></a>LB到应用集群</h2><p>上面到代理层有那么多好处，为什么还有绕过代理层这条路径存在呢？这主要是针对大流量服务。因为代理层因为有很多额外的操作，导致响应会变长，路径增加，到下一个集群多了一次网络传输往返。</p>
<p>所以，一般针对大流量服务，为了防止代理被打满，响应更快，会直接在外网LB上进行负载到应用集群。</p>
<p>通过上面的分割后，最终都会到达应用集群，每一台机器上我们会部署一台 <code>Nginx</code> 来按照域名转到对应服务，当然这里完全也可以不是 <code>Nginx</code> ，比如微服务，这里可能是一个 <code>SideCard</code> 代理。这里主要是为了便于说明我们后面全部都是当成Nginx。服务调用 <code>DB</code> <code>Cache</code> 等，都是通过域名，这是为了负载均衡，请求时，会通过内网DNS服务，完成域名解析，然后拿到内网的 <code>LB</code> 的IP。然后再这里进行内网的负载均衡，会根据域名的端口来检查你是写操作、还是读操作返回IP。常规一点会保证是单点写入，多点读取。来完成数据一致性的保障。</p>
<p>整个大体过程如此，接下来我们详细说一下 <code>DNS</code> 与 <code>CDN</code> 相关的工作原理。</p>
<h1 id="DNS如何实现IP查找"><a href="#DNS如何实现IP查找" class="headerlink" title="DNS如何实现IP查找"></a>DNS如何实现IP查找</h1><p>为了后面说清楚CDN，这里先介绍DNS的解析过程。当然此类文章网络上已经极多。但是我还是想按照我的理解来说一下DNS是如何工作的。</p>
<p>在整个DNS过程中有四个重要概念，下面解释下。</p>
<p><strong>DNS Resolver</strong> - 递归解析器，主要是接收客户端发出的域名解析请求，并发送 DNS query 查询请求。对于客户端来说它不需要任何操劳，等待 DNS Resolver 告诉自己域名转IP的结果就好。</p>
<p><strong>Root Server</strong> - 这是转换IP执行的第一步查询，根服务器并不会保存具体的域名IP映射信息。它就像一个索引服务器，会告诉你下一步该去那台 <strong>TLD Server</strong> 查询。</p>
<p><strong>TLD Server</strong> - 这是顶级域名服务器，是执行IP查询的第二步，这里会告诉 <strong>DNS Resolver</strong> 权威域名服务器的地址。</p>
<p><strong>Authoriative Server</strong> - 权威域名服务器就是包含了完整的机器名的域名，例如：www.example.com ，在这台机器上保存了这个具体域名对应的IP地址。</p>
<p><img src="https://dayutalk.cn/img/dns-lookup-diagram.png" alt="dns-lookup-diagram"></p>
<p>下面根据图中的十个步骤说一下每一步都在干嘛。</p>
<ol>
<li>一个用户在浏览器输入了：example.com，这时会产生一个 DNS 查询，从而进入到 DNS Resolver中；</li>
<li>Resolver 会进入到 root server 进行查询；</li>
<li>root server 返回了 TLD server 的地址，查询请求转向顶级域名服务，这里是 .com 服务器。</li>
<li>递归解析器向 .com 服务器发送一个请求；</li>
<li>TLD server 收到请求后会返回 example.com 权威服务器的地址；</li>
<li>递归解析器又发了一个向权威服务器查询的请求，至此权威服务器查询自己的映射表拿到IP；</li>
<li>返回查询到的IP给了 DNS Resolver；</li>
<li>DNS Resolver返回IP给浏览器，浏览器将会用这个IP来建立连接，发起请求;</li>
<li>客户端通过这个IP地址，发起一个 HTTP 请求；</li>
<li>服务器解析请求，并返回数据到浏览器。</li>
</ol>
<p>这里需要补充一点是，上面每一步其实都有DNS缓存的设计。比如：</p>
<ul>
<li>浏览器会缓存DNS的结果，（chrome://net-internals/#dns）</li>
<li>操作系统的DNS模块会缓存</li>
<li>后面的每一层级也都有缓存</li>
</ul>
<p>所以很多时候，我们的解析过程并不是要顺序执行完这8个步骤。这就跟我们自己开发的应用服务一样，层层缓存，有缓存就读取缓存结果，缓存实现就执行完整流程。</p>
<h2 id="DNS的解析分类"><a href="#DNS的解析分类" class="headerlink" title="DNS的解析分类"></a>DNS的解析分类</h2><p>DNS有多种解析记录可以设置，我这里介绍三个很常用的设计。</p>
<p><strong>A记录</strong> - 被称为IP指向，用户设置自域名指到对应的IP主机上。如果想要利用A记录实现 <strong>负载均衡</strong> 需要主机商的支持。<br><strong>CNAME记录</strong> - 它相当于为一个主机名设置一个别名，而且该记录不能直接使用IP，只能是另一个主机的别名。CDN主要就是利用该记录来完成的。如果有A记录与CNAME记录同时存在，A记录会被优先使用，换句话说CNAME记录不会生效。<br><strong>NS记录</strong> - 用来设置一个域名的权威服务器路径，该记录只会对子域名生效。这个地方可以设置IP也可以设置另外一个权威服务器的域名。需要重点指出的是它的优先级高于A记录，并且它在DNS解析过程中，会跳过2，3，4，5步。</p>
<p>了解完了DNS的步骤，接下来就进入到CDN部分的分析。</p>
<h1 id="CDN访问加速度"><a href="#CDN访问加速度" class="headerlink" title="CDN访问加速度"></a>CDN访问加速度</h1><p>什么是CDN呢？中文翻译过来就是内容分发网络。看张图。<br><img src="https://dayutalk.cn/img/2circles.png" alt="2circles"></p>
<p>没有CDN的时候，不管哪里的用户访问我们的站点，都需要到我们数据中心来获取数据(单纯的DNS过程)。而有了CDN之后，用户根据自己的地理位置会选择距离自己最近的缓存数据中心来获取数据。不会每次都到源站（应用服务器）来获取数据。为了理解这个过程，我们是如果在完整的DNS过程中，实现CDN的呢？</p>
<p>接下来我们需要回答两个问题。</p>
<ol>
<li>CDN带来了什么好处。</li>
<li>如何解析到CDN。</li>
</ol>
<h2 id="CDN带来的好处"><a href="#CDN带来的好处" class="headerlink" title="CDN带来的好处"></a>CDN带来的好处</h2><p>了解一个东西之前最好知道它能干什么，带来的好处是什么。然后我们再去看它的运行原理。对于CDN有以下几个方面的好处。</p>
<h3 id="提高页面加载速度"><a href="#提高页面加载速度" class="headerlink" title="提高页面加载速度"></a>提高页面加载速度</h3><p>这是最显而易见的一个优势，通过上面的图，大家也可以直观感受下，用户访问距离自己最近的机器，速度肯定是最快的。并且网站的加载速度越快那么用户体验越优秀，你的网站更会受到对应用户的喜爱。至于如何实现就近访问的，后面原理部分介绍。</p>
<h3 id="增加内容的冗余"><a href="#增加内容的冗余" class="headerlink" title="增加内容的冗余"></a>增加内容的冗余</h3><p>CDN是一个典型的分布式架构，它通过增加数据的冗余，一方面保障在大流量面前有多台服务器能够提供相同的数据；另一方面当部分机器出现故障时，可以进行自动转移。</p>
<h3 id="节省带宽"><a href="#节省带宽" class="headerlink" title="节省带宽"></a>节省带宽</h3><p>如果大家自己买过云服务就知道，带宽每增加一点价格就飙升。使用CDN后，由于流量被分流了，那么原机器带宽要求自然就降低了。当然带宽费用降低了，你还需要为CDN付费。</p>
<h3 id="保障服务安全"><a href="#保障服务安全" class="headerlink" title="保障服务安全"></a>保障服务安全</h3><p>CDN可防止的攻击：<code>DDOS攻击</code>，该攻击就是通过巨大流量打满你的带宽，让你丧失服务能力。那么由于CDN的存在，它将巨大的流量进行了分流。那么源站压力自然小了。这其实也是高并发需要考虑的。</p>
<p>CDN目前不仅仅是只能缓存静态的HTML、CSS、JS、VIDEO，现在还有能够缓存动态接口内容的CDN，这为我们在架构高并发的服务时，提供了更多的手段进行选择。</p>
<h2 id="CDN工作原理"><a href="#CDN工作原理" class="headerlink" title="CDN工作原理"></a>CDN工作原理</h2><p>在介绍DNS的时候，介绍了客户端是如何获取到IP地址的。那么有了CDN之后，这个过程该怎么处理呢？</p>
<p>CDN其实更像是放在应用服务器与用户之间的一层缓存。所以如果DNS的时候，返回给客户端的是CDN机器的IP而不是应用的IP，那么自然就走到了CDN机器上。</p>
<p>为了实现上述目的，我们会为该域名配置一个 <code>CNAME</code>（大家注意上面提到的CNAME与A记录的优先级），那么这个CNAME是最终如何解析到对应的CDN机器呢？其实流程与DNS解析是一样的。当发现一个域名设置了CNAME时，DNS解析器会继续解析这个CNAME别名（其实就是另一个域名）。对这个CNAME解析的时候会用到全局负载DNS解析，它会根据访问者的地理位置信息返回对应的IP（CDN机器的IP）。因此客户端实际上得到的是距离它最近的CDN机器的IP地址。</p>
<p>如果说用户访问CDN，但是CDN上没有对应内容会怎么办？此时CDN机器其实会根据自身专用的DNS解析服务，根据域名得到源站的IP，然后向源站发送请求获取数据，并把这些数据缓存到本地，方便后续使用；同时返回本次结果，完成本次请求的访问。</p>
<p>需要说一下的是，CDN其实也是分层的。距离用户最近的称之为边缘节点。而CDN的中心服务器集群被称为二级缓存。在上面就是应用部署的源站。一般边缘节点没数据就去找二级缓存，二级缓存没数据就去找源站（被称为回源）。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>关于 <code>DNS</code> 的过程，文中是以流程介绍为主，至于更细节的依赖协议、传输过程都忽略了。 关于CDN也是我们经常用到的性能提升手段，后续要写的秒杀相关文章，就会用到它来提升性能。特别是CDN的分布式设计、解析过程在我们平常设计应用架构时非常有参考意义。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coder，你会设计交易系统吗？]]></title>
      <url>http://dayutalk.cn/2019/02/25/coder%EF%BC%8C%E4%BD%A0%E4%BC%9A%E8%AE%BE%E8%AE%A1%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%90%97%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>现在的互联网业务，都少不了支付这个环节。那么如何去设计一个通用的服务，满足各个产品线的需求？希望本文能够给你带来收获！<br><a id="more"></a></p>
<p>文中我们从严谨的角度一步步聊到支付如何演变成独立的系统。内容包括：系统演进过程、接口设计、数据库设计以及代码如何组织的示例。若有不足之处，欢迎讨论共同学习。</p>
<h1 id="从模块到服务"><a href="#从模块到服务" class="headerlink" title="从模块到服务"></a>从模块到服务</h1><p>我记得最开始工作的时候，所有的功能：加购物车/下单/支付 等逻辑都是放在一个项目里。如果一个新的项目需要某个功能，就把这个部分的功能包拷贝到新的项目。数据库也原封不动的拷贝过来，稍微根据需求改改。</p>
<p>这就是所谓的 <strong>单体应用</strong> 时代，随着公司产品线开始多元，每条产品线都需要用到支付服务。如果支付模块调整了代码，那么就会处处改动、处处测试。另一方面公司的交易数据割裂在不同的系统中，无法有效汇总统一分析、管理。</p>
<p>这时就到了系统演进的时候，我们把每个产品线的支付模块抽离成统一的服务。对自己公司内部提供统一的API使用，可以对这些API进一步包装成对应的SDK，供内部业务线快速接入。这里服务使用HTTP或者是RPC协议都可以根据公司实际情况决定。不过如果考虑到未来给第三方使用，建议使用HTTP协议，</p>
<p><strong>系统的演变过程：</strong></p>
<p><img src="https://dayutalk.cn/img/image-20190309104541749.png" alt="image-20190309104541749"></p>
<p>总结下，将支付单独抽离成服务后，带来好处如下：</p>
<ol>
<li>避免重复开发，数据隔离的现象出现；</li>
<li>支付系统周边功能演进更容易，整个系统更完善丰满。如：对账系统、实时交易数据展示；</li>
<li>随时可对外开发，对外输出Paas能力，成为有收入的项目；</li>
<li>专门的团队进行维护，系统更有机会演进成顶级系统；</li>
<li>公司重要账号信息保存一处，风险更小。</li>
</ol>
<h1 id="系统能力"><a href="#系统能力" class="headerlink" title="系统能力"></a>系统能力</h1><p>如果我们接手该需求，需要为公司从零搭建支付系统。我们该从哪些方面入手？这样的系统到底需要具备什么样的能力呢？</p>
<p>首先支付系统我们可以理解成是一个适配器。他需要把很多第三方的接口进行统一的整合封装后，对内部提供统一的接口，减少内部接入的成本。做为一个最基本的支付系统。需要对内提供如下接口出来：</p>
<ol>
<li>发起支付，我们取名：<code>/gopay</code></li>
<li>发起退款，我们取名：<code>/refund</code></li>
<li>接口异步通知，我们取名：<code>/notify/支付渠道/商户交易号</code></li>
<li>接口同步通知，我们取名：<code>/return/支付渠道/商户交易号</code></li>
<li>交易查询，我们取名：<code>/query/trade</code></li>
<li>退款查询，我们取名：<code>/query/refund</code></li>
<li>账单获取，我们取名：<code>/query/bill</code></li>
<li>结算明细，我们取名：<code>/query/settle</code></li>
</ol>
<p>一个基础的支付系统，上面8个接口是肯定需要提供的（这里忽略某些支付中的转账、绑卡等接口）。现在我们来基于这些接口看看都有哪些系统会用到。</p>
<p><img src="https://dayutalk.cn/img/image-20190309111001880.png" alt="image-20190309111001880"></p>
<p>下面按照系统维度，介绍下这些接口如何使用，以及内部的一些逻辑。</p>
<h2 id="应用系统"><a href="#应用系统" class="headerlink" title="应用系统"></a>应用系统</h2><p>一般支付网关会提供两种方式让应用系统接入：</p>
<ol>
<li>网关模式，也就是应用系统自己需要开发一个收银台；（适合提供给第三方）</li>
<li>收银台模式，应用系统直接打开支付网关的统一收银台。（内部业务）</li>
</ol>
<p>下面为了讲清楚设计思路，我们按照 <strong>网关模式</strong> 进行讲解。</p>
<p>对于应用系统它需要能够请求支付，也就是调用 <code>gopay</code> 接口。这个接口会处理商户的数据，完成后会调用第三方网关接口，并将返回结果统一处理后返回给应用方。</p>
<p>这里需要注意，第三方针对支付接口根据我的经验大致有以下情况：</p>
<ol>
<li>支付时，不需要调用第三方，按照规则生成数据即可；</li>
<li>支付时，需要调用第三方多个接口完成逻辑（这可能比较慢，大型活动时需要考虑限流/降配）；</li>
<li>返回的数据是一个url，可直接跳转到第三方完成支付（wap/pc站）；</li>
<li>返回的数据是xml/json结构，需要拼装或作为参数传给她的sdk（app）。</li>
</ol>
<p>这里由于第三方返回结构的不统一，我们需要统一处理成统一格式，返回给商户端。我推荐使用json格式。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"errno"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">"msg"</span>:<span class="string">"ok"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把所有的变化封装在 <strong>data</strong> 结构中。举个例子，如果返回的一个url。只需要应用程序发起 <strong>GET</strong> 请求。我们可以这样返回：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"errno"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">"msg"</span>:<span class="string">"ok"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"url"</span>:<span class="string">"xxxxx"</span>,</span><br><span class="line">        <span class="attr">"method"</span>:<span class="string">"GET"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是返回的结构，需要应用程序直接发起 <strong>POST</strong> 请求。我们可以这样返回：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"errno"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"msg"</span>:<span class="string">"ok"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"from"</span>:<span class="string">"&lt;form action="</span>xxx<span class="string">" method="</span>POST<span class="string">"&gt;xxxxx&lt;/form&gt;"</span>,</span><br><span class="line">        <span class="attr">"method"</span>:<span class="string">"POST"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <strong>form</strong> 字段，生成了一个form表单，应用程序拿到后可直接显示然后自动提交。当然封装成 from表单这一步也可以放在商户端进行。</p>
<p>上面的数据格式仅仅是一个参考。大家可根据自己的需求进行调整。</p>
<p>一般应用系统除了会调用发起支付的接口外，可能还需要调用 <strong>支付结果查询接口</strong>。当然大多数情况下不需要调用，应用系统对交易的状态只应该依赖自己的系统状态。</p>
<p>##对账系统</p>
<p>对于对账，一般分为两个类型：<strong>交易对账</strong> 与 <strong>结算对账</strong></p>
<h3 id="交易对账"><a href="#交易对账" class="headerlink" title="交易对账"></a>交易对账</h3><p>交易对账的核心点是：<strong>检查每一笔交易是否正确</strong>。它主要目的是看我们系统中的每一笔交易与第三方的每一笔交易是否一致。</p>
<p>这个检查逻辑很简单，对两份账单数据进行比较。它主要是使用 <code>/query/bill</code> 接口，拿到在第三方那边完成的交易数据。然后跟我方的交易成功数据进行比较。检查是否存在误差。</p>
<p>这个逻辑非常简单，但是有几点需要大家注意：</p>
<ol>
<li>我方的数据需要正常支付数据+重复支付数据的总和；</li>
<li>对账检查不成功主要包括：<strong>金额不对</strong>、<strong>第三方没有找到对应的交易数据</strong>、<strong>我方不存在对应的交易数据</strong>。</li>
</ol>
<p>针对这些情况都需要有对应的处理手段进行处理。在我的经验中上面的情况都有过遇到。</p>
<p><strong>金额不对</strong>：主要是由于第三方的问题，可能是系统升级故障、可能是账单接口金额错误；</p>
<p><strong>第三方无交易数据：</strong> 可能是拉去的账单时间维度问题（比如存在时差），这种时区问题需要自己跟第三方确认找到对应的时间差。也可能是被攻击，有人冒充第三方异步通知（说明系统校验机制又问题或者密钥泄漏了）。</p>
<p><strong>自己系统无交易数据：</strong> 这种原因可能是第三方通知未发出或者未正确处理导致的。</p>
<p>上面这些问题的处理绝大部份都可以依赖 <code>query/trade</code>  <code>query/refund</code> 来完成自动化处理。</p>
<h3 id="结算对账"><a href="#结算对账" class="headerlink" title="结算对账"></a>结算对账</h3><p>那么有了上面的 <strong>交易对账</strong> 为什么还需要 <strong>结算对账</strong> 呢？这个系统又是干嘛的？先来看下结算的含义。</p>
<blockquote>
<p>结算，就是第三方网关在固定时间点，将T+x或其它约定时间的金额，汇款到公司账号。</p>
</blockquote>
<p>下面我们假设结算周期是： <strong>T+1</strong>。结算对账主要使用到的接口是 <code>/query/settle</code>，这个接口获取的主要内容是：每一笔结算的款项都是由哪些笔交易组成（交易成功与退款数据）。以及本次结算扣除多少手续费用。</p>
<p>它的逻辑其实也很简单。我们先从自己的系统按照 <strong>T+1</strong> 的结算周期，计算出对方应该汇款给我们多少金额。然后与刚刚接口获取到的数据金额比较：</p>
<blockquote>
<p>银行收款金额 + 手续费 = 我方系统计算的金额</p>
</blockquote>
<p>这一步检查通过后，说明金额没有问题。接下来需要检查本次结算下的每一笔订单是否一致。</p>
<p>结算系统是 <strong>强依赖</strong> 对账系统的。如果对账发现异常，那么结算金额肯定会出现异常。另外结算需要注意的一些问题是：</p>
<ul>
<li>银行可能会自行退款给用户，因为用户可直接向自己发卡行申请退款；</li>
<li>结算也存在时区差问题；</li>
<li>结算接口中的明细交易状态与我方并不完全一致。比如：银行结算时发现某笔退款完成，但我方系统在进行比较时按照未退款完成的逻辑在处理。</li>
</ul>
<p>针对上面的问题，大家根据自己的业务需求需要做一些方案来进行自动化处理。</p>
<p>##财务系统</p>
<p>财务系统有很多内部业务，我这里只聊与支付系统相关的。（当然上面的对账系统也可以算是财务范畴）。</p>
<p>财务系统与支付主要的一个关系点在于校验交易、以及退款。这里校验交易可以使用 <code>query/trade</code>  <code>query/refund</code>这两个接口来完成。这个逻辑过程就不需要说了。下面重点说下退款。</p>
<p>我看到很多的系统退款是直接放在了应用里边，用户申请退款直接就调用退款接口进行退款。这样的风险非常高。支付系统的关于资金流向的接口一定要慎重，不能过多的直接暴露给外部，带来风险。</p>
<p>退款的功能应该是放到财务系统来做。这样可以走内部的审批流程（是否需要根据业务来），并且在财务系统中可以进行更多检查来觉得是否立即进行退款，或者进入等待、拒绝等流程。</p>
<h2 id="第三方网关"><a href="#第三方网关" class="headerlink" title="第三方网关"></a>第三方网关</h2><p>针对第三方主要使用到的其实就是异步通知与同步通知两个接口。这一部分的逻辑其实非常简单。就是根据第三方的通知完成交易状态的变更。以及通知到自己对应的应用系统。</p>
<p>这部分比较复杂的是，第三方的通知数据结构不统一、通知的类型不统一。比如：有的退款是同步返回结果、有的是异步返回结果。这里如何设计会在后面的 <strong>系统设计</strong> 中给出答案。</p>
<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p>数据的设计是按照：交易、退款、日志 来设计的。对于上面说到的对账等功能并没有。这部分不难大家可以自行设计，按照上面讲到的思路。主要的表介绍如下：</p>
<ul>
<li><code>pay_transaction</code> 记录所有的交易数据。</li>
<li><code>pay_transaction_extension</code> 记录每次向第三方发起交易时，生成的交易号</li>
<li><code>pay_log_data</code> 所有的日志数据，如：支付请求、退款请求、异步通知等</li>
<li><code>pay_repeat_transaction</code> 重复支付的数据</li>
<li><code>pay_notify_app_log</code> 通知应用程序的日志</li>
<li><code>pay_refund</code> 记录所有的退款数据</li>
</ul>
<p><strong>具体的表结构：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- -----------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Table 创建支付流水表</span></span><br><span class="line"><span class="comment">-- -----------------------------------------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`pay_transaction`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`app_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'应用id'</span>,</span><br><span class="line">  <span class="string">`pay_method_id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'支付方式id，可以用来识别支付，如：支付宝、微信、Paypal等'</span>,</span><br><span class="line">  <span class="string">`app_order_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'应用方订单号'</span>,</span><br><span class="line">  <span class="string">`transaction_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'本次交易唯一id，整个支付系统唯一，生成他的原因主要是 order_id对于其它应用来说可能重复'</span>,</span><br><span class="line">  <span class="string">`total_fee`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'支付金额，整数方式保存'</span>,</span><br><span class="line">  <span class="string">`scale`</span> TINYINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'金额对应的小数位数'</span>,</span><br><span class="line">  <span class="string">`currency_code`</span> <span class="built_in">CHAR</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'CNY'</span> <span class="keyword">COMMENT</span> <span class="string">'交易的币种'</span>,</span><br><span class="line">  <span class="string">`pay_channel`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'选择的支付渠道，比如：支付宝中的花呗、信用卡等'</span>,</span><br><span class="line">  <span class="string">`expire_time`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'订单过期时间'</span>,</span><br><span class="line">  <span class="string">`return_url`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'支付后跳转url'</span>,</span><br><span class="line">  <span class="string">`notify_url`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'支付后，异步通知url'</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户的邮箱'</span>,</span><br><span class="line">  <span class="string">`sing_type`</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'RSA'</span> <span class="keyword">COMMENT</span> <span class="string">'采用的签方式：MD5 RSA RSA2 HASH-MAC等'</span>,</span><br><span class="line">  <span class="string">`intput_charset`</span> <span class="built_in">CHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'UTF-8'</span> <span class="keyword">COMMENT</span> <span class="string">'字符集编码方式'</span>,</span><br><span class="line">  <span class="string">`payment_time`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'第三方支付成功的时间'</span>,</span><br><span class="line">  <span class="string">`notify_time`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'收到异步通知的时间'</span>,</span><br><span class="line">  <span class="string">`finish_time`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'通知上游系统的时间'</span>,</span><br><span class="line">  <span class="string">`trade_no`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'第三方的流水号'</span>,</span><br><span class="line">  <span class="string">`transaction_code`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'真实给第三方的交易code，异步通知的时候更新'</span>,</span><br><span class="line">  <span class="string">`order_status`</span> TINYINT <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'0:等待支付，1:待付款完成， 2:完成支付，3:该笔交易已关闭，-1:支付失败'</span>,</span><br><span class="line">  <span class="string">`create_at`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_at`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  <span class="string">`create_ip`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'创建的ip，这可能是自己服务的ip'</span>,</span><br><span class="line">  <span class="string">`update_ip`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'更新的ip'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> <span class="string">`uniq_tradid`</span> (<span class="string">`transaction_id`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_trade_no`</span> (<span class="string">`trade_no`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_ctime`</span> (<span class="string">`create_at`</span>)),</span><br><span class="line"><span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4</span><br><span class="line"><span class="keyword">COMMENT</span> = <span class="string">'发起支付的数据'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Table 交易扩展表</span></span><br><span class="line"><span class="comment">-- -----------------------------------------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`pay_transaction_extension`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`transaction_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'系统唯一交易id'</span>,</span><br><span class="line">  <span class="string">`pay_method_id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  <span class="string">`transaction_code`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'生成传输给第三方的订单号'</span>,</span><br><span class="line">  <span class="string">`call_num`</span> TINYINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'发起调用的次数'</span>,</span><br><span class="line">  <span class="string">`extension_data`</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'扩展内容，需要保存：transaction_code 与 trade no 的映射关系，异步通知的时候填充'</span>,</span><br><span class="line">  <span class="string">`create_at`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`create_ip`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建ip'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_trads`</span> (<span class="string">`transaction_id`</span>, <span class="string">`pay_status`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> <span class="string">`uniq_code`</span> (<span class="string">`transaction_code`</span>)),</span><br><span class="line"><span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4</span><br><span class="line"><span class="keyword">COMMENT</span> = <span class="string">'交易扩展表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Table 交易系统全部日志</span></span><br><span class="line"><span class="comment">-- -----------------------------------------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`pay_log_data`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`app_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'应用id'</span>,</span><br><span class="line">  <span class="string">`app_order_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'应用方订单号'</span>,</span><br><span class="line">  <span class="string">`transaction_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'本次交易唯一id，整个支付系统唯一，生成他的原因主要是 order_id对于其它应用来说可能重复'</span>,</span><br><span class="line">  <span class="string">`request_header`</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'请求的header 头'</span>,</span><br><span class="line">  <span class="string">`request_params`</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'支付的请求参数'</span>,</span><br><span class="line">  <span class="string">`log_type`</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'日志类型，payment:支付; refund:退款; notify:异步通知; return:同步通知; query:查询'</span>,</span><br><span class="line">  <span class="string">`create_at`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`create_ip`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'创建ip'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_tradt`</span> (<span class="string">`transaction_id`</span>, <span class="string">`log_type`</span>)),</span><br><span class="line"><span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4</span><br><span class="line"><span class="keyword">COMMENT</span> = <span class="string">'交易日志表'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Table 重复支付的交易</span></span><br><span class="line"><span class="comment">-- -----------------------------------------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`pay_repeat_transaction`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`app_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'应用的id'</span>,</span><br><span class="line">  <span class="string">`transaction_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'系统唯一识别交易号'</span>,</span><br><span class="line">  <span class="string">`transaction_code`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'支付成功时，该笔交易的 code'</span>,</span><br><span class="line">  <span class="string">`trade_no`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'第三方对应的交易号'</span>,</span><br><span class="line">  <span class="string">`pay_method_id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'支付方式'</span>,</span><br><span class="line">  <span class="string">`total_fee`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'交易金额'</span>,</span><br><span class="line">  <span class="string">`scale`</span> TINYINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'小数位数'</span>,</span><br><span class="line">  <span class="string">`currency_code`</span> <span class="built_in">CHAR</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'CNY'</span> <span class="keyword">COMMENT</span> <span class="string">'支付选择的币种，CNY、HKD、USD等'</span>,</span><br><span class="line">  <span class="string">`payment_time`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'第三方交易时间'</span>,</span><br><span class="line">  <span class="string">`repeat_type`</span> TINYINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> <span class="keyword">COMMENT</span> <span class="string">'重复类型：1同渠道支付、2不同渠道支付'</span>,</span><br><span class="line">  <span class="string">`repeat_status`</span> TINYINT <span class="keyword">UNSIGNED</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'处理状态,0:未处理；1:已处理'</span>,</span><br><span class="line">  <span class="string">`create_at`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_at`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_trad`</span> ( <span class="string">`transaction_id`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_method`</span> (<span class="string">`pay_method_id`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_time`</span> (<span class="string">`create_at`</span>)),</span><br><span class="line"><span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4</span><br><span class="line"><span class="keyword">COMMENT</span> = <span class="string">'记录重复支付'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Table 通知上游应用日志</span></span><br><span class="line"><span class="comment">-- -----------------------------------------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`pay_notify_app_log`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`app_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'应用id'</span>,</span><br><span class="line">  <span class="string">`pay_method_id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'支付方式'</span>,</span><br><span class="line">  <span class="string">`transaction_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'交易号'</span>,</span><br><span class="line">  <span class="string">`transaction_code`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'支付成功时，该笔交易的 code'</span>,</span><br><span class="line">  <span class="string">`sign_type`</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'RSA'</span> <span class="keyword">COMMENT</span> <span class="string">'采用的签名方式：MD5 RSA RSA2 HASH-MAC等'</span>,</span><br><span class="line">  <span class="string">`input_charset`</span> <span class="built_in">CHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'UTF-8'</span>,</span><br><span class="line">  <span class="string">`total_fee`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'涉及的金额，无小数'</span>,</span><br><span class="line">  <span class="string">`scale`</span> TINYINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'小数位数'</span>,</span><br><span class="line">  <span class="string">`pay_channel`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'支付渠道'</span>,</span><br><span class="line">  <span class="string">`trade_no`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'第三方交易号'</span>,</span><br><span class="line">  <span class="string">`payment_time`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'支付时间'</span>,</span><br><span class="line">  <span class="string">`notify_type`</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'paid'</span> <span class="keyword">COMMENT</span> <span class="string">'通知类型，paid/refund/canceled'</span>,</span><br><span class="line">  <span class="string">`notify_status`</span> <span class="built_in">VARCHAR</span>(<span class="number">7</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'INIT'</span> <span class="keyword">COMMENT</span> <span class="string">'通知支付调用方结果；INIT:初始化，PENDING: 进行中；  SUCCESS：成功；  FAILED：失败'</span>,</span><br><span class="line">  <span class="string">`create_at`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  <span class="string">`update_at`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_trad`</span> (<span class="string">`transaction_id`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_app`</span> (<span class="string">`app_id`</span>, <span class="string">`notify_status`</span>)</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_time`</span> (<span class="string">`create_at`</span>)),</span><br><span class="line"><span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4</span><br><span class="line"><span class="keyword">COMMENT</span> = <span class="string">'支付调用方记录'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Table 退款</span></span><br><span class="line"><span class="comment">-- -----------------------------------------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`pay_refund`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`app_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'应用id'</span>,</span><br><span class="line">  <span class="string">`app_refund_no`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'上游的退款id'</span>,</span><br><span class="line">  <span class="string">`transaction_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'交易号'</span>,</span><br><span class="line">  <span class="string">`trade_no`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'第三方交易号'</span>,</span><br><span class="line">  <span class="string">`refund_no`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'支付平台生成的唯一退款单号'</span>,</span><br><span class="line">  <span class="string">`pay_method_id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'支付方式'</span>,</span><br><span class="line">  <span class="string">`pay_channel`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'选择的支付渠道，比如：支付宝中的花呗、信用卡等'</span>,</span><br><span class="line">  <span class="string">`refund_fee`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'退款金额'</span>,</span><br><span class="line">  <span class="string">`scale`</span> TINYINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'小数位数'</span>,</span><br><span class="line">  <span class="string">`refund_reason`</span> <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'退款理由'</span>,</span><br><span class="line">  <span class="string">`currency_code`</span> <span class="built_in">CHAR</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'CNY'</span> <span class="keyword">COMMENT</span> <span class="string">'币种，CNY  USD HKD'</span>,</span><br><span class="line">  <span class="string">`refund_type`</span> TINYINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'退款类型；0:业务退款; 1:重复退款'</span>,</span><br><span class="line">  <span class="string">`refund_method`</span> TINYINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> <span class="keyword">COMMENT</span> <span class="string">'退款方式：1自动原路返回; 2人工打款'</span>,</span><br><span class="line">  <span class="string">`refund_status`</span> TINYINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'0未退款; 1退款处理中; 2退款成功; 3退款不成功'</span>,</span><br><span class="line">  <span class="string">`create_at`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_at`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  <span class="string">`create_ip`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'请求源ip'</span>,</span><br><span class="line">  <span class="string">`update_ip`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'请求源ip'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> <span class="string">`uniq_refno`</span> (<span class="string">`refund_no`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_trad`</span> (<span class="string">`transaction_id`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_status`</span> (<span class="string">`refund_status`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_ctime`</span> (<span class="string">`create_at`</span>)),</span><br><span class="line"><span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4</span><br><span class="line"><span class="keyword">COMMENT</span> = <span class="string">'退款记录'</span>;</span><br></pre></td></tr></table></figure>
<p>表的使用逻辑进行下方简单描述：</p>
<p><strong>支付</strong>，首先需要记录请求日志到 <code>pay_log_data</code>中，然后生成交易数据记录到 <code>pay_transaction</code>与<code>pay_transaction_extension</code> 中。</p>
<p><strong>收到通知</strong>，记录数据到 <code>pay_log_data</code> 中，然后根据时支付的通知还是退款的通知，更新 <code>pay_transaction</code> 与 <code>pay_refund</code> 的状态。如果是重复支付需要记录数据到 <code>pay_repeat_transaction</code> 中。并且将需要通知应用的数据记录到 <code>pay_notify_app_log</code>，这张表相当于一个消息表，会有消费者会去消费其中的内容。</p>
<p><strong>退款</strong> 记录日志日志到 <code>pay_log_data</code> 中，然后记录数据到退款表中 <code>pay_refund</code>。</p>
<p>当然这其中还有些细节，需要大家自己看了表结构，实际去思考一下该如何使用。如果有任何疑问欢迎到我们GitHub的项目（点击阅读原文）中留言，我们都会一一解答。</p>
<blockquote>
<p>这些表能够满足最基本的需求，其它内容可根据自己的需求进行扩张，比如：支持用户卡列表、退款走银行卡等。</p>
</blockquote>
<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><p>这部分主要说下系统该如何搭建，以及代码组织方式的建议。</p>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>由于支付系统的安全性非常高，因此不建议将对应的入口直接暴露给用户可见。应该是在自己的应用系统中调用支付系统的接口来完成业务。另外系统对数据要求是：强一致性的。因此也没有缓存介入（当如缓存可以用来做报警，这不在本位范畴）。</p>
<p><img src="https://dayutalk.cn/img/image-20190309135800643.png" alt="image-20190309135800643"></p>
<p>具体的实现，系统会使用两个域名，一个为内部使用，只有指定来源的ip能够访问固定功能（访问除通知外的其它功能）。另一个域名只能访问 <code>notify</code> <code>return</code> 两个路由。通过这种方式可以保证系统的安全。</p>
<p>在数据库的使用上无论什么请求直接走 <strong>Master</strong> 库。这样保证数据的强一致。当然从库也是需要的。比如：账单、对账相关逻辑我们可以利用从库完成。</p>
<h2 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h2><p>不管想做什么最终都要用代码来实现。我们都知道需要可维护、可扩展的代码。那么具体到支付系统你会怎么做呢？我已支付为例说下我的代码结构设计思路。仅供参考。比如我要介入：微信、支付宝、招行 三家支付。我的代码结构图如下：</p>
<p><img src="https://dayutalk.cn/img/image-20190309142925499.png" alt="image-20190309142925499"></p>
<p>用文字简单介绍下。我会将每一个第三方封装成： <code>XXXGateway</code> 类，内部是单纯的封装第三方接口，不管对方是 HTTP 请求还是 SOAP 请求，都在内部进行统一处理。</p>
<p>另外有一层<code>XXXProxy</code> 来封装这些第三方提供的能力。这一层主要干两件事情：对传过来请求支付的数据进行个性化处理。对返回的结构进行统一处理返回上层统一的结构。当然根据特殊情况这里可以进行一切业务处理；</p>
<p>通过上面的操作变化已经基本上被完全封装了。如果新增一个支付渠道。只需要增加：<code>XXXGateway</code> 与 <code>XXXProxy</code>。</p>
<p>那么 <code>Context</code> 与 <code>Server</code> 有什么用呢？<code>Server</code> 内部封装了所有的业务逻辑，它提供接口给 action 或者其它 server 进行调用。而 <code>Context</code> 这一层存在的价值是处理 <code>Proxy</code> 层返回的错误。以及在这里进行报警相关的处理。</p>
<p>上面的结构只是我的一个实践，欢迎大家讨论。</p>
<p>本文描述的系统只是满足了最基本的支付需求。缺少相关的监控、报警。如果你按照上文设计自己的系统，风险自担与我无关。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线上大量CLOSE_WAIT分析]]></title>
      <url>http://dayutalk.cn/2018/12/08/%E7%BA%BF%E4%B8%8A%E5%A4%A7%E9%87%8FCLOSE_WAIT%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>这一次重启真的无法解决问题了：一次 <strong>MySQL</strong> 主动关闭，导致服务出现大量 <strong>CLOSE_WAIT</strong> 的全流程排查过程。<br><a id="more"></a></p>
<p>近日遇到一个线上服务 <strong>socket</strong> 资源被不断打满的情况。通过各种工具分析线上问题,定位到问题代码。这里对该问题发现、修复过程进行一下复盘总结。</p>
<p>先看两张图。一张图是服务正常时监控到的 <strong>socket</strong> 状态，另一张当然就是异常啦！</p>
<p><img src="https://dayutalk.cn/img/image-20181208155626513-4255786.png" alt="image-20181208155626513"></p>
<p align="center"><b>图一：正常时监控</b></p>

<p><img src="https://dayutalk.cn/img/image-20181208160100456-4256060.png" alt="image-20181208160100456"></p>
<p align="center"><b>图二：异常时监控</b></p>

<p>从图中的表现情况来看，就是从 <strong>04:00</strong> 开始，socket 资源不断上涨，每个谷底时重启后恢复到正常值，然后继续不断上涨不释放，而且每次达到峰值的间隔时间越来越短。</p>
<p>重启后，排查了日志，没有看到 <strong>panic</strong> ，此时也就没有进一步检查，真的以为重启大法好。</p>
<h1 id="情况说明"><a href="#情况说明" class="headerlink" title="情况说明"></a>情况说明</h1><p>该服务使用Golang开发，已经上线正常运行将近一年，提供给其它服务调用，主要底层资源有DB/Redis/MQ。</p>
<p>为了后续说明的方便，将服务的架构图进行一下说明。</p>
<p><img src="https://dayutalk.cn/img/image-20181208162049386-4257249.png" alt="image-20181208162049386"></p>
<p align="center"><b>图三：服务架构</b></p>

<p>架构是非常简单。</p>
<p>问题出现在早上 <strong>08:20</strong> 左右开始的，报警收到该服务出现 <strong>504</strong>，此时第一反应是该服务长时间没有重启（快两个月了），可能存在一些内存泄漏，没有多想直接进行了重启。也就是在图二第一个谷底的时候，经过重启服务恢复到正常水平（重启真好用，开心）。</p>
<p>将近 <strong>14:00</strong> 的时候，再次被告警出现了 <strong>504</strong> ，当时心中略感不对劲，但由于当天恰好有一场大型促销活动，因此先立马再次重启服务。直到后续大概过了1小时后又开始告警，连续几次重启后，发现需要重启的时间间隔越来越短。此时发现问题绝不简单。<strong>这一次重启真的解决不了问题老</strong>，因此立马申请机器权限、开始排查问题。下面的截图全部来源我的重现demo，与线上无关。</p>
<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>出现问题后，首先要进行分析推断、然后验证、最后定位修改。根据当时的表现是分别进行了以下猜想。</p>
<p><em>ps：后续截图全部来源自己本地复现时的截图</em></p>
<h2 id="推断一"><a href="#推断一" class="headerlink" title="推断一"></a>推断一</h2><blockquote>
<p>socket 资源被不断打满，并且之前从未出现过，今日突然出现，<strong>怀疑是不是请求量太大压垮服务</strong></p>
</blockquote>
<p>经过查看实时 <strong>qps</strong> 后，放弃该想法，虽然量有增加，但依然在服务器承受范围（远远未达到压测的基准值）。</p>
<h2 id="推断二"><a href="#推断二" class="headerlink" title="推断二"></a>推断二</h2><blockquote>
<p>两台机器故障是同时发生，重启一台，另外一台也会得到缓解，作为独立部署在两个集群的服务非常诡异</p>
</blockquote>
<p>有了上面的的依据，推出的结果是肯定是该服务依赖的底层资源除了问题，要不然不可能独立集群的服务同时出问题。</p>
<p>由于监控显示是 <strong>socket</strong> 问题，因此通过 <strong>netstat</strong> 命令查看了当前tcp链接的情况（本地测试，线上实际值大的多）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/go/src/hello # netstat -na | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br><span class="line">LISTEN 2</span><br><span class="line">CLOSE_WAIT 23 # 非常异常</span><br><span class="line">TIME_WAIT 1</span><br></pre></td></tr></table></figure>
<p>发现绝大部份的链接处于 <strong>CLOSE_WAIT</strong> 状态，这是非常不可思议情况。然后用 <code>netstat -an</code> 命令进行了检查。</p>
<p><img src="https://dayutalk.cn/img/image-20181208172652155-4261212.png" alt="image-20181208172652155"></p>
<p align="center"><b>图四：大量的CLOSE_WAIT</b></p>

<blockquote>
<p>CLOSED  表示socket连接没被使用。<br>LISTENING  表示正在监听进入的连接。<br>SYN_SENT  表示正在试着建立连接。<br>SYN_RECEIVED  进行连接初始同步。<br>ESTABLISHED  表示连接已被建立。<br>CLOSE_WAIT  表示远程计算器关闭连接，正在等待socket连接的关闭。<br>FIN_WAIT_1  表示socket连接关闭，正在关闭连接。<br>CLOSING  先关闭本地socket连接，然后关闭远程socket连接，最后等待确认信息。<br>LAST_ACK  远程计算器关闭后，等待确认信号。<br>FIN_WAIT_2  socket连接关闭后，等待来自远程计算器的关闭信号。<br>TIME_WAIT  连接关闭后，等待远程计算器关闭重发。</p>
</blockquote>
<p>然后开始重点思考为什么会出现大量的mysql连接是  <strong>CLOSE_WAIT</strong> 呢？为了说清楚，我们来插播一点TCP的四次挥手知识。</p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>我们来看看 <strong>TCP</strong> 的四次挥手是怎么样的流程：</p>
<p><img src="https://dayutalk.cn/img/image-20181208175427046-4262867.png" alt="image-20181208175427046"></p>
<p align="center"><b>图五：TCP四次挥手</b></p>

<p>用中文来描述下这个过程：</p>
<p>Client: <code>服务端大哥，我事情都干完了，准备撤了</code>，这里对应的就是客户端发了一个<strong>FIN</strong></p>
<p>Server：<code>知道了，但是你等等我，我还要收收尾</code>，这里对应的就是服务端收到 <strong>FIN</strong> 后回应的 <strong>ACK</strong></p>
<p>经过上面两步之后，服务端就会处于 <strong>CLOSE_WAIT</strong> 状态。过了一段时间 <strong>Server</strong> 收尾完了</p>
<p>Server：<code>小弟，哥哥我做完了，撤吧</code>，服务端发送了<strong>FIN</strong></p>
<p>Client：<code>大哥，再见啊</code>，这里是客户端对服务端的一个 <strong>ACK</strong></p>
<p>到此服务端就可以跑路了，但是客户端还不行。为什么呢？客户端还必须等待 <strong>2MSL</strong> 个时间，这里为什么客户端还不能直接跑路呢？主要是为了防止发送出去的 <strong>ACK</strong> 服务端没有收到，服务端重发 <strong>FIN</strong> 再次来询问，如果客户端发完就跑路了，那么服务端重发的时候就没人理他了。这个等待的时间长度也很讲究。</p>
<blockquote>
<p><strong>Maximum Segment Lifetime</strong> 报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃</p>
</blockquote>
<p>这里一定不要被图里的 <strong>client／server</strong> 和项目里的客户端服务器端混淆，你只要记住：主动关闭的一方发出 <strong>FIN</strong> 包（Client），被动关闭（Server）的一方响应 <strong>ACK</strong> 包，此时，被动关闭的一方就进入了 <strong>CLOSE_WAIT</strong> 状态。如果一切正常，稍后被动关闭的一方也会发出 <strong>FIN</strong> 包，然后迁移到 <strong>LAST_ACK</strong> 状态。</p>
<p>既然是这样， <strong>TCP</strong> 抓包分析下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/go # tcpdump -n port 3306</span><br><span class="line"># 发生了 3次握手</span><br><span class="line">11:38:15.679863 IP 172.18.0.5.38822 &gt; 172.18.0.3.3306: Flags [S], seq 4065722321, win 29200, options [mss 1460,sackOK,TS val 2997352 ecr 0,nop,wscale 7], length 0</span><br><span class="line">11:38:15.679923 IP 172.18.0.3.3306 &gt; 172.18.0.5.38822: Flags [S.], seq 780487619, ack 4065722322, win 28960, options [mss 1460,sackOK,TS val 2997352 ecr 2997352,nop,wscale 7], length 0</span><br><span class="line">11:38:15.679936 IP 172.18.0.5.38822 &gt; 172.18.0.3.3306: Flags [.], ack 1, win 229, options [nop,nop,TS val 2997352 ecr 2997352], length 0</span><br><span class="line"></span><br><span class="line"># mysql 主动断开链接</span><br><span class="line">11:38:45.693382 IP 172.18.0.3.3306 &gt; 172.18.0.5.38822: Flags [F.], seq 123, ack 144, win 227, options [nop,nop,TS val 3000355 ecr 2997359], length 0 # MySQL负载均衡器发送fin包给我</span><br><span class="line">11:38:45.740958 IP 172.18.0.5.38822 &gt; 172.18.0.3.3306: Flags [.], ack 124, win 229, options [nop,nop,TS val 3000360 ecr 3000355], length 0 # 我回复ack给它</span><br><span class="line"></span><br><span class="line">... ... # 本来还需要我发送fin给他，但是我没有发，所以出现了close_wait。那这是什么缘故呢？</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>src &gt; dst: flags data-seqno ack window urgent options</strong></p>
<p>src &gt; dst 表明从源地址到目的地址<br>flags 是TCP包中的标志信息,S 是SYN标志, F(FIN), P(PUSH) , R(RST) “.”(没有标记)<br>data-seqno 是数据包中的数据的顺序号<br>ack 是下次期望的顺序号<br>window 是接收缓存的窗口大小<br>urgent 表明数据包中是否有紧急指针<br>options 是选项</p>
</blockquote>
<p>结合上面的信息，我用文字说明下：<strong>MySQL负载均衡器</strong> 给我的服务发送 <strong>FIN</strong> 包，我进行了响应，此时我进入了 <strong>CLOSE_WAIR</strong> 状态，但是后续作为被动关闭方的我，并没有发送 <strong>FIN</strong>，导致我服务端一直处于 <strong>CLOSE_WAIR</strong> 状态，无法最终进入 <strong>CLOSED</strong> 状态。</p>
<p>那么我推断出现这种情况可能的原因有以下几种：</p>
<ol>
<li><p><strong>负载均衡器</strong> 异常退出了，</p>
<p><code>这基本是不可能的，他出现问题绝对是大面积的服务报警，而不仅仅是我一个服务</code></p>
</li>
<li><p><strong>MySQL负载均衡器</strong> 的超时设置的太短了，导致业务代码还没有处理完，<strong>MySQL负载均衡器</strong> 就关闭tcp连接了</p>
<p><code>这也不太可能，因为这个服务并没有什么耗时操作，当然还是去检查了负载均衡器的配置，设置的是60s。</code></p>
</li>
<li><p>代码问题，<strong>MySQL</strong> 连接无法释放</p>
<p><code>目前看起来应该是代码质量问题，加之本次数据有异常，触发到了以前某个没有测试到的点，目前看起来很有可能是这个原因</code></p>
</li>
</ol>
<h1 id="查找错误原因"><a href="#查找错误原因" class="headerlink" title="查找错误原因"></a>查找错误原因</h1><p>由于代码的业务逻辑并不是我写的，我担心一时半会看不出来问题，所以直接使用 <code>perf</code> 把所有的调用关系使用火焰图给绘制出来。既然上面我们推断代码中没有释放mysql连接。无非就是：</p>
<ol>
<li>确实没有调用close</li>
<li>有耗时操作（火焰图可以非常明显看到），导致超时了</li>
<li>mysql的事务没有正确处理，例如：rollback 或者 commit</li>
</ol>
<p>由于火焰图包含的内容太多，为了让大家看清楚，我把一些不必要的信息进行了折叠。</p>
<p><img src="https://dayutalk.cn/img/image-20181208212045848-4275245.png" alt="image-20181208212045848"></p>
<p align="center"><b>图六：有问题的火焰图</b></p>

<p>火焰图很明显看到了开启了事务，但是在余下的部分，并没有看到 <strong>Commit</strong> 或者是<strong>Rollback</strong> 操作。这肯定会操作问题。然后也清楚看到出现问题的是：</p>
<p><strong>MainController.update</strong> 方法内部，话不多说，直接到 update 方法中去检查。发现了如下代码：</p>
<figure class="highlight go"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MainController)</span> <span class="title">update</span><span class="params">()</span> <span class="params">(flag <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	o := orm.NewOrm()</span><br><span class="line">	o.Using(<span class="string">"default"</span>)</span><br><span class="line">	</span><br><span class="line">	o.Begin()</span><br><span class="line">	nilMap := getMapNil()</span><br><span class="line">	<span class="keyword">if</span> nilMap == <span class="literal">nil</span> &#123;<span class="comment">// 这里只检查了是否为nil，并没有进行rollback或者commit</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nilMap[<span class="number">10</span>] = <span class="number">1</span></span><br><span class="line">	nilMap[<span class="number">20</span>] = <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> nilMap == <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(nilMap) == <span class="number">0</span> &#123;</span><br><span class="line">		o.Rollback()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sql := <span class="string">"update tb_user set name=%s where id=%d"</span></span><br><span class="line">	res, err := o.Raw(sql, <span class="string">"Bug"</span>, <span class="number">2</span>).Exec()</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		num, _ := res.RowsAffected()</span><br><span class="line">		fmt.Println(<span class="string">"mysql row affected nums: "</span>, num)</span><br><span class="line">		o.Commit()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	o.Rollback()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，全部分析结束。经过查看 <strong>getMapNil</strong> 返回了nil，但是下面的判断条件没有进行回滚。</p>
<figure class="highlight go"><figcaption><span>lago l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nilMap == <span class="literal">nil</span> &#123;</span><br><span class="line">    o.Rollback()<span class="comment">// 这里进行回滚</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个分析过程还是废了不少时间。最主要的是主观意识太强，觉得运行了一年没有出问题的为什么会突然出问题？因此一开始是质疑 SRE、DBA、各种基础设施出了问题（人总是先怀疑别人）。导致在这上面费了不少时间。</p>
<p>理一下正确的分析思路：</p>
<ol>
<li>出现问题后，立马应该检查日志，确实日志没有发现问题；</li>
<li>监控明确显示了socket不断增长，很明确立马应该使用 <code>netstat</code> 检查情况看看是哪个进程的锅；</li>
<li>根据 <code>netstat</code> 的检查，使用 <code>tcpdump</code> 抓包分析一下为什么连接会<strong>被动断开</strong>（TCP知识非常重要）；</li>
<li>如果熟悉代码应该直接去检查业务代码，如果不熟悉则可以使用 <code>perf</code> 把代码的调用链路打印出来；</li>
<li>不论是分析代码还是火焰图，到此应该能够很快定位到问题。</li>
</ol>
<p>那么本次到底是为什么会出现  <strong>CLOSE_WAIR</strong> 呢？大部分同学应该已经明白了，我这里再简单说明一下：</p>
<p>由于那一行代码没有对事务进行回滚，导致服务端没有主动发起close。因此 <strong>MySQL负载均衡器</strong> 在达到 60s 的时候主动触发了close操作，但是通过tcp抓包发现，服务端并没有进行回应，这是因为代码中的事务没有处理，因此从而导致大量的端口、连接资源被占用。在贴一下挥手时的抓包数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mysql 主动断开链接</span><br><span class="line">11:38:45.693382 IP 172.18.0.3.3306 &gt; 172.18.0.5.38822: Flags [F.], seq 123, ack 144, win 227, options [nop,nop,TS val 3000355 ecr 2997359], length 0 # MySQL负载均衡器发送fin包给我</span><br><span class="line">11:38:45.740958 IP 172.18.0.5.38822 &gt; 172.18.0.3.3306: Flags [.], ack 124, win 229, options [nop,nop,TS val 3000360 ecr 3000355], length 0 # 我回复ack给它</span><br></pre></td></tr></table></figure>
<p>希望此文对大家排查线上问题有所帮助。为了便于帮助大家理解，下面附上正确情况下的火焰图与错误情况下的火焰图。大家可以自行对比。</p>
<ul>
<li><a href="https://dayutalk.cn/img/right.svg">正确情况下的火焰图</a></li>
<li><a href="https://dayutalk.cn/img/err.svg">错误情况的火焰图</a></li>
</ul>
<p>我参考的一篇文章对这种情况提出了两个思考题，我觉得非常有意义，大家自己思考下：</p>
<ol>
<li>为什么一台机器几百个  <strong>CLOSE_WAIR</strong>  就导致不可继续访问？我们不是经常说一台机器有 <strong>65535</strong> 个文件描述符可用吗？</li>
<li>为什么我有负载均衡，而两台部署服务的机器确几乎同时出了  <strong>CLOSE_WAIR</strong> ? </li>
</ol>
<p>参考文章：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&amp;mid=402163560&amp;idx=1&amp;sn=5269044286ce1d142cca1b5fed3efab1&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd" target="_blank" rel="external">又见CLOSE_WAIT</a></li>
<li><a href="https://wiki.wireshark.org/TCP%204-times%20close" target="_blank" rel="external">TCP 4-times close</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第三方支付的流程分析与总结]]></title>
      <url>http://dayutalk.cn/2018/11/25/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>总结的国内、国际支付流程，以及支付开发中注意事项<br><a id="more"></a></p>
<p>这几年的工作中一直与支付打交到，借着 <a href="https://github.com/skr-shop/manuals" target="_blank" rel="external">skr-shop</a> 这个项目来与大家一起分享探索一下支付系统该怎么设计、怎么做。我们先从支付的一些常见流程出发分析，找出这些支付的共性，抽象后再去探讨具体的数据库设计、代码结构设计。</p>
<p>相关项目：</p>
<ul>
<li><a href="https://github.com/helei112g/payment" target="_blank" rel="external">PHP 版本的支付SDK</a></li>
<li><a href="https://github.com/skr-shop/fool-pay" target="_blank" rel="external">Go 版本的支付SDK-开发中</a></li>
</ul>
<blockquote>
<p>支付整体而言的一个流程是：给第三方发起了一笔交易，用户通过第三方完成支付，第三方告诉我支付成功，我把用户购买的产品给用户。</p>
</blockquote>
<p><img src="https://dayutalk.cn/img/pay-1.jpg" alt="pay-1"></p>
<p>看似简单的流程，这里边不同的支付机构却有不同的处理。下面以我接触过的一些支付来总结一下</p>
<h1 id="国内支付"><a href="#国内支付" class="headerlink" title="国内支付"></a>国内支付</h1><p>国内的典型支付代表是：<strong>支付宝</strong>、<strong>微信</strong>、<strong>银行</strong>(以招商银行为例)，由于国内的支付都支持多种渠道的支付方式，为了描述简单，我们均以pc上的支付为例进行讲解。</p>
<h2 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h2><p>支付宝的接入是我觉得最简单的一种支付。对于在PC上的支付能力，支付宝提供了【电脑支付】。当用户下单后，商户系统根据支付宝的规则构建好一个url，用户跳转到这个url后进入到支付宝的支付页面，然后完成支付流程。</p>
<p>在支付成功后，支付宝会通过 <strong>同步通知</strong>、<strong>异步通知</strong> 两种方式告诉商户系统支付成功，并且两种通知方式的结果都是可信的，而且异步通知的消息延迟也非常短暂。</p>
<p>对于退款流程，支付宝支持全额、部分退款。并且能够根据商户的退款单号区分是否是同一笔退款进而避免了重复退款的可能。支付的退款是调用后同步返回结果，不会异步通知。</p>
<h2 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h2><p>微信并没有提供真的PC支付能力，但是我们可以利用【扫码支付】来达成电脑支付的目的。扫码支付有两种模式，这里以模式二为例。</p>
<p>微信调用下单接口获取到这个二维码链接，然后用户扫码后，进入支付流程。完成支付后微信会 <strong>异步通知</strong>，但是这里并没有 <strong>同步通知</strong>，因此前端页面只能通过定时轮训的方式检查这笔交易是否支付，直到查询到成功、或者用户主动关闭页面。</p>
<p>退款流程与支付宝最大的不同是，有一个 <strong>异步通知</strong> 需要商户系统进行处理。</p>
<blockquote>
<p>第一个不同点：</p>
<ol>
<li>异步通知的接口需要处理多种不同类型的异步消息</li>
</ol>
</blockquote>
<h2 id="招商银行"><a href="#招商银行" class="headerlink" title="招商银行"></a>招商银行</h2><p>随着在线支付在国内的蓬勃发展，各家银行也是不断推出自己的在线支付能力。其中的佼佼者当属 <strong>招商银行</strong>。大家经常用的滴滴上面就有该支付方式，可以体验一下。</p>
<p>招商支付使用的是银行卡，因此首次用户必须进行绑卡。因此这里可能就多了一个流程，首先得记录用户是否绑过卡，然后用于签名的公钥会发生变化，需要定期更新。</p>
<p>招商所有平台的支付体验都是一致的，会跳转到招行的H5页面完成逻辑，支付成功后并不会自动跳回商户，也就是没有 <strong>同步通知</strong>，它的支付结果只会走异步通知流程，延迟非常短暂。</p>
<p>退款流程与支付宝一样，也是同步返回退款结果，没有异步通知。</p>
<blockquote>
<p>第二个不同点：</p>
<ol>
<li>支付前需要检查用户是否签约过，有签约流程</li>
</ol>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>国内在线支付流程相对都比较完善，接入起来也非常容易。需要注意的一点是：退款后之前支付的单子依然是支付成功状态，并不会变成退款状态。因为退款与支付属于不同的交易。</p>
<p>这一点基本上是国内在线支付的通用做法。</p>
<h1 id="国际支付"><a href="#国际支付" class="headerlink" title="国际支付"></a>国际支付</h1><p>国际支付的平台非常多，包括像支付宝、微信也在扩展这一块市场。我以我接触的几家支付做一个简单的总结。</p>
<h2 id="WorldPay"><a href="#WorldPay" class="headerlink" title="WorldPay"></a>WorldPay</h2><p>这是比较出名的一家国际支付公司，它主要做的是银行卡支付，公司在英国</p>
<p>支付流程上，也是根据规则构建好请求的url后，直接跳转到 <strong>WorldPay</strong> 的页面，通过信用卡完成支付。这里比较麻烦的处理机制是：支付成功后，他首次给你的异步/同步消息通知并不能作为支付成功的依据。真的从银行确认划款成功后，才会给出真的支付成功通知。这中间还可能会异步通知告诉你支付请求被拒绝。最头痛的是不同状态的异步消息时间间隔都是按照分钟以上级别的延迟来计算</p>
<p>退款流程上，状态跟微信一样，需要通过异步消息来确认退款状态。其次它的不同点在于无法根据商户退款单号来确认是否已经发起过退款，因此对于它来说只要请求一次退款接口，那它就默认发起了一次退款。</p>
<blockquote>
<p>第三、四不同点：</p>
<ol>
<li><p>支付成功后的通知状态有多种，涉及到商户系统业务流程的特殊处理</p>
</li>
<li><p>退款不支持商户退款单号，无法支持防重复退款需要商户自己处理</p>
</li>
</ol>
</blockquote>
<h2 id="Assist"><a href="#Assist" class="headerlink" title="Assist"></a>Assist</h2><p>这是俄罗斯的一家支付公司，这也是一家搞死人不偿命的公司，看下面介绍</p>
<p>它的支付发起是需要构建一个form表单，向它post支付相关的数据。成功后会跳转到它的支付页，用户完成支付即可。对于 <strong>同步通知</strong>，它需要用户手动触发跳回商户，与招商的逻辑很像，同步也仅仅是做返回并不会真的告知支付结果。<strong>异步通知</strong> 才是真的告知支付状态。比较恶心的是，支付时必须传入指定格式的商品信息，这会在部分退款时用到。</p>
<p>现在来说退款，退款也是与 <strong>WorldPay</strong> 一样，不支持商户的退款单号，因此防重方面也许自己的系统进行设计。并且如果是部分退款，需要传入指定的退款商品，这就会出现一个非常尴尬的局面：部分退款的金额与任何一个商品金额都对应不上，退款则会失败。</p>
<blockquote>
<p>第五个不同点：</p>
<ol>
<li>部分退款时需要传入部分退款的商品信息，并且金额要一致</li>
</ol>
</blockquote>
<h2 id="Doku"><a href="#Doku" class="headerlink" title="Doku"></a>Doku</h2><p>接下来再来聊聊印尼的这家支付机构 <strong>doku</strong>。由于印尼这个国家信用卡的普及程度并不高，它的在线支付提供一种超商支付方式。</p>
<p>什么是超商支付呢？也就是用户在网络上完成下单后，会获取到一个二维码或者条形码。用户拿着这个条形码到超商（711、全家这种）通过收银员扫码，付现金给超商，完成支付流程。</p>
<p>这种方式带来的问题是，用户长时间不去支付，导致订单超时关单后才去付款。对整个业务流程以及用户体验带来很多伤害。</p>
<p>再来说退款，由于存在超商这种支付方式，导致这种支付无法支持在线自动退款，需要人工收集用户银行卡信息，然后完成转账操作。非常痛苦不堪。</p>
<blockquote>
<p>第六个不同点：</p>
<ol>
<li>线上没有付款，只有获取付款码，退款需要通过人工操作</li>
</ol>
</blockquote>
<h2 id="AmazonPay"><a href="#AmazonPay" class="headerlink" title="AmazonPay"></a>AmazonPay</h2><p>亚马逊出品，与支付宝非常类似。提供的是集成式的钱包流程。</p>
<p>支付时直接构建一个url，然后跳转到亚马逊即可完成支付。它还提供一种授权模式，能够不用跳转amazon，再商户端即完成支付。</p>
<p>支付成功后也会同步跳转，<strong>同步通知</strong> 的内容可以作为支付是否成功的判断依据。经过实际检查 <strong>异步通知</strong> 的到达会稍有延迟，大概10s以内。</p>
<p>退款方面也支持商户退款单号可以依赖此进行防重。但是退款的状态也是基于异步来的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这其中还有一些国际支付，如：<strong>PayPal</strong>、<strong>GooglePay</strong>、<strong>PayTM</strong> 等知名支付机构没有进行介绍，是因为基本它们的流程也都在上面的模式之中。我们后续的代码结构设计、数据库设计都基于满足上面的各种支付模型来完成设计。</p>
<p>最后，赠送大家一副脑图，这是接入一家支付时必须弄清楚的问题清单</p>
<p><img src="https://dayutalk.cn/img/pay-2.png" alt="pay-2"></p>
<p><strong>下篇预告：《支付数据库与代码结构设计》</strong></p>
<p>这是我们几个小伙伴利用业余时间思考的一些业务设计，如果有写的不对或者不完善的地方，希望大家多多评论，互相学习互相进步～</p>
<p>项目地址: <a href="https://github.com/skr-shop/manuals" target="_blank" rel="external">https://github.com/skr-shop/manuals</a></p>
<h1 id="skr-shop项目成员简介"><a href="#skr-shop项目成员简介" class="headerlink" title="skr-shop项目成员简介"></a>skr-shop项目成员简介</h1><p>排名不分先后，字典序</p>
<table>
<thead>
<tr>
<th>昵称</th>
<th>简介</th>
<th>个人博客</th>
</tr>
</thead>
<tbody>
<tr>
<td>AStraw</td>
<td>研究生创业者, 现于小米科技海外商城组从事商城后端研发工作</td>
<td>——–</td>
</tr>
<tr>
<td>Dayu</td>
<td>Payment开源作者，服务端开发者</td>
<td>dayutalk.cn</td>
</tr>
<tr>
<td>lwhcv</td>
<td>曾就职于百度/融360, 现于小米科技海外商城组从事商城后端研发工作</td>
<td>——–</td>
</tr>
<tr>
<td>TIGERB</td>
<td>PHP框架EasyPHP作者，拥有A/B/C轮电商创业公司工作经验，现于小米科技海外商城组从事商城后端研发工作</td>
<td>TIGERB.cn</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[玩转Redis持久化]]></title>
      <url>http://dayutalk.cn/2018/08/12/%E7%8E%A9%E8%BD%ACRedis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>Redis系列的第三篇，结合自己看过的文章，以及最近对Redis源码的阅读总结一下自己对持久化的认识。</p>
<p>真心希望对你有帮助。<br><a id="more"></a></p>
<p>Redis为持久化提供了两种方式：</p>
<ul>
<li>RDB：在指定的时间间隔能对你的数据进行快照存储。</li>
<li>AOF：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。</li>
</ul>
<p>本文将通过下面内容的介绍，希望能够让大家更全面、清晰的认识这两种持久化方式，同时理解这种保存数据的思路，应用于自己的系统设计中。</p>
<ul>
<li>持久化的配置</li>
<li>RDB与AOF持久化的工作原理</li>
<li>如何从持久化中恢复数据</li>
<li>关于性能与实践建议</li>
</ul>
<h1 id="持久化的配置"><a href="#持久化的配置" class="headerlink" title="持久化的配置"></a>持久化的配置</h1><p>为了使用持久化的功能，我们需要先知道该如何开启持久化的功能。</p>
<h2 id="RDB的持久化配置"><a href="#RDB的持久化配置" class="headerlink" title="RDB的持久化配置"></a>RDB的持久化配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 时间策略</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 文件名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 文件保存路径</span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"></span><br><span class="line"># 如果持久化出错，主进程是否停止写入</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 导入时是否检查</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>
<p>配置其实非常简单，这里说一下持久化的时间策略具体是什么意思。</p>
<ul>
<li><code>save 900 1</code> 表示900s内如果有1条是写入命令，就触发产生一次快照，可以理解为就进行一次备份</li>
<li><code>save 300 10</code> 表示300s内有10条写入，就产生快照</li>
</ul>
<p>下面的类似，那么为什么需要配置这么多条规则呢？因为Redis每个时段的读写请求肯定不是均衡的，为了平衡性能与数据安全，我们可以自由定制什么情况下触发备份。所以这里就是根据自身Redis写入情况来进行合理配置。</p>
<p><code>stop-writes-on-bgsave-error yes</code> 这个配置也是非常重要的一项配置，这是当备份进程出错时，主进程就停止接受新的写入操作，是为了保护持久化的数据一致性问题。<strong>如果自己的业务有完善的监控系统，可以禁止此项配置，</strong> 否则请开启。</p>
<p>关于压缩的配置 <code>rdbcompression yes</code> ，建议没有必要开启，毕竟Redis本身就属于CPU密集型服务器，再开启压缩会带来更多的CPU消耗，相比硬盘成本，CPU更值钱。</p>
<p>当然如果你想要禁用RDB配置，也是非常容易的，只需要在save的最后一行写上：<code>save &quot;&quot;</code></p>
<h2 id="AOF的配置"><a href="#AOF的配置" class="headerlink" title="AOF的配置"></a>AOF的配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启aof</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># 文件名称</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 同步方式</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 重写触发配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 加载aof时如果有错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># 文件重写策略</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>
<p>还是重点解释一些关键的配置：</p>
<p><code>appendfsync everysec</code> 它其实有三种模式:</p>
<ul>
<li>always：把每个写命令都立即同步到aof，很慢，但是很安全</li>
<li>everysec：每秒同步一次，是折中方案</li>
<li>no：redis不处理交给OS来处理，非常快，但是也最不安全</li>
</ul>
<p>一般情况下都采用 <strong>everysec</strong> 配置，这样可以兼顾速度与安全，最多损失1s的数据。</p>
<p><code>aof-load-truncated yes</code> 如果该配置启用，在加载时发现aof尾部不正确是，会向客户端写入一个log，但是会继续执行，如果设置为 <code>no</code> ，发现错误就会停止，必须修复后才能重新加载。</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>关于原理部分，我们主要来看RDB与AOF是如何完成持久化的，他们的过程是如何。</p>
<p>在介绍原理之前先说下Redis内部的定时任务机制，定时任务执行的频率可以在配置文件中通过 <code>hz 10</code> 来设置（这个配置表示1s内执行10次，也就是每100ms触发一次定时任务）。该值最大能够设置为：<strong>500</strong>，但是不建议超过：<strong>100</strong>，因为值越大说明执行频率越频繁越高，这会带来CPU的更多消耗，从而影响主进程读写性能。</p>
<p>定时任务使用的是Redis自己实现的 <strong>TimeEvent</strong>，它会定时去调用一些命令完成定时任务，这些任务可能会阻塞主进程导致Redis性能下降。因此我们在配置Redis时，一定要整体考虑一些会触发定时任务的配置，根据实际情况进行调整。</p>
<h2 id="RDB的原理"><a href="#RDB的原理" class="headerlink" title="RDB的原理"></a>RDB的原理</h2><p>在Redis中RDB持久化的触发分为两种：自己手动触发与Redis定时触发。</p>
<p><strong>针对RDB方式的持久化，手动触发可以使用：</strong></p>
<ul>
<li>save：会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。</li>
<li>bgsave：该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候。</li>
</ul>
<p><strong>而自动触发的场景主要是有以下几点：</strong></p>
<ul>
<li>根据我们的 <code>save m n</code> 配置规则自动触发；</li>
<li>从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发 <code>bgsave</code>；</li>
<li>执行 <code>debug reload</code> 时；</li>
<li>执行  <code>shutdown</code>时，如果没有开启aof，也会触发。</li>
</ul>
<p>由于 <code>save</code> 基本不会被使用到，我们重点看看 <code>bgsave</code> 这个命令是如何完成RDB的持久化的。<br><img src="http://ol59nqr1i.bkt.clouddn.com/persistence-1.png" alt="image1"></p>
<p>这里注意的是 <code>fork</code> 操作会阻塞，导致Redis读写性能下降。我们可以控制单个Redis实例的最大内存，来尽可能降低Redis在fork时的事件消耗。以及上面提到的自动触发的频率减少fork次数，或者使用手动触发，根据自己的机制来完成持久化。</p>
<h2 id="AOF的原理"><a href="#AOF的原理" class="headerlink" title="AOF的原理"></a>AOF的原理</h2><p>AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是 <code>appendfsync everysec</code> 配置，会有1s损耗），第二步是对aof文件的重写。</p>
<p>对于增量追加到文件这一步主要的流程是：命令写入=》追加到aof_buf =》同步到aof磁盘。那么这里为什么要先写入buf在同步到磁盘呢？如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能。</p>
<p>aof重写是为了减少aof文件的大小，可以手动或者自动触发，关于自动触发的规则请看上面配置部分。fork的操作也是发生在重写这一步，也是这里会对主进程产生阻塞。</p>
<p><strong>手动触发：</strong> <code>bgrewriteaof</code>，<strong>自动触发</strong> 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。</p>
<p>下面来看看重写的一个流程图：<br><img src="http://ol59nqr1i.bkt.clouddn.com/persistence-2.png" alt="image2"></p>
<p>对于上图有四个关键点补充一下：</p>
<ol>
<li>在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失。</li>
<li>为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据。</li>
<li>重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。</li>
<li>AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复。</li>
</ol>
<blockquote>
<p>不能是RDB还是AOF都是先写入一个临时文件，然后通过 <code>rename</code> 完成文件的替换工作。  </p>
</blockquote>
<h1 id="从持久化中恢复数据"><a href="#从持久化中恢复数据" class="headerlink" title="从持久化中恢复数据"></a>从持久化中恢复数据</h1><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p>
<p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：<br><img src="http://ol59nqr1i.bkt.clouddn.com/persistence-3.png" alt="image2"></p>
<p>启动时会先检查AOF文件是否存在，如果不存在就尝试加载RDB。那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p>
<h1 id="性能与实践"><a href="#性能与实践" class="headerlink" title="性能与实践"></a>性能与实践</h1><p>通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。</p>
<ol>
<li>降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；</li>
<li>控制Redis最大使用内存，防止fork耗时过长；</li>
<li>使用更牛逼的硬件；</li>
<li>合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。</li>
</ol>
<p>在线上我们到底该怎么做？我提供一些自己的实践经验。</p>
<ol>
<li>如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；</li>
<li>自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；</li>
<li>单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；</li>
<li>可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；</li>
<li>RDB持久化与AOF持久化可以同时存在，配合使用。</li>
</ol>
<p>本文的内容主要是运维上的一些注意点，但我们开发者了解到这些知识，在某些时候有助于我们发现诡异的bug。接下来会介绍Redis的主从复制与集群的知识。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis的数据类型——探究竟]]></title>
      <url>http://dayutalk.cn/2018/07/22/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F/</url>
      <content type="html"><![CDATA[<p>第二篇来了，Redis常用5种类型大揭秘。长文预警！<br><a id="more"></a></p>
<p>接上篇 <a href="https://mp.weixin.qq.com/s/cKIaRPGKywrxfs_s7wiaQg" target="_blank" rel="external">为什么要用Redis</a>，今天来聊聊具体的Redis数据类型与命令。本篇是深入理解Redis的一个重要基础，请坐稳，前方 长文预警。</p>
<blockquote>
<p>本系列内容基于：redis-3.2.12</p>
</blockquote>
<p>文中不会介绍所有命令，主要是工作中经常遇到的。</p>
<p>平时我们看的大部分资料，都是简单粗暴的告诉我们这个命令干嘛，那个命令需要几个参数。这种方式只会知其然不知其所以然，本文从命令的时间复杂度到用途，再到对应类型在Redis低层采用何种结构保存数据，希望让大家认识的更深刻，使用时心里更有底。</p>
<ol>
<li><p>这里在阅读中请注意：虽然很多命令的时间复杂度都是O(n)，但要注意其n所代表的具体含义。</p>
</li>
<li><p>文中会用到 OBJECT ENCODING xxx 来检查Redis的内部编码，它其实是读取的 redisObject 结构体中 encoding 所代表的值。redisObject 对不同类型的数据提供了统一的表现形式。</p>
</li>
</ol>
<h1 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h1><p>应该讲这是Redis中使用的最广泛的数据类型。该类型中的一些命令使用场景非常广泛。比如：</p>
<ul>
<li>缓存，这是使用非常多的地方；</li>
<li>计数器/限速器技术；</li>
<li>共享Session服务器也是基于该数据类型</li>
</ul>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/redis-type-string.png" alt=""></p>
<blockquote>
<p>注：表格中仅仅说明了String中的12个命令，使用场景也仅列举了部分。  </p>
</blockquote>
<p>我们时常被人说教 MSET/MGET 这类命令少用，因为他们的时间复杂度是O(n)，但其实这里注意，n表示的是本次设置或读取的key个数，所以如果你批量读取的key并不是很多，每个key的内容也不是很大，那么使用批量操作命令反而能够节省网络请求、传输的时间。</p>
<h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><p>String类型的数据最终是如何在Redis中保存的呢？如果要细究的话，得先从 <code>SDS</code> 这个结构说起，不过今天先按下不表这源码部分的细节，只谈其内部保存的数据结构。最终我们设置的字符串都会以三种形式中的一种被存储下来。</p>
<ul>
<li>Int，8个字节的长整型，最大值是：0x7fffffffffffffffL</li>
<li>Embstr，小于等于44个字节的字符串</li>
<li>Raw</li>
</ul>
<p>结合代码来看看Redis对这三种数据结构是如何决策的。当我们在客户端使用命令 <code>SET test hello,redis</code> 时，客户端会把命令保存到一个buf中，然后按照收到的命令先后顺序依次执行。这其中有一个函数是：<code>processMultibulkBuffer()</code> ，它内部调用了 <code>createStringObject()</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">	  <span class="comment">// 检查保存的字符串长度，选择对应类型</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不懂C语言不要紧，这里就是检查我们输入的字符串 <code>hello,redis</code> 长度是否超过了 44 ，如果超过了用类型 <code>raw</code> ，没有则选用 <code>embstr</code> 。实验看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET test 12345678901234567890123456789012345678901234 // len=44</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding test</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; SET test 123456789012345678901234567890123456789012345 // len=45</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding test</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到，一旦超过44，底层类型就变成了：<code>raw</code> 。等等，上面我们不是还提到有一个 <code>int</code> 类型吗？从函数里边完全看不到它的踪迹啊？不急，当我们输入的这条命令真的要开始执行时，也就是调用函数 <code>setCommand()</code> 时，会触发一个 <code>tryObjectEncoding()</code> 函数，这个函数的作用是试图对输入的字符串进行压缩，继续看看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    len = sdslen(s);</span><br><span class="line">	  <span class="comment">// 长度小于等于20，并且能够转成长整形</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">20</span> &amp;&amp; string2l(s,len,&amp;value)) &#123;</span><br><span class="line">        o-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数被我大幅缩水了，但是简单我们能够看到它判断长度是否小于等于20，并且尝试转化成整型，看看例子。</p>
<blockquote>
<p><strong>9223372036854775807</strong> 是8位字节可表示的最大整数，它的16进制形式是：<strong>0x7fffffffffffffffL</strong>  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET test 9223372036854775807</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding test</span><br><span class="line">&quot;int&quot;</span><br><span class="line">127.0.0.1:6379&gt; SET test 9223372036854775808 // 比上面大1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding test</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>
<p>至此，关于String的类型选择流程完毕了。这对我们的参考价值是，我们在使用String类型保存数据时，要考虑到底层对应不同的类型，不同的类型在Redis内部会执行不同的流程，其所对应的执行效率、内存消耗都是不同的。</p>
<h1 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h1><p>我们经常用它来保存一个结构化的数据，比如与一个用户相关的缓存信息。如果使用普通的String类型，需要对字符串进行序列化与反序列化，无疑增加额外开销，并且每次读取都只能全部读取出来。</p>
<ul>
<li>缓存结构化的数据，如：文章信息，可灵活修改其某一个字段，如阅读量。</li>
</ul>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/redis-type-hash.png" alt=""></p>
<p>Hash类型保存的结构话数据，非常像MySQL中的一条记录，我们可以方便修改某一个字段，但是它更具灵活性，每个记录能够含有不同的字段。</p>
<h2 id="内部结构-1"><a href="#内部结构-1" class="headerlink" title="内部结构"></a>内部结构</h2><p>在内部Hash类型数据可能存在两种类型的数据结构：</p>
<ul>
<li>ZipList，更加节省空间，限制：key与field长度不超过64，key中field的个数不超过512个</li>
<li>HashTable</li>
</ul>
<p>对于Hash，Redis 首先默认给它设置使用 <code>ZipList</code> 数据结构，后续根据条件进行判断是否需要改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> update;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">// 根据长度决策</span></span><br><span class="line">    ... ...</span><br><span class="line">    update = hashTypeSet(o,c-&gt;argv[<span class="number">2</span>],c-&gt;argv[<span class="number">3</span>]);<span class="comment">// 根据元素个数决策</span></span><br><span class="line">    addReply(c, update ? shared.czero : shared.cone);</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hashTypeLookupWriteOrCreate()</code> 内部会调用 <code>createHashObject()</code> 创建Hash对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_HASH, zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;<span class="comment">// 设置编码 ziplist</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hashTypeTryConversion()</code> 函数内部根据是否超过 <code>hash_max_ziplist_value</code> 限制的长度（64），来决定低层的数据结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashTypeTryConversion</span><span class="params">(robj *o, robj **argv, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding != OBJ_ENCODING_ZIPLIST) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++) &#123;</span><br><span class="line">		  <span class="comment">// 检查 field 与 value 长度是否超长</span></span><br><span class="line">        <span class="keyword">if</span> (sdsEncodedObject(argv[i]) &amp;&amp;</span><br><span class="line">            sdslen(argv[i]-&gt;ptr) &gt; server.hash_max_ziplist_value)</span><br><span class="line">        &#123;</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在函数 <code>hashTypeSet()</code> 中检查field个数是否超过了 <code>hash_max_ziplist_entries</code> 的限制（512个）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashTypeSet</span><span class="params">(robj *o, robj *field, robj *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> update = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">		  ... ...</span><br><span class="line">        <span class="comment">// 检查field个数是否超过512</span></span><br><span class="line">        <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">		  ... ...</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来验证一下上面的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET test name qweqweqwkejkksdjfslfldsjfkldjslkfqweqweqwkejkksdjfslfldsjfkldjsl</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HSTRLEN test name</span><br><span class="line">(integer) 64</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding test</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6379&gt; HSET test name qweqweqwkejkksdjfslfldsjfkldjslkfqweqweqwkejkksdjfslfldsjfkldjslq</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; HSTRLEN test name</span><br><span class="line">(integer) 65</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding test</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure></p>
<p>关于key设置超过64，以及field个数超过512的限制情况，大家可自行测试。</p>
<h1 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h1><p>List类型的用途也是非常广泛，主要概括下常用场景:</p>
<ul>
<li>消息队列：LPUSH + BRPOP（阻塞特征）</li>
<li>缓存：用户记录各种记录，最大特点是可支持分页</li>
<li>栈：LPUSH + LPOP</li>
<li>队列：LPUSH + RPOP</li>
<li>有限队列：LPUSH + LTRIM，可以维持队列中数据的数量</li>
</ul>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/redis-type-list.png" alt=""></p>
<h2 id="内部结构-2"><a href="#内部结构-2" class="headerlink" title="内部结构"></a>内部结构</h2><p>List 的数据类型在低层实现有以下几种：</p>
<ul>
<li>QuickList：它是以ZipList为节点的LinkedList</li>
<li>ZipList（省内存），<strong>在3.2.12版本中发现有地方使用</strong></li>
<li>LinkedList，<strong>在3.2.12版本中发现有地方使用</strong></li>
</ul>
<p>网络上有些文章说 <code>LinkedList</code> 在 <code>Redis 4.0</code> 之后的版本没有再被使用，实际上我发现 <code>Redis 3.2.12</code> 版本中也没有再使用该结构（不直接做为数据存储结构），包括 <code>ZipList</code> 在 <code>3.2.12</code> 版本中都没有再被直接用来存储数据了。</p>
<p>我们做个实验来验证下，我们设置一个List中有 <strong>1000</strong> 个元素，每个元素value长度都超过 <strong>64</strong> 个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LLEN test</span><br><span class="line">(integer) 1000</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding test</span><br><span class="line">&quot;quicklist&quot;</span><br><span class="line">127.0.0.1:6379&gt; LINDEX test 0</span><br><span class="line">&quot;qweqweqwkejkksdjfslfldsjfkldjslkfqweqweqwkejkksdjfslfldsjfkldjslq&quot; // 65个字符</span><br></pre></td></tr></table></figure>
<p>无论我们是改变列表元素的个数以及元素值的长度，其结构都是 <code>QuickList</code>。还不信的话，我们来看看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, waiting = <span class="number">0</span>, pushed = <span class="number">0</span>;</span><br><span class="line">    robj *lobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">	  ... ...</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        c-&gt;argv[j] = tryObjectEncoding(c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (!lobj) &#123;</span><br><span class="line">			  <span class="comment">// 创建 quick list</span></span><br><span class="line">            lobj = createQuicklistObject();</span><br><span class="line">            quicklistSetOptions(lobj-&gt;ptr, server.list_max_ziplist_size,</span><br><span class="line">                                server.list_compress_depth);</span><br><span class="line">            dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj);</span><br><span class="line">        &#125;</span><br><span class="line">        listTypePush(lobj,c-&gt;argv[j],where);</span><br><span class="line">        pushed++;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始话时，调用 <code>createQuicklistObject()</code> 设置其低层数据结构是：<code>quick list</code> 。后续流程中没有地方再对该结构进行转化。</p>
<h1 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h1><p>Set 类型的重要特性之一是可以去重、无序。它集合的性质在社交上可以有广泛的使用。</p>
<ul>
<li>共同关注</li>
<li>共同喜好</li>
<li>数据去重</li>
</ul>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/redis-type-set.png" alt=""></p>
<h2 id="内部结构-3"><a href="#内部结构-3" class="headerlink" title="内部结构"></a>内部结构</h2><p>Set低层实现采用了两种数据结构：</p>
<ul>
<li>IntSet，集合成员都是整数（不能超过最大整数）并且集合成员个数少于512时使用。</li>
<li>HashTable</li>
</ul>
<p>该命令的代码如下，其中重要的两个关于决定类型的调用是：<code>setTypeCreate()</code> 和 <code>setTypeAdd()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		  <span class="comment">// 初始化</span></span><br><span class="line">        <span class="built_in">set</span> = setTypeCreate(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">		  <span class="comment">// 内部会检查元素个数是否扩充到需要改变低层结构</span></span><br><span class="line">        <span class="keyword">if</span> (setTypeAdd(<span class="built_in">set</span>,c-&gt;argv[j])) added++;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下 Set 结构对象的初始创建代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">setTypeCreate</span><span class="params">(robj *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isObjectRepresentableAsLongLong(value,<span class="literal">NULL</span>) == C_OK)</span><br><span class="line">        <span class="keyword">return</span> createIntsetObject(); <span class="comment">// 使用IntSet</span></span><br><span class="line">    <span class="keyword">return</span> createSetObject(); <span class="comment">// 使用HashTable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isObjectRepresentableAsLongLong()</code>  内部判断其整数范围，如果是整数且没有超过最大整数就会使用 <code>IntSet</code> 来保存。否则使用 <code>HashTable</code> 。接着会检查元素的个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, robj *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">		 ... ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isObjectRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">/* Convert to regular set when the intset contains</span><br><span class="line">                 * too many entries. */</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Failed to get integer from object, convert to regular set. */</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">			  ... ...</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	  ... ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看例子，这里以最大整数临界值为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD test 9223372036854775807</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding test</span><br><span class="line">&quot;intset&quot;</span><br><span class="line">127.0.0.1:6379&gt; SADD test 9223372036854775808</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding test</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure></p>
<p>关于集合个数的测试，请自行完成观察。</p>
<h1 id="SortSet类型"><a href="#SortSet类型" class="headerlink" title="SortSet类型"></a>SortSet类型</h1><p>现在的应用，都有一些排行榜之类的功能，比如投资网站显示投资金额排行，购物网站显示消费排行等。SortSet非常适合做这件事。常用来解决以下问题：</p>
<ul>
<li>各类排行榜</li>
<li>设置执行任务权重，后台脚本根据其排序顺序执行相关操作</li>
<li>范围查找，查找某个值在集合的哪个范围</li>
</ul>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/redis-type-zset.png" alt=""></p>
<h2 id="内部结构-4"><a href="#内部结构-4" class="headerlink" title="内部结构"></a>内部结构</h2><p>虽然有序集合也是集合，但是低层的数据结构却与Set不一样，它也有两种数据结构，分别是：</p>
<ul>
<li>ZipList，当有序集合的元素个少于等于128或 member 的长度小于等于64的时候使用该结构</li>
<li>SkipList</li>
</ul>
<p>这个转变成过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (zobj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xx) <span class="keyword">goto</span> reply_to_client; <span class="comment">/* No key + XX option: nothing to do. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.zset_max_ziplist_entries == <span class="number">0</span> ||</span><br><span class="line">            server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+<span class="number">1</span>]-&gt;ptr))</span><br><span class="line">        &#123;</span><br><span class="line">            zobj = createZsetObject();<span class="comment">// skip list</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            zobj = createZsetZiplistObject();<span class="comment">// zip list</span></span><br><span class="line">        &#125;</span><br><span class="line">        dbAdd(c-&gt;db,key,zobj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">	  ... ...</span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries)</span><br><span class="line">            zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);<span class="comment">// 根据个数转化编码</span></span><br><span class="line">        <span class="keyword">if</span> (sdslen(ele-&gt;ptr) &gt; server.zset_max_ziplist_value)</span><br><span class="line">            zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);<span class="comment">// 根据长度转化编码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里以member长度超过64举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD test 77 qwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwer // member长度是 64</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding test</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZADD test 77 qwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwerq // member长度是65</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding test</span><br><span class="line">&quot;skiplist&quot;</span><br></pre></td></tr></table></figure>
<p>当我们member 超过64位长度时，低层的数据结构由 <code>ZipList</code> 转变成了 <code>SkipList</code>。剩下的元素个数的测试，动动手试试看。</p>
<h1 id="全局常用命令"><a href="#全局常用命令" class="headerlink" title="全局常用命令"></a>全局常用命令</h1><p><img src="http://ol59nqr1i.bkt.clouddn.com/redis-type-global.png" alt=""></p>
<p>对于全局命令，不管对应的key是什么类型的数据，都是可以进行操作的。其中需要注意 <strong>KEYS</strong> 这个命令，不能用于线上，因为Redis单线程机制，如果内存中数据太多，会操作严重的阻塞，导致整个Redis服务都无法响应。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Redis每种类型的命令时间复杂度不同，有的跟对应元素的个数有关系；有的跟请求个数有关系；</li>
<li>合理安排元素相关个数以及长度，争取Redis底层采用最简单的数据结构；</li>
<li>关注时间复杂度，了解自己的Redis内部元素情况，避免阻塞；</li>
<li>越简单的数据，越能获得更好的性能；</li>
<li>Redis每种数据类型低层都对应多种数据结构，修改与扩展对上层无感知。</li>
</ul>
<p>第一篇讲了为什么要用Redis，本文又讲了绝大部分命令吧，以及Redis源码中对它们的一些实现，后续开始关注具体实践中的一些操作。希望对大家有帮助，<strong>期待任何形式的批评与鼓励</strong>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为什么要用Redis]]></title>
      <url>http://dayutalk.cn/2018/07/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Redis/</url>
      <content type="html"><![CDATA[<p>从今天开始探索Redis，不让它成为一个黑盒子<br><a id="more"></a></p>
<p>最近阅读了《Redis开发与运维》，非常不错。这里对书中的知识整理一下，方便自己回顾一下Redis的整个体系，来对相关知识点查漏补缺。</p>
<p>我按照五点把书中的内容进行一下整理：<br>​    •    为什么要选择Redis：介绍Redis的使用场景与使用Redis的原因；<br>​    •    Redis常用命令总结：包括时间复杂度总结与具体数据类型在Redis内部使用的数据结构；<br>​    •    Redis的高级功能：包括持久化、复制、哨兵、集群介绍；<br>​    •    理解Redis：理解内存、阻塞；这部分是非常重要的，前面介绍的都可以成为术，这里应该属于道的部分。；<br>​    •    开发技巧：主要是一些开发实战的总结，包括缓存设计与常见坑点。</p>
<p>先来开启第一部分的内容，对Redis来一次重新打量。</p>
<blockquote>
<p>本系列内容基于：redis-3.2.12</p>
</blockquote>
<h1 id="Redis不是万金油"><a href="#Redis不是万金油" class="headerlink" title="Redis不是万金油"></a>Redis不是万金油</h1><p>在面试的时候，常被问比较下Redis与Memcache的优缺点，个人觉得这二者并不适合一起比较，一个是非关系型数据库不仅可以做缓存还能干其它事情，一个是仅用做缓存。常常让我们对这二者进行比较，主要也是由于Redis最广泛的应用场景就是Cache。那么Redis到底能干什么？又不能干什么呢？</p>
<h2 id="Redis都可以干什么事儿"><a href="#Redis都可以干什么事儿" class="headerlink" title="Redis都可以干什么事儿"></a>Redis都可以干什么事儿</h2><p>缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；</p>
<p>排行榜，如果使用传统的关系型数据库来做这个事儿，非常的麻烦，而利用Redis的SortSet数据结构能够非常方便搞定；</p>
<p>计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；</p>
<p>好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；</p>
<p>简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；</p>
<p>Session共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。</p>
<h2 id="Redis不能干什么事儿"><a href="#Redis不能干什么事儿" class="headerlink" title="Redis不能干什么事儿"></a>Redis不能干什么事儿</h2><p>Redis感觉能干的事情特别多，但它不是万能的，合适的地方用它事半功倍。如果滥用可能导致系统的不稳定、成本增高等问题。</p>
<p>比如，用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。</p>
<p>简单总结就是数据量太大、数据访问频率非常低的业务都不适合使用Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/redis/redis-1.png" alt=""></p>
<h1 id="选择总需要找个理由"><a href="#选择总需要找个理由" class="headerlink" title="选择总需要找个理由"></a>选择总需要找个理由</h1><p>上面说了Redis的一些使用场景，那么这些场景的解决方案也有很多其它选择，比如缓存可以用Memcache，Session共享还能用MySql来实现，消息队列可以用RabbitMQ，我们为什么一定要用Redis呢？</p>
<p>速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；<br>注意：单线程仅仅是说在网络请求这一模块上用一个请求处理客户端的请求，像持久化它就会重开一个线程/进程去进行处理</p>
<p>丰富的数据类型，Redis有8种数据类型，当然常用的主要是 String、Hash、List、Set、 SortSet 这5种类型，他们都是基于键值的方式组织数据。每一种数据类型提供了非常丰富的操作命令，可以满足绝大部分需求，如果有特殊需求还能自己通过 lua 脚本自己创建新的命令（具备原子性）；</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/redis/redis-2.png" alt=""></p>
<p>除了提供的丰富的数据类型，Redis还提供了像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等个性化功能。</p>
<p>Redis的代码开源在GitHub，代码非常简单优雅，任何人都能够吃透它的源码；它的编译安装也是非常的简单，没有任何的系统依赖；有非常活跃的社区，各种客户端的语言支持也是非常完善。另外它还支持事务（没用过）、持久化、主从复制让高可用、分布式成为可能。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/redis/redis-3.png" alt=""></p>
<p>做为一个开发者，对于我们使用的东西不能让它成为一个黑盒子，我们应该深入进去，对它更了解、更熟悉。今天简单说了下Redis的使用场景，以及为什么选择了Redis而不是其它。下次对Redis的内部数据结构及常用命令的时间复杂度进行总结。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MySQL InnoDB引擎锁的总结]]></title>
      <url>http://dayutalk.cn/2018/07/09/MySQL-InnoDB%E5%BC%95%E6%93%8E%E9%94%81%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>知其然，知其所以然<br><a id="more"></a></p>
<p>总结一下自己多年来对MySQL的相关知识，做个梳理。</p>
<p>本文用到的MySQL版本：5.7.22</p>
<h1 id="为什么要锁"><a href="#为什么要锁" class="headerlink" title="为什么要锁"></a>为什么要锁</h1><p>我们开的的各式各样系统中，系统运行需要CPU、内存、I/O、磁盘等等资源。但除了硬资源外，还有最为重要的软资源：<strong>数据</strong>。</p>
<p>当人们访问操作我们的系统时，其实归根是对数据的查看与生产。那么对于同一份数据，如果多个用户同时对它查看、修改时会出现什么问题呢？这必然会带来竞争，而为了控制并发的读取、修改数据会对数据造成的不一致、错乱等问题，数据库引入了锁的机制。</p>
<p>当然锁的问题解决了并发访问数据的问题，而不可避免的会对系统的性能产生负面影响。总结一下各种锁的使用场景方便在实践中更好的运用它从而提升系统性能。</p>
<h1 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h1><blockquote>
<p>我们日常开发中用到最多的存储引擎是Innodb 与 MyISAM两种，而 Innodb 现在更多是首选，因此主要是对 Innodb 的说明，MyISAM 跟多是作为一个对比的角色。  </p>
</blockquote>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/sql/suotype.png" alt=""></p>
<p>MySQL的锁可以按照多种方式进行划分，这里使用最常用的两种方式进行划分：粒度与使用方式。</p>
<p>需要特别说明的是：乐观锁与悲观锁并不是数据库中实现的锁机制，是需要我们自己去实现的。它是一种思想，我们不仅仅可以用在MySQL中，其它地方有需要的也可以用到。而像悲观锁它也是利用数据库现有的机制进行实现的。下面先根据不同分类对说明相关概念。</p>
<h2 id="按使用方式"><a href="#按使用方式" class="headerlink" title="按使用方式"></a>按使用方式</h2><p><strong>乐观锁</strong> 机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。相对悲观锁而言，乐观锁更倾向于开发运用。</p>
<p><strong>悲观锁</strong> 具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<h2 id="按粒度"><a href="#按粒度" class="headerlink" title="按粒度"></a>按粒度</h2><p><strong>表级锁</strong> 是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁分为表共享读锁与表独占写锁。</p>
<p><strong>行级锁</strong> 是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>
<p><strong>页级锁</strong> 是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。</p>
<p>这里需要说明的是，悲观锁是一种思想，它的实现是使用了 共享锁与排他锁来实现的。因此悲观锁本身并不是MySQL实现的锁机制，它是我们造出来的一个概念。</p>
<p>另外，我看到很多文章在讲悲观锁时，只说排他锁是悲观锁机制，没有说共享锁是什么机制，而我认为共享锁也属于悲观锁，具体原因往后看。</p>
<h1 id="InnoDB中加锁"><a href="#InnoDB中加锁" class="headerlink" title="InnoDB中加锁"></a>InnoDB中加锁</h1><p>InnoDB 实现了两种类型的行锁，共享锁（S）与排他锁（X）。然后由于 InnoDB引擎又支持表级锁，所以它内部又有意向共享锁（IS）与意向排他锁（IX）。这两种表锁，都是InnoDB内部自动处理，换句话说我们写代码是无法控制也不需要控制的。我们能控制的是S与X锁。</p>
<h2 id="为MySQL加锁"><a href="#为MySQL加锁" class="headerlink" title="为MySQL加锁"></a>为MySQL加锁</h2><p>在日常操作中，<strong>UPDATE</strong>、<strong>INSERT</strong>、<strong>DELETE</strong> InnoDB会自动给涉及的数据集加排他锁，一般的 <strong>SELECT</strong> 一般是不加任何锁的。我们可以使用以下方式显示的为 <strong>SELECT</strong> 加锁。</p>
<ul>
<li>共享锁：select * from table_name where id =10 lock in share mode;</li>
<li>排他锁：select * from table_name where id=10 for update;</li>
</ul>
<p>那么什么时候该用共享锁什么时候用排他锁呢？<br>一般来讲，共享锁主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作（包括加锁的事物也只能读）。简单说就是大家都可以读数据，但是无法修改（更新或者删除），因此我认为::共享锁也是悲观锁::的一种实现。<br>排他锁是与共享锁相对应，自身加排他锁的事物能够自己发起修改操作，其它事物无法再对该数据加共享或者排他锁。</p>
<p>这里需要注意上面说到的一点，由于InnoDB引擎是行锁，不管我们在这条数据上加了共享锁还是排他锁，简单的select语句依然可以使用的，因为默认在InnoDB中select是不加锁的。</p>
<p>这里还有一点，上图中我们写到一个 <strong>间隙锁</strong>，这是什么东西？比如：当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。它存在的主要目的有一个是为了解决幻读问题，因为RR作为InnoDB的默认事物隔离级别，是存在幻读问题的，而我们在实际操作中确没有出现，就是因为这里做了处理。</p>
<p>关于乐观锁是如何加锁的，这个不同系统有不同的实现，简单来说，对每一个数据维护一个版本号，每次读取时把版本号读取出来，更新时版本号+1。然后更新时将读取的版本号作为条件，如果有其它事物更新了，那么必然会导致版本号变化，因为本次更新不会成功。这种机制最大程度的保证了并发。</p>
<h2 id="查看锁情况"><a href="#查看锁情况" class="headerlink" title="查看锁情况"></a>查看锁情况</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'innodb_row_lock%';</span><br><span class="line">+-------------------------------+--------+</span><br><span class="line">| Variable_name                 | Value  |</span><br><span class="line">+-------------------------------+--------+</span><br><span class="line">| Innodb_row_lock_current_waits | 0      |</span><br><span class="line">| Innodb_row_lock_time          | 218276 |</span><br><span class="line">| Innodb_row_lock_time_avg      | 18189  |</span><br><span class="line">| Innodb_row_lock_time_max      | 51058  |</span><br><span class="line">| Innodb_row_lock_waits         | 12     |</span><br><span class="line">+-------------------------------+--------+</span><br><span class="line">5 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure>
<p>上面的语句能够展示当前系统锁的情况，当系统锁争用比较严重的时候，<code>Innodb_row_lock_waits</code> 和 <code>Innodb_row_lock_time_avg</code> 的值会比较高。上面的数据是由于我做实验导致的。大家可以检查下自己的系统。</p>
<h2 id="InnoDB什么时候会锁表"><a href="#InnoDB什么时候会锁表" class="headerlink" title="InnoDB什么时候会锁表"></a>InnoDB什么时候会锁表</h2><p>我们常常说InnoDB是行锁，但是这里介绍一下它锁表的情况。</p>
<p>InnoDB行锁是通过索引上的索引项来实现的，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！<br>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p>
<p>这里我们实际演示一下，一来让大家了解如何测试锁情况，二来这样用例子也许更容易说明问题。表结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Create Table: CREATE TABLE `tb_user` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `age` mediumint(9) NOT NULL DEFAULT &apos;1&apos;,</span><br><span class="line">  `money` int(11) NOT NULL DEFAULT &apos;0&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/sql/demosql.png" alt=""></p>
<p>我们看当where条件不是索引时，如果加了排他锁，对这个表其它行记录也不能再加排他锁了，这明显就是锁住了整个表。而如果条件是索引字段，则它只会对where条件指定的行数据加锁，另一个事务可以对其它行数据加锁。</p>
<p>有些文章说只有表没有索引才会锁表，通过上面的实验，我觉得是不准确的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>悲观锁与乐观锁是一种思想，而不是数据库锁机制的实现；</li>
<li>InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁；</li>
<li>虽然根据标准InnoDB的默认事务隔离级别RR是存在幻读，但是通过间隙锁以及MVCC解决了幻读的问题；</li>
<li>间隙锁的存在会导致并发插入问题，尽量减少范围查询；</li>
<li>InnoDB的索引设计非常重要。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dockerfile 与 Compose 环境搭建学习笔记（二）]]></title>
      <url>http://dayutalk.cn/2018/06/26/Dockerfile%E4%B8%8ECompose%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Dockerfile 的编写是门手艺<br><a id="more"></a></p>
<p>上一篇文章对整体结构进行了简单记录，这一篇介绍下关于Dockerfile自定义镜像以及各个服务的配置。</p>
<blockquote>
<p>其实 <code>https://hub.docker.com/</code> 上面各种基础镜像非常完善，特别是官方的镜像质量非常之高，而我再捣腾一次完全是为了让自己掌握 Dockerfile 方面的技能而已。  </p>
</blockquote>
<p>在选择基础镜像方面，推荐使用 <code>Alpine</code> ，然后再它上面进行定制，因为它非常的小仅3M。我的 Nginx/Redis 是在 <code>Alpine</code> 基础上定制的，<code>PHP</code> 是在 <code>CentOS7</code>上面进行的定制。截图大家可以感受下大小：</p>
<p><img src="&amp;&amp;&amp;SFLOCALFILEPATH&amp;&amp;&amp;FE7C23F8-FC2D-4B9A-8CF3-B22471ABC2E2.png" alt=""></p>
<h1 id="Dockerfile-与-Compose-建立关联"><a href="#Dockerfile-与-Compose-建立关联" class="headerlink" title="Dockerfile 与 Compose 建立关联"></a>Dockerfile 与 Compose 建立关联</h1><p>关于概念可以看这里：<br><a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a></p>
<p>我这里以 PHP/Redis/Nginx 的定制来进行一些说明（我也只是现学现用，希望高手多指教）。</p>
<p>在上篇的 docker-compose.yml 文件中如下的配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dev.nginx.srv:</span><br><span class="line">	image: lei_nginx:<span class="number">1.14</span><span class="number">.0</span></span><br><span class="line">	build: ./nginx</span><br><span class="line">	volumes:</span><br><span class="line">		- ./nginx/conf:/home/work/app/nginx/conf</span><br><span class="line"><span class="bullet">      -</span> ./www:/home/work/www</span><br><span class="line">	ports:</span><br><span class="line">		- <span class="string">"80:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"443:443"</span></span><br><span class="line">	restart: always</span><br></pre></td></tr></table></figure></p>
<p>这里重要的是多了 build 这个选项，设置的对应目录中可以找到 <code>Dockerfile</code> 这个文件，当我们 <code>docker-compose up</code> 时，docker会根据这个文件去先创建镜像，然后启动一个容器。</p>
<h2 id="Dockerfile-如何写"><a href="#Dockerfile-如何写" class="headerlink" title="Dockerfile 如何写"></a>Dockerfile 如何写</h2><p>网络上有非常多关于 <code>Dockerfile</code> 该如何写的最佳实践，我觉得有几点特别重要：</p>
<ul>
<li>一个容器只运行一个进程；</li>
<li>镜像层数尽可能少，当然还需要考虑可读性等方面的因素；</li>
<li>RUN指令应该用 \ 分成多行方便阅读；</li>
<li>容器镜像要尽可能的小。</li>
</ul>
<p>更多最佳实践可以看这里：<br><a href="https://yeasy.gitbooks.io/docker_practice/content/appendix/best_practices.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/appendix/best_practices.html</a></p>
<p>接下来以 Redis 的 Dockerfile 来聊一聊实际如何编写。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释信息</span></span><br><span class="line"><span class="keyword">LABEL</span> maintainer="HeLei &lt;dayugog@gmail.com&gt;"</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> REDIS_VERSION=<span class="number">3.2</span>.<span class="number">11</span> \</span><br><span class="line">    SRC_DIR=/home/work/src \</span><br><span class="line">    DATA_DIR=/home/work/app/redis/data \</span><br><span class="line">    CONF_DIR=/home/work/app/redis/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置系统时区</span></span><br><span class="line"><span class="keyword">RUN</span> ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> src/ $SRC_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译文件</span></span><br><span class="line"><span class="keyword">RUN</span> set -ex; \</span><br><span class="line">    \</span><br><span class="line">    addgroup -S work &amp;&amp; adduser -S -G work work; \</span><br><span class="line">    apk add --no-cache --virtual .build-deps \</span><br><span class="line">            coreutils \</span><br><span class="line">            gcc \</span><br><span class="line">            jemalloc-dev \</span><br><span class="line">            linux-headers \</span><br><span class="line">            make \</span><br><span class="line">            musl-dev \</span><br><span class="line">        ; \</span><br><span class="line">    \</span><br><span class="line">    cd $SRC_DIR; \</span><br><span class="line">    tar xvzf redis-$REDIS_VERSION.tar.gz; \</span><br><span class="line">    cd redis-$REDIS_VERSION; \</span><br><span class="line">    make &amp;&amp; make install; \</span><br><span class="line">    apk del .build-deps; \</span><br><span class="line">    \</span><br><span class="line">    mkdir -p $DATA_DIR &amp;&amp; mkdir -p $CONF_DIR; \</span><br><span class="line">    chown -R work:work /home; \</span><br><span class="line">    rm -rf $SRC_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝配置文件</span></span><br><span class="line"><span class="keyword">COPY</span> conf/ /home/work/app/redis/conf</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> docker-entrypoint.sh /usr/local/bin/</span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["docker-entrypoint.sh"]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"><span class="comment"># 启动redis</span></span><br><span class="line">CMD [<span class="string">"redis-server"</span>]</span><br></pre></td></tr></table></figure></p>
<p>第一行 <strong>FROM</strong> 用来指定基础镜像。也就是你要在什么镜像上进行定制，我这里选择的是 alpine，这是一个提供的基础空白对象非常小。只是它上面的包管理是 <code>apk</code> ，使用时需要掌握下它的一些参数。</p>
<p><strong>LABEL</strong>可以理解成添加一些说明、描述信息。我这里仅添加了自己的联系方式。可以通过反斜线 <code>\</code> 来进行换行。</p>
<p><strong>ENV</strong>用来设置环境变量，例如：定义一些系统版本、路径的环境变量，在后续RUN中可以使用（当然不仅仅是RUN中可用），也可以用改写原有的环境变量，例如：PATH。</p>
<p><strong>RUN</strong>这是一个非常重要的命令，它是用来执行命令行的命令。就像上面看到的用 yum 安装更新软件，make编译代码等。可以通过反斜线 <code>\</code> 来进行换行。</p>
<p><strong>COPY</strong>它是将宿主机的内容复制到容器中指定的路径。</p>
<p><strong>EXPOSE</strong>指令用于指定容器将要监听的端口。一般设置为应用程序使用常见的端口，例如Redis设置为：<code>6379</code></p>
<p>现在重点说下 <strong>CMD</strong> 与 <strong>ENTRYPOINT</strong> 两个命令。如果Dockerfile中没有 <strong>ENTRYPOINT</strong> 选项，<strong>CMD</strong> 的内容就相当于直接执行某个命令。但是当存在时就是另外一回事。以上面的为例：<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span> docker-entrypoint.sh /usr/local/bin/</span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["docker-entrypoint.sh"]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis</span></span><br><span class="line"><span class="keyword">CMD</span> ["redis-server"]</span><br></pre></td></tr></table></figure></p>
<p>这里设置了一个 <strong>ENTRYPOINT</strong> ，像上面这种情况的时候如果直接启动一个容器时，相当于最后应用启动执行的命令是：<code>./docker-entrypoint.sh redis-server</code>。</p>
<p>根据这个特性，<code>docker-entrypoint.sh</code> 内部可以根据相关参数进行特殊处理。来看下我的 <code>docker-entrypoint.sh</code> 脚本内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">cd `dirname $0`</span><br><span class="line"></span><br><span class="line"># 对文件夹进行权限修改</span><br><span class="line">if [ &quot;$1&quot; = &apos;redis-server&apos; -a &quot;$(id -u)&quot; = &apos;0&apos; ]; then</span><br><span class="line">	chown -R work:work /home</span><br><span class="line">  exec redis-server /home/work/app/redis/conf/redis.conf</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure></p>
<p>可以看到如果脚本后面带的参数是<code>redis-server</code>则会先进行相关目录授权，然后启动redis。如果不是就会直接执行，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/dockerEnv &gt;docker run -it --rm redis:3.2.11 redis-cli -v</span><br><span class="line">redis-cli 3.2.11</span><br></pre></td></tr></table></figure></p>
<p>会直接执行后面这个命令，你可以看到redis客户端的版本信息。这也就是表示，可以把镜像当成一个命令来使用了。</p>
<p>有了 <strong>ENTRYPOINT</strong> 这个功能，可以用它在服务启动时，做更多操作 。例如可以结合 docker-compose.yml 中设置的环境变量做更多事情。可以查看官方的MySQL的 <code>docker-entrypoint.sh</code> 文件内容。</p>
<h1 id="依据Dockerfile启动容器"><a href="#依据Dockerfile启动容器" class="headerlink" title="依据Dockerfile启动容器"></a>依据Dockerfile启动容器</h1><p>Dockerfile 已经写好了，通过下面的命令即可创建镜像启动容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/dockerEnv &gt;docker build -t lei_redis:3.2.11 .</span><br></pre></td></tr></table></figure></p>
<p>在 redis/ 目录下执行上面的命令，他会先获取基础镜像，然后根据命令逐条执行，完成redis的编译、安装以及相关清理工作。</p>
<p>编译完成后可用通过<code>docker image ls</code>查看当前的镜像列表数据。</p>
<p>然后通过 <code>docker run -it -p 6379:6379 -d lei_redis:3.2.11</code> 启动一个容器。</p>
<p>启动完成后，大家可以用redis客户端链接查看redis已经正常启动。</p>
<p>当然还有 PHP/Nginx 的镜像定制，以及每个服务的配置，大家可以在github上查看详情，这里就不再赘述了，剩下再介绍下这个过程中遇的到的几个错误。</p>
<h1 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h1><ol>
<li><strong>在宿主机中无法连接Redis</strong><br>这是由于bind的问题。以前在 vagrant 中安装redis也遇到过， 通过将配置修改为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>宿主机能够连接到服务器上。这样设置的含义是，让容器中的Redis监听容器ip的所有端口。这样设置而不是指定ip是因为每个镜像可以启动多个容器，而每个容器的ip地址是不确定的。</p>
<ol>
<li><strong>镜像创建时报错</strong><br>报错信息如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: for dockerenv_dev.php-fpm.srv_1  Cannot start service dev.php-fpm.srv: OCI runtime create failed: container_linux.go:348: starting container process caused &quot;exec: \&quot;docker-entrypoint.sh\&quot;: executable file not found in $PATH&quot;: unknown</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个问题主要是：我的 <code>docker-entrypoint.sh</code> 文件没有可执行权限，因此在镜像创建完后，执行<strong>ENTRYPOINT</strong>指定的脚本时导致错误，解决办法当然很简单，直接执行：<code>chmod +x docker-entrypoint.sh</code>。然后需要重新创建镜像。</p>
<ol>
<li><strong>Nginx 无法连接php-fpm</strong><br>这个错误其实与宿主机无法连接Redis很像，错误信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018/06/13 11:13:26 [error] 5#0: *8 connect() failed (111: Connection refused) while connecting to upstream, client: 172.18.0.1, server: localhost, request: &quot;GET / HTTP/1.1&quot;, upstream: &quot;fastcgi://172.18.0.2:9000&quot;, host: &quot;localhost&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>修改 php-fpm 的监听地址为：<strong>0.0.0.0:9000</strong>，Nginx可正常启动。</p>
<ol>
<li><strong>访问php文件时找不到文件</strong><br>执行动态文件时，出现了文件找不到的提示，具体错误信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018/06/13 11:21:20 [error] 5#0: *10 FastCGI sent in stderr: &quot;Primary script unknown&quot; while reading response header from upstream, client: 172.18.0.1, server: localhost, request: &quot;GET / HTTP/1.1&quot;, upstream: &quot;fastcgi://172.18.0.2:9000&quot;, host: &quot;localhost&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由于Nginx与PHP没有部署在同一个容器中，相关的项目文件只与Nginx进行了共享，而没有与PHP的容器进行共享。因此当访问静态文件时，Nginx直接在自己的容器中完成操作，而访问php文件时信息传到了PHP所在的容器，容器内部无法找到对应的php文件而导致的错误。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过2天的折腾，算是基本把环境搭建起来了。不过还有一些其他问题需要思考该如何进行：</p>
<ul>
<li>如果我的PHP需要新的扩展，该如何去编译这个扩展包？</li>
<li>如何去监控docker中的应用的状态？比如：Redis/Nginx等服务的状态。</li>
</ul>
<p>后续会继续摸索分享自己的经验。</p>
<p>项目地址：<br><a href="https://github.com/helei112g/docker-env" target="_blank" rel="external">https://github.com/helei112g/docker-env</a></p>
<p>参考资料：</p>
<ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/</a></li>
<li><a href="https://docs.lvrui.io/2017/06/09/%E7%BC%96%E5%86%99docker-entrypoint-sh%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6/" target="_blank" rel="external">https://docs.lvrui.io/2017/06/09/%E7%BC%96%E5%86%99docker-entrypoint-sh%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6/</a></li>
<li><a href="https://pkgs.alpinelinux.org/packages" target="_blank" rel="external">https://pkgs.alpinelinux.org/packages</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dockerfile 与 Compose 环境搭建学习笔记（一）]]></title>
      <url>http://dayutalk.cn/2018/06/25/Dockerfile%E4%B8%8ECompose%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>大家都用docker了，我先把自己的开发环境换了吧~_~<br><a id="more"></a></p>
<p>以前一直使用 <strong>Vagrant</strong> 作为自己的开发环境，并且在上家公司也推行大家采用 Vagrant 作为开发环境，保障公司使用的是同一套开发环境。随着docker的流行，越来越多的人在docker上运行自己的项目，利用docker也非常方便模拟各种线上集群，相比虚拟机效率会更高，不管是搭建还是运行。</p>
<p>网络上关于docker搭建环境的资料非常之多了，但自己一直没有进行过实践。纸上得来终觉浅，只有自己动过手之后，才能对相关的概念更熟悉。花了将近2天时间折腾，终于算是把docker的开发环境搭建好了，对他的很多概念也又了更深入的认识。整理一下整个过程，方便以后查漏补缺。</p>
<p>下面就来开启docker之旅吧，打算利用docker完成以下任务：</p>
<ul>
<li>基础的环境搭建：MySQL、Redis、Nginx；</li>
<li>搭建PHP、Golang的开发环境；</li>
<li>搭建MySQL、Redis的主从；</li>
<li>探索一下如何监控docker中的进程。</li>
</ul>
<h1 id="涉及的命令介绍"><a href="#涉及的命令介绍" class="headerlink" title="涉及的命令介绍"></a>涉及的命令介绍</h1><p>这仅仅是操作笔记，不涉及 <strong>Docker</strong> 原理什么之类的知识，重点是如何应用。为了后续理解方便，先把用到的相关命令在这里进行整体介绍。</p>
<h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker search mysql</span><br></pre></td></tr></table></figure>
<p>上面这个命令就是查找 mysql 镜像。对应的可以将 mysql 替换成其它想要查找的镜像名称。该命令常用选项是： <code>-s</code>。可以设置搜索条件：多少个start以上的镜像。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker search -s 100 mysql</span><br></pre></td></tr></table></figure>
<p>搜索有100个以上start的 mysql 镜像。</p>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos7</span><br></pre></td></tr></table></figure>
<p>这个命令会把镜像克隆到本地，就像：<code>git clone</code> 一样的效果。关于什么是镜像、容器之类的概念不在我的讲解范畴了。</p>
<h2 id="查看与删除镜像"><a href="#查看与删除镜像" class="headerlink" title="查看与删除镜像"></a>查看与删除镜像</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker image ls</span><br></pre></td></tr></table></figure>
<p>会列出当前所有的本地安装了的镜像。看到了有哪些镜像，有时候一个镜像我们用不到了，想把它干掉，为硬盘腾腾位置，可以用下面的命令：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker rmi 0d16d0a97dd1 <span class="comment"># 编号是 image id</span></span><br></pre></td></tr></table></figure>
<h2 id="创建镜像-Dockerfile"><a href="#创建镜像-Dockerfile" class="headerlink" title="创建镜像 - Dockerfile"></a>创建镜像 - Dockerfile</h2><p>docker的镜像可以从官方直接拉取，也可也通过 Dockerfile 进行定制，写好 Dockerfile 文件后，可以执行下面的命令运行镜像。<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker build -t nginx:1.14.0 .</span><br></pre></td></tr></table></figure></p>
<p>这里的结尾有个 <code>.</code> 它表示上下文，而不是说 Dockerfile 的路径。举例来说，在 Dockerfile 中常常用 Copy 指令，它拷贝的文件必须要在这个上下文中。</p>
<p>Dockerfile的主要作用是：自己根据基础镜像，重新定制镜像，而不是直接从官方仓库拿现成的使用。</p>
<p>具体含义可以看这里：<a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a></p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker <span class="keyword">run</span> -it --rm php:7 bash</span><br></pre></td></tr></table></figure>
<p>上面的命令会启动一个容器，并且分配一个伪终端，退出后容器就会被删除。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker <span class="keyword">run</span> -d -p 9000:9000 php:7</span><br></pre></td></tr></table></figure>
<p>这个命令会在后台运行一个容器，此容器不会因为退出就被删除，可以重复进行start、stop操作。</p>
<p>上面两种容器启动的操作方式，在我的文章中其实不会出现，我的环境是基于docker-compose + Dockerfile 来搭建的。因为根据最佳实践：一个容器内部只包含一个进程，像上面我需要安装：PHP/Golang/Redis/Nginx/Mysql等，就算不算主从也需要启动5个容器，每次这样启动都要累死，还不说需要管理容器之间的互联。因此我使用Compose来定义和运行多个 Docker 容器的应用。</p>
<h2 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker inspect a49dfb2e6f45 <span class="comment"># image id</span></span><br></pre></td></tr></table></figure>
<p>通过该命令可以看到容器的完整信息，我用这个命令主要是在进行容器互联的时候，检查容器的网络与IP相关的情况。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker exec -it e8d740a6ac7a bash <span class="comment"># image id</span></span><br></pre></td></tr></table></figure>
<p>上面的命令可以进入容器，让你感觉像是 ssh 到了远程机器一样的感觉。</p>
<h2 id="停止、启动"><a href="#停止、启动" class="headerlink" title="停止、启动"></a>停止、启动</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker stop a49dfb2e6f45 <span class="comment"># image id</span></span><br></pre></td></tr></table></figure>
<p>如果容器是在后台启动，可以通过该方式停止容器。停止后可以使用下面的命令启动容器：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker start a49dfb2e6f45 <span class="comment"># image id</span></span><br></pre></td></tr></table></figure>
<h2 id="查看与删除容器"><a href="#查看与删除容器" class="headerlink" title="查看与删除容器"></a>查看与删除容器</h2><p>容器也可以像镜像一样进行查看<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker ps</span><br></pre></td></tr></table></figure></p>
<p>上面的命令只会显示启动了的镜像，如果要查看所有镜像，可以添加 <code>-a</code> 选项。<br>如果某个容器不需要了，可以使用下面的命令进行删除：<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker rm 0d848bc87fe7  <span class="comment"># image id</span></span><br></pre></td></tr></table></figure></p>
<p>容器的删除并不会影响镜像，镜像可以继续用来启动新的容器。并且如果依赖某个镜像创建的容器没有被删除，该镜像是不能直接删除的，需要先删除容器后才能继续删除镜像。</p>
<h2 id="Compose-中的启动与停止"><a href="#Compose-中的启动与停止" class="headerlink" title="Compose 中的启动与停止"></a>Compose 中的启动与停止</h2><p>针对docker compose启动与停止用到下面的命令，个人感觉这就是批量操作，毕竟容器太多，一个一个操作太麻烦，容易遗漏等等问题。</p>
<p>批量启动：<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker-compose up -d</span><br></pre></td></tr></table></figure></p>
<p>虽然该命令并不是单纯的启动容器，它非常强大，将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<p>如果已经创建完了，也可以用下面的命令来启动已经创建的容器。<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker-compose start</span><br></pre></td></tr></table></figure></p>
<p>如果想要停止容器可以使用下面的命令：<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;docker-compose stop</span><br></pre></td></tr></table></figure></p>
<p>当然这些命令的运行，要在 <code>docker-compose.yml</code> 文件所在的目录下运行，否则它也不知道该启动或关闭哪些容器。</p>
<p>基本用到的命令大概就是上面这些，接下来先说说 <code>docker-compose.yml</code> 文件的编写。</p>
<h1 id="Docker-Compose构建环境"><a href="#Docker-Compose构建环境" class="headerlink" title="Docker Compose构建环境"></a>Docker Compose构建环境</h1><p>Docker Compose 可以把多个容器方便的管理起来，也就是所谓的编排技术。</p>
<p>编排技术的核心是 <code>docker-compose.yml</code> 这个模版文件。它定义了容器集群里每一个容器的镜像、数据卷挂载路径、端口、网络等。</p>
<p>以接下来要构建的环境来说明下，下面我将要搭建一个php7的开发环境，需要Nginx/PHP-FPM/MySQL/Redis进行配合。那么需要启动4个容器。对应的也需要4个镜像。整个环境的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── logs</span><br><span class="line">│   └── nginx</span><br><span class="line">├── mysql</span><br><span class="line">│   ├── conf</span><br><span class="line">│   └── data</span><br><span class="line">├── nginx</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── conf</span><br><span class="line">│   └── src</span><br><span class="line">├── php7</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── docker-compose.yml</span><br><span class="line">│   ├── etc</span><br><span class="line">│   ├── extensions</span><br><span class="line">│   └── src</span><br><span class="line">├── redis</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── data</span><br><span class="line">│   └── src</span><br><span class="line">├── start.sh</span><br><span class="line">├── stop.sh</span><br><span class="line">└── www</span><br><span class="line">    └── abc</span><br></pre></td></tr></table></figure>
<p>我的MySQL是直接使用的官方提供的镜像资源，而Redis/Nginx/PHP为了做定制化，我采用Dockerfile进行自定义。接下来按照每一个独立的服务分别进行一下说明。</p>
<h2 id="MySQL服务"><a href="#MySQL服务" class="headerlink" title="MySQL服务"></a>MySQL服务</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dev.mysql.srv:</span><br><span class="line">	image: mysql:<span class="number">5.7</span><span class="number">.22</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line">		- ./mysql/data:/var/lib/mysql</span><br><span class="line"><span class="bullet">      -</span> ./mysql/conf:/etc/mysql/conf.d</span><br><span class="line">	ports:</span><br><span class="line">		- <span class="string">"3307:3306"</span></span><br><span class="line">	restart: always</span><br><span class="line">	environment:</span><br><span class="line">		MYSQL_ROOT_PASSWORD: <span class="number">123123</span></span><br><span class="line">	networks:</span><br><span class="line">		- default</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>image：</strong>是制定依赖的镜像，这里是Docker提供的镜像资源；</li>
<li><strong>volumes：</strong>数据卷所挂载路径设置，主要是MySQL的数据保存的路径设置与配置文件的设置。它的主要作用是持久化数据，避免容器销毁后内部数据丢失；</li>
<li><strong>ports：</strong>暴露到宿主机的端口。这个没什么太多说的，就是为了可以在宿主机访问到容器内部的服务；</li>
<li><strong>restart：</strong>该命令是设置容器如果在某种情况下（非认为）退出了，容器重启的策略；</li>
<li><strong>environment：</strong>设置镜像的环境变量，你可以进入镜像通过：<code>echo $MYSQL_ROOT_PASSWORD</code>查看其值；</li>
<li><strong>networks:</strong>设置网络，让所有的容器在一个网络中，方便容器互联互通。</li>
</ul>
<p>这里还有一个点需要注意，<code>dev.mysql.srv</code> ，是我为mysql服务取的名字。取一个好的名字，非常便于后续容器互联的使用，比如这个名字，如果php代码需要填写mysql的host。我则可以直接使用它。</p>
<h2 id="其它服务"><a href="#其它服务" class="headerlink" title="其它服务"></a>其它服务</h2><p>剩下的三种服务配置方式基本上大同小异。我放在一起说明。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">dev.nginx.srv:</span><br><span class="line">	image: lei_nginx:<span class="number">1.14</span><span class="number">.0</span></span><br><span class="line">	build: ./nginx</span><br><span class="line">	volumes:</span><br><span class="line">		- ./nginx/conf:/home/work/app/nginx/conf</span><br><span class="line"><span class="bullet">      -</span> ./www:/home/work/www</span><br><span class="line">	ports:</span><br><span class="line">		- <span class="string">"80:8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"443:443"</span></span><br><span class="line">	restart: always</span><br><span class="line">	networks:</span><br><span class="line">		- default</span><br><span class="line">	depends_on:</span><br><span class="line"><span class="bullet">      -</span> dev.php-fpm.srv</span><br><span class="line">dev.redis.srv:</span><br><span class="line">	image: lei_redis:<span class="number">3.2</span><span class="number">.11</span></span><br><span class="line">	build: ./redis</span><br><span class="line">	volumes:</span><br><span class="line">		- ./redis/conf:/home/work/app/redis/conf</span><br><span class="line"><span class="bullet">      -</span> ./redis/data:/home/work/app/redis/data</span><br><span class="line">	ports:</span><br><span class="line"><span class="bullet">      -</span> <span class="string">"6379:6379"</span></span><br><span class="line">	restart: always</span><br><span class="line">	networks:</span><br><span class="line"><span class="bullet">      -</span> default</span><br><span class="line">dev.php-fpm.srv:</span><br><span class="line">	image: lei_php:<span class="number">7.2</span><span class="number">.6</span></span><br><span class="line">	build: ./php7</span><br><span class="line">	volumes:</span><br><span class="line">		- ./php7/etc:/home/work/app/php/etc</span><br><span class="line">		- ./www:/home/work/www</span><br><span class="line">	ports:</span><br><span class="line">		- <span class="string">"9000:9000"</span></span><br><span class="line">	restart: always</span><br><span class="line">	networks:</span><br><span class="line">		- default</span><br></pre></td></tr></table></figure></p>
<p>这里与MySQL最大的一个区别是多了一个 build 选项。这就是上面说到的这三个镜像都是我用Dockerfile定制的有关。你可以在对应的 build 指定的目录下看到 <code>Dockerfile</code> 这个文件。</p>
<p>另外一个需要注意的地方是Nginx中配置的 <code>depends_on</code> 选项，他的作用是指定依赖，因为Nginx中我配置了php-fpm。所以它启动前要确保php-fpm已经启动后，他才能正常的启动。</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>为了减少太多概念的东西，你可以先直接从github拉取这部分配置，然后运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ ~/home/dockerenv &gt;./start.sh</span><br><span class="line">Starting dockerenv_dev.php-fpm.srv_1 ... done</span><br><span class="line">Starting dockerenv_dev.redis.srv_1   ... done</span><br><span class="line">Starting dockerenv_dev.mysql.srv_1   ... done</span><br><span class="line">Creating dockerenv_dev.nginx.srv_1   ... done</span><br></pre></td></tr></table></figure>
<p>如果你是第一次运行 <code>start.sh</code> ，他还会去docker hub上拉取镜像，以及根据Dockerfile来定制镜像。所以会有非常多的输出信息。</p>
<p> 然后访问：<a href="http://localhost" target="_blank" rel="external">http://localhost</a> 。应该就能够看到 phpinfo() 输出的信息。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过自己的熟悉，对基本的docker命令，以及docker的三个基础概念：仓库、镜像、容器有了充分的认识。利用 docker compose 搭建一个环境后，对于容器的互联也有了更深刻的体会，并且经过这种一个容器运行一个进程的方式，对系统也有了一些更深的认识。在利用Dockerfile定制镜像的过程中，通过反复的 build 镜像，对理解容器的分层、如何确保镜像体积更小方面有了相当多的实践，特别是在<strong>ENTRYPOINT</strong>的设置上，认识到了docker的启动流程。</p>
<p>由于篇幅限制，把 Dockerfile 的内容在拆出一篇来进行说明，以及把遇到的一些问题也进行一些整理。</p>
<p>我的docker环境：<a href="https://github.com/helei112g/docker-env" target="_blank" rel="external">https://github.com/helei112g/docker-env</a></p>
<p><em>以后换机装换机，再也不担心了</em></p>
<p>参考资料：</p>
<ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Golang中函数传参存在引用传递吗？]]></title>
      <url>http://dayutalk.cn/2018/06/11/Golang%E4%B8%AD%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E5%AD%98%E5%9C%A8%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%90%97%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>Go的函数传递详解，一篇文章搞明白Golang的值传递。<br><a id="more"></a></p>
<p>继上篇文章后，继续来探讨下面的几个问题:</p>
<ol>
<li>函数传参中值传递、指针传递与引用传递到底有什么不一样？</li>
<li>为什么说 <strong>slice</strong>、<strong>map</strong>、<strong>channel</strong> 是引用类型？</li>
<li>Go中 <strong>slice</strong> 在传入函数时到底是不是引用传递？如果不是，在函数内为什么能修改其值？</li>
</ol>
<blockquote>
<p>In a function call, the function value and arguments are evaluated in the usual order. After they are evaluated, the parameters of the call are <strong>passed by value</strong> to the function and the called function begins execution.<br>文档地址：<a href="https://golang.org/ref/spec#Calls" target="_blank" rel="external">https://golang.org/ref/spec#Calls</a></p>
</blockquote>
<p>官方文档已经明确说明：<strong>Go里边函数传参只有值传递一种方式</strong>，为了加强自己的理解，再来把每种传参方式进行一次梳理。</p>
<h1 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h1><blockquote>
<p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
</blockquote>
<p>概念总给人一种教科书的感觉，写点代码验证下。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, &amp;a) <span class="comment">// (*int)(0xc420018080)</span></span><br><span class="line">	vFoo(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vFoo</span><span class="params">(b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, &amp;b) <span class="comment">// (*int)(0xc420018090)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>注释内容是我机器的输出，你如果运行会得到不一样的输出</em></p>
<p>根据代码来解释下，所谓的值传递就是：实参 <strong>a</strong> 在传递给函数 <strong>vFoo</strong> 的形参 <strong>b</strong> 后，在 <strong>vFoo</strong> 的内部，<strong>b</strong> 会被当作局部变量在栈上分配空间，并且完全拷贝 <strong>a</strong> 的值。</p>
<p>代码执行后，我们看到的结果便是：a、b拥有完全不同的内存地址， 说明他们虽然值相同（b拷贝的a，值肯定一样），但是分别在内存中不同的地方，也因此在函数 <strong>vFoo</strong> 内部如果改变 <strong>b</strong> 的值，<strong>a</strong> 是不会受到影响的。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/funcCall1.png" alt="funcCall"></p>
<p>图中左侧是还未调用时，内存的分配，右侧是调用函数后内存分别分配的变量。这里需要注意，就算vFoo的参数名字是a，实参与形参也分别有自己的内存空间，因为参数的名字仅仅是给程序员看的，上篇文章已经说清楚了。</p>
<h1 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h1><blockquote>
<p>形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</p>
</blockquote>
<p>是不是云里雾里的？还是通过代码结合来分析所谓的指针传递。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	pa := &amp;a</span><br><span class="line">	fmt.Printf(<span class="string">"value: %#v\n"</span>, pa) <span class="comment">// value: (*int)(0xc420080008)</span></span><br><span class="line">	fmt.Printf(<span class="string">"addr: %#v\n"</span>, &amp;pa) <span class="comment">// addr: (**int)(0xc420088018)</span></span><br><span class="line">	pFoo(pa)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pFoo</span><span class="params">(p * <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"value: %#v\n"</span>, p) <span class="comment">// value: (*int)(0xc420080008)</span></span><br><span class="line">	fmt.Printf(<span class="string">"addr: %#v\n"</span>, &amp;p) <span class="comment">// addr: (**int)(0xc420088028)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义了一个变量 a，并把地址保存在指针变量 pa 里边了。按照我们定的结论，<strong>Go中只有值传递</strong>，那么指针变量pa传给函数的形参p后，形参将会是它在栈上的一份拷贝，他们本身将各自拥有不同的地址，但是二者的值是一样的（都是变量a的地址）。上面的注释部分是我程序运行后的结果，pa 与 p 的地址各自互不相关，说明在参数传递中发生了值拷贝。</p>
<p>在函数 <strong>pFoo</strong> 中，形参 p 的地址与实参 pa 的地址并不一样，但是他们在内存中的值都是变量 a 的地址，因此可以通过指针相关的操作来改变a的值。<br><img src="http://ol59nqr1i.bkt.clouddn.com/funcCall2.png" alt="funcCall"></p>
<p><em>图中 &amp;a 表示a的地址，值为： 0xc420080008</em></p>
<h1 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h1><blockquote>
<p>所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
</blockquote>
<p>由于 Go 里边并不存在引用传递，我们常常看到说 Go 中的引用传递也是针对：<strong>Slice</strong>、<strong>Map</strong>、<strong>Channel</strong> 这几种类型（这是个错误观点），因此为了解释清楚引用传递，先劳烦大家看一段 C++ 的代码（当然非常简单）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rFoo</span><span class="params">(<span class="keyword">int</span> &amp; ref)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;ref);<span class="comment">// 0x7ffee5aef768</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);<span class="comment">// 0x7ffee7307768</span></span><br><span class="line">    <span class="keyword">int</span> &amp; b = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;b);<span class="comment">// 0x7ffee5aef768</span></span><br><span class="line">    rFoo(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就是简单的在main中定义一个引用，然后传给函数 <strong>rFoo</strong>，那么来看看正统的引用传递是什么样的？</p>
<p>这里 b 是 a 的别名（引用，不清楚的可以看我上篇文章），因此a、b必定具备相同的地址。那么按照引用传递的定义，实参 b 传给形参 ref 之后，ref 将是 b 的别名（也即a、b、ref都是同一个变量），他们将拥有相同地址。通过在 <strong>rFoo</strong> 函数中的打印信息，可以看到三者具有完全形同的地址，这是所谓的引用传递。</p>
<h1 id="Go中没有引用传递"><a href="#Go中没有引用传递" class="headerlink" title="Go中没有引用传递"></a>Go中没有引用传递</h1><p>Go中函数调用只有值传递，但是类型引用有引用类型，他们是：<strong>slice</strong>、<strong>map</strong>、<strong>channel</strong>。来看看官方的说法：</p>
<blockquote>
<p>There’s a lot of history on that topic. Early on, maps and channels were syntactically pointers and it was impossible to declare or use a non-pointer instance. Also, we struggled with how arrays should work. Eventually we decided that the strict separation of pointers and values made the language harder to use.  <strong>Changing these types to act as references to the associated, shared data structures resolved these issues</strong>. This change added some regrettable complexity to the language but had a large effect on usability: Go became a more productive, comfortable language when it was introduced.</p>
</blockquote>
<p>大概意思是说：最开始用的是指针语法，由于种种原因改成了引用，但是这个引用与C++的引用是不同的，它是共享关联数据的结构。关于这个问题的深入讨论我会放到 <strong>slice</strong> 相关文章中进行讨论，现在回到今天讨论的主题。</p>
<p>那么Go的引用传递源起何处？我觉得让大家误解的是，map、slice、channel这类引用类型在传递到函数内部，可以在函数内部对它的值进行修改而引起的误会。</p>
<p>针对这种三种类型是 <strong>by value</strong> 传递，我们用 slice 来进行验证。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"addr:%p\n"</span>, &amp;arr)<span class="comment">// addr:0xc42001a1e0</span></span><br><span class="line">	s1 := arr[:]</span><br><span class="line">	fmt.Printf(<span class="string">"addr:%p\n"</span>, &amp;s1)<span class="comment">// addr:0xc42000a060</span></span><br><span class="line"></span><br><span class="line">	changeSlice(s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"addr:%p\n"</span>, &amp;s)<span class="comment">// addr:0xc42000a080</span></span><br><span class="line">	fmt.Printf(<span class="string">"addr:%p\n"</span>, &amp;s[<span class="number">0</span>])<span class="comment">// addr:0xc42001a1e0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中定义了一个数组 <strong>arr</strong>，然后用它生成了一个slice。如果go中存在引用传递，形参 s 的地址应该与实参 s1 一样（上面c++的证明），通过实际的情况我们发现它们具备完全不同的地址，也就是传参依然发生了拷贝——值传递。</p>
<p>但是这里有个奇怪的现象，大家看到了 <strong>arr</strong> 的地址与 <strong>s[0]</strong> 有相同的地址，这也就是为什么我们在函数内部能够修改 slice 的原因，因为当它作为参数传入函数时，虽然 slice 本身是值拷贝，但是它内部引用了对应数组的结构，因此 <strong>s[0]</strong> 就是 <strong>arr[0]</strong> 的引用，这也就是能够进行修改的原因。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/funcCall3.png" alt="funcCall"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>Go 中函数传参仅有值传递一种方式；</li>
<li><strong>slice</strong>、<strong>map</strong>、<strong>channel</strong>都是引用类型，但是跟c++的不同；</li>
<li><strong>slice</strong>能够通过函数传参后，修改对应的数组值，是因为 slice 内部保存了引用数组的指针，并不是因为引用传递。</li>
</ul>
<p>接下来的文章尝试解析下：<br>slice 为什么一定要用 make 进行初始话，它初始化做了哪些事情？它每次动态扩展容量的时候进行了什么操作？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[指针、引用的理解]]></title>
      <url>http://dayutalk.cn/2018/06/06/%E6%8C%87%E9%92%88%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>指针与引用常常被混淆，他们为什么总被人理解错误？<br><a id="more"></a></p>
<p>最近在学习Golang的过程中，发现一个有意思的事情，有的文章说函数调用传参时 <strong>slice</strong> 是引用传递，有的说是值传递。为什么同一个东西大家会不同认识？为了搞清楚其本质，我进行了以下内容的研究：</p>
<ol>
<li>变量的变量名、变量值、变量地址在内存中是怎么样的？</li>
<li>指针的定义是什么？引用的定义是什么？二者有什么关系？</li>
<li>函数传参中值传递、指针传递与引用传递到底有什么不一样？</li>
<li>Go中 <strong>slice</strong> 在传入函数时到底是不是引用传递？如果不是，在函数内为什么能修改其值？</li>
</ol>
<p>为了避免文章写的过长，看了想瞌睡，分成两篇文章来解释这个问题，本文先解决问题1跟2，下一篇说明余下的问题。</p>
<h1 id="变量名程序员给地址取的外号"><a href="#变量名程序员给地址取的外号" class="headerlink" title="变量名程序员给地址取的外号"></a>变量名程序员给地址取的外号</h1><p>上学的时候，老师讲变量是存在内存中的，内存就像一排排抽屉组成的，每个抽屉上面有个编号，我们定义一个变量，就是把想放的东西放到这个对应编号的抽屉里。比如： int a = 10，用图来表示下：<br><img src="http://ol59nqr1i.bkt.clouddn.com/ref1.png" alt=""></p>
<p>这里：变量的名字叫 <strong>a</strong> ，变量的值是：<strong>10</strong>，变量的地址是：<strong>0x 00000001</strong>。<br>那么问题来了，变量的值我们知道是放在了抽屉里（内存中），每个抽屉有编号（地址），但是变量的名字 <strong>a</strong> 存放在哪里呢？或者说它会存在于内存中吗？</p>
<p>大家想一个问题，如果变量的名字要存放在内存中，那么肯定分配一个空间给他，保存它的空间有个地址，这个地址是不是又得有个地方存起来程序才能找到？如果真是这样设计，那么代码根本没发写、无法运行了。</p>
<p>其实变量名仅仅是写给程序员看的，让我们写代码的时候知道这个变量有什么用，能够通过名字调用变量的值。因为如果直接给你一个地址 0x 23004123，你知道这是要干嘛吗？代码经过编译后，最终都会转换成机器码，我们定义的变量名就都不存在了，存在的只有地址跟值。</p>
<h1 id="指针其实很普通"><a href="#指针其实很普通" class="headerlink" title="指针其实很普通"></a>指针其实很普通</h1><p>有了上面的理解，再来一个特殊的变量：指针变量。什么叫指针变量呢？其实就是这个变量里边存放的是一个变量的地址，通过这个地址，机器可以找到对应变量的值，例如：int <em> pa = &amp;a，就表示变量 <strong>pa</strong> 抽屉里放的是 <strong>a</strong> 的地址，它的类型是：int</em>，继续看图：<br><img src="http://ol59nqr1i.bkt.clouddn.com/ref2.png" alt=""></p>
<p><strong>这里需要重要说明的是：指针pa与a的关系是：a抽屉里边放的是变量值10，pa放的是变量的地址：0x00000001</strong>，这里一定要记住，下面说引用的时候才更容易理解。</p>
<h1 id="引用就是变量的另一名字"><a href="#引用就是变量的另一名字" class="headerlink" title="引用就是变量的另一名字"></a>引用就是变量的另一名字</h1><p>继续谈引用，引用与指针我们经常傻傻分不清，因为它们的行为确实非常诡异，看起来效果非常相似，看代码：</p>
<blockquote>
<p>由于引用的概念是在 c++ 中引入的，因此下面的代码使用c++，仅仅是一些打印而已，放心看下去  </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">// 变量</span></span><br><span class="line">    <span class="keyword">int</span> * pa = &amp;a; <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">int</span> &amp; b = a; <span class="comment">// 引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a: %d\n"</span>, a);<span class="comment">// a: 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*pa: %d\n"</span>, *pa);<span class="comment">// *pa: 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b: %d\n"</span>, b);<span class="comment">// b: 10</span></span><br><span class="line"></span><br><span class="line">    *pa = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a: %d\n"</span>, a);<span class="comment">// a: 20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*pa: %d\n"</span>, *pa);<span class="comment">// *pa: 20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b: %d\n"</span>, b);<span class="comment">// b: 20</span></span><br><span class="line"></span><br><span class="line">    b = <span class="number">30</span>;</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">"a: %d\n"</span>, a);<span class="comment">// a: 30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*pa: %d\n"</span>, *pa);<span class="comment">// *pa: 30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b: %d\n"</span>, b);<span class="comment">// b: 30</span></span><br><span class="line"></span><br><span class="line">	  a = <span class="number">40</span>;</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">"a: %d\n"</span>, a);<span class="comment">// a: 40</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*pa: %d\n"</span>, *pa);<span class="comment">// *pa: 40</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b: %d\n"</span>, b);<span class="comment">// b: 40</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们发现，指针与引用都能达到一个效果：都有能力修改a的值，指针前面讲过了，因为它保存了a的地址，通过解引用操作后，实际上就是打开了a的抽屉，因此可以进行修改。那么引用又是怎么办到的？这里注意一个细节：<em>pa = 20； c = 30；a = 40。我们看到操作c的时候与操作a是一样的方式：直接使用变量名，但是pa要想改变a的值，必须进行 </em>pa 操作（解引用），如果直接 pa=20，这仅仅是改变的pa的值，让他指向了另外一个地址。</p>
<p>为什么引用与变量是一样的操作方式？先来看一下引用的定义：</p>
<blockquote>
<p>引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。  </p>
</blockquote>
<p>那么别名是什么意思呢？继续看图，一看就懂<br><img src="http://ol59nqr1i.bkt.clouddn.com/ref3.png" alt=""><br>看到了吧？a就是b，b就是a。系统并不会为引用额外分配空间进行存储，甚至可以简单理解为：这个别名仅仅是为了给程序员看的，到机器码层面的时候，他们都会变成地址：0x 00000001。</p>
<h1 id="有码为证"><a href="#有码为证" class="headerlink" title="有码为证"></a>有码为证</h1><p>通过上面的分析不知道你理解了几分？或者你是不是对指针与引用还是半信半疑？没关系，写点代码证明一下即可，我们要证明的是：</p>
<ul>
<li>引用是变量的别名，那么它的地址应该与变量一致；</li>
<li>指针保存的是变量的地址，那么它的值是变量的地址，它自身的地址与变量不同。</li>
</ul>
<p>为了证明，程序设计如下：定义一个变量，分别赋值给指针、引用，然后检查他们对应的值与地址。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"~~~~~~~~~~~~~~\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> * b = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"~~~~~~~~~~~~~~\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> &amp; c = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>获得输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10 // 变量a的值</span><br><span class="line">0x7ffee3c7a768 // 变量a的地址</span><br><span class="line">~~~~~~~~~~~~~~</span><br><span class="line">0x7ffee3c7a768 // 指针的值，是变量a的地址</span><br><span class="line">0x7ffee3c7a760 // 指针变量自己的地址</span><br><span class="line">~~~~~~~~~~~~~~</span><br><span class="line">10 // 变量a的值</span><br><span class="line">0x7ffee3c7a768 // 引用变量c的地址，与变量a的地址完全一样</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在上面如果指针想要打印变量a的值，需要解引用操作：printf(“%d\n”, *b);  </p>
</blockquote>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>变量由三分部分构成：变量名、变量值、变量地址；</li>
<li>变量名实际上只是给程序员看的，编译后的代码中并不存在变量名；</li>
<li>指针变量就是一个变量存储了另外一个变量的地址，系统也会为他分配内存空间来存储这个地址；</li>
<li>引用实际是变量的别名，他跟变量有相同的地址。</li>
</ul>
<p><strong>下次预告：</strong></p>
<ol>
<li>函数传参中值传递、指针传递与引用传递到底有什么不一样？</li>
<li>为什么说 <strong>slice</strong> 是引用类型？</li>
<li>Go中 <strong>slice</strong> 在传入函数时到底是不是引用传递？如果不是，在函数内为什么能修改其值？</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一个程序员对架构的认识]]></title>
      <url>http://dayutalk.cn/2018/05/27/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AF%B9%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>架构是一个系统的草图（逻辑+物理角度），它是有生命的，随着业务的变化会不断演进。没有完美的架构只有合适的架构。<br><a id="more"></a></p>
<p>最近订阅了一些架构方面的资料，阅读后获益匪浅，想着整理一些自己的体会与思考，形成架构方面的读书笔记，一来与大家交流，二来通过文字的形式检查自己到底收获多少！</p>
<p>“我们系统是MVC架构的”</p>
<p>“淘宝的架构好屌”</p>
<p>“最近在学习MySQL的架构”</p>
<p>“这个系统开发我们要用MVC框架来进行开发”</p>
<hr>
<p>我们常常听到上面关于架构的各种描述，那么架构到底是指什么？系统、框架、架构三者之间是一个什么样的关系？下面让我们结合实际的例子一起来探究下。</p>
<h1 id="架构的含义"><a href="#架构的含义" class="headerlink" title="架构的含义"></a>架构的含义</h1><p>小石最近加入了一家生鲜电商公司。公司现在的首要任务是把电商系统给做出来，让用户能够通过PC、App购买公司的生鲜产品。</p>
<blockquote>
<p>关键词：<strong>系统</strong>，所谓系统可以简单理解为我们平时所说的应用，当然系统可以包含多个小系统，这里为了简单起见，我们就先假设只开发这样一个单体应用，包含了用户下单购买的基本功能。  </p>
</blockquote>
<p>小石通过分析其他电商系统，知道至少需要 <strong>用户注册登录模块</strong>、<strong>用户信息模块</strong>、<strong>商品模块</strong>、<strong>订单模块</strong> 系统才能够进行运转。</p>
<p>系统的功能确定了，该选择用什么样的语言进行开发呢？选择什么样的方式进行开发呢？与大家一起讨论后，大家认为现在阶段的首要目标是快速做出系统来，因此大家决定采用PHP来开发，并决定使用 <strong>Yii2</strong> 框架，数据库方面使用 MySQL，WebService使用Nginx。</p>
<blockquote>
<p>关键词：<strong>框架</strong>，为了快速完成系统的开发，我们会采用一些已被业内实践确认的规范来进行，比如这里采用 YII2 框架，也就是采用了业内的 MVC 规范。所以可以认为所谓的框架就是确定了一些业内规范，从某种程度上对大家形成约束或者形成都能理解的规定。  </p>
</blockquote>
<p>从开始到现在，还没有写一行代码，一直在进行设计与讨论，讨论需要哪些功能，设计采用什么 <strong>结构</strong>，而这里的结构主要包括了两方面：逻辑的结构与物理的结构。所谓逻辑结构就是指系统是按照什么样的流程来运转，需要哪些功能来支持。所谓物理，就是当编码完成所有的逻辑后，系统采用什么形式来部署运行。</p>
<p>那么到底什么是架构呢？我理解的架构：在系统诞生之初，对系统进行的逻辑设计与物理设计。他是系统的草图，可以类比为建筑领域的设计图。这张图需要确定：</p>
<ul>
<li>业务需要的功能模块划分（建筑设计需要划分区域功能）</li>
<li>技术选型，用什么框架、什么存储、什么缓存（建筑领域也要确认框架结构还是框剪结构）</li>
</ul>
<h1 id="架构是进化的"><a href="#架构是进化的" class="headerlink" title="架构是进化的"></a>架构是进化的</h1><p>一个架构的0.1版本绝对不会是完美的，世界上也不存在完美的架构。像上面的小故事，我们采用最简单的架构，如下图（物理角度）：<br><img src="http://ol59nqr1i.bkt.clouddn.com/jg2.jpeg" alt="架构"></p>
<p>我们把所有的功能写在一份代码里，所有的数据存在一个库里，所有的代码部署在同一个Nginx上，甚至还可能我们的Nginx、MySQL都部署在同一台机器上。</p>
<p>公司业务得以发展，人员得以增加，系统变得更加复杂。这个时候原来的架构，一无法满足业务快速发展，二无法让多人开发变得愉快。因为几十个人在同一份代码里进行编码，想一下都是头大。文件冲突、功能依赖、bug排查、测试功能，这些都无法愉快的解决。这时就得根据新的情况重新设计架构。</p>
<p>我们将代码功能进行拆分，将以前的模块拆分成独立的系统，将MySQL进行主从设计，利用Nginx做负载等等。</p>
<p>那么为什么不一上来就进行拆分呢？因为一开始人手不足，拆分过细，开发周期慢，业务也不需要如此细致的划分。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>架构是一个系统的草图（逻辑+物理角度），它是有生命的，随着业务的变化会不断演进。没有完美的架构只有合适的架构。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Go初始化变量的招式]]></title>
      <url>http://dayutalk.cn/2018/05/26/Go%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F%E7%9A%84%E6%8B%9B%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>乱立Flag害死人<br><a id="more"></a></p>
<p>年初的立的各种Flag，已经被我抛到九霄云外去了。2018年已经过去了一半，终于开始了第三篇文章，距离全年30篇的输出计划，仅剩27本，我很有“信心完成”剩下的部分。</p>
<p>2018年伊始，开始从PHP转到Go的开发方向，虽然说学习路线并不是非常陡峭，但是过程中遇到不少坑以及有意思的地方，忍不住想总结分享给大家。今天先来聊一聊Go中初始化变量的几种方式。</p>
<h1 id="Go中初始化值类型的招式"><a href="#Go中初始化值类型的招式" class="headerlink" title="Go中初始化值类型的招式"></a>Go中初始化值类型的招式</h1><p>Golang的数据类型可以分为：<strong>值类型</strong> 与 <strong>引用类型</strong>，我先来总结一下Go中值类型（以 <strong>string</strong> 为例）的初始化方式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"a1: %#v \n"</span>, a1) <span class="comment">// a1: ""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a2 *<span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"a2: %#v \n"</span>, a2) <span class="comment">// a2: (*string)(nil)</span></span><br><span class="line"><span class="comment">// panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line"><span class="comment">//fmt.Printf(**"a2: %#v \n"**, *a2)</span></span><br><span class="line"></span><br><span class="line">a3 := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line">fmt.Printf(<span class="string">"a3: %#v \n"</span>, a3) <span class="comment">// a3: (*string)(0xc42000e200)</span></span><br><span class="line">fmt.Printf(**<span class="string">"a3: %#v \n"</span>**, *a3) <span class="comment">// a3: ""</span></span><br><span class="line"></span><br><span class="line">a4 := <span class="string">"hello"</span></span><br><span class="line">fmt.Printf(<span class="string">"a4: %#v \n"</span>, a4) <span class="comment">// a4: "hello"</span></span><br><span class="line"></span><br><span class="line">a5 := <span class="keyword">string</span>(<span class="string">"hello"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"a5: %#v \n"</span>, a5) <span class="comment">// a5: "hello"</span></span><br><span class="line"></span><br><span class="line">a6 := &amp;a5</span><br><span class="line">fmt.Printf(<span class="string">"a6: %#v \n"</span>, a6) <span class="comment">// a6: (*string)(0xc42000e1e0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，cannot make type string</span></span><br><span class="line"><span class="comment">//a7 := make(string, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，cannot take the address of string("hello")</span></span><br><span class="line"><span class="comment">//a8 := &amp;string("hello")</span></span><br></pre></td></tr></table></figure></p>
<p>注释部分是输出的信息，可以看到有的结果打出来是个值，有的是一个指针。这一部分重点我只想说明两个点：</p>
<ol>
<li>Go会自动将申明变量初始化为0值，所谓的0值是：int就是0，string就是空字符，bool就是false等</li>
<li>对于通过new创建的变量，是一个指针，它与var声明的变量是不同的，var声明的变量仅是一个nil。而new(string) 为string分配一片内存，初始化为 0。通过上面注释的报错信息大家可以理解。</li>
</ol>
<h1 id="Go中初始化引用类型的招式"><a href="#Go中初始化引用类型的招式" class="headerlink" title="Go中初始化引用类型的招式"></a>Go中初始化引用类型的招式</h1><p>这是我想说的重点，Go中的引用类型仅有三种：::map:: ::slice:: ::channel::，这里举例就用slice来进行。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"s1: %#v\n"</span>, s1) <span class="comment">// s1: []string(nil)</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="string">"hello"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"s1: %#v\n"</span>, s1) <span class="comment">// s1: []string&#123;"hello"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 *[]<span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"s2: %#v\n"</span>, s2) <span class="comment">// s2: (*[]string)(nil)</span></span><br><span class="line"></span><br><span class="line">s3 := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"s3: %#v\n"</span>, s3) <span class="comment">// s3: []string&#123;"a", "b", "c"&#125;</span></span><br><span class="line"></span><br><span class="line">s4 := &amp;[]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"s4: %#v\n"</span>, s4) <span class="comment">// s4: &amp;[]string&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">s5 := &amp;s3</span><br><span class="line">fmt.Printf(<span class="string">"s5: %#v\n"</span>, s5) <span class="comment">// s5: &amp;[]string&#123;"a", "b", "c"&#125;</span></span><br><span class="line"></span><br><span class="line">s6 := <span class="built_in">new</span>([]<span class="keyword">string</span>)</span><br><span class="line">fmt.Printf(<span class="string">"s6: %#v\n"</span>, s6) <span class="comment">// s6: &amp;[]string(nil)</span></span><br><span class="line"><span class="comment">// first argument to append must be slice; have *[]string</span></span><br><span class="line"><span class="comment">//s6 = append(s6, "hello") // 这是一个空引用的指针，所以报错</span></span><br><span class="line"></span><br><span class="line">s7 := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"s7: %#v\n"</span>, s7) <span class="comment">// s7: []string&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有毛病才用这种方式</span></span><br><span class="line">s8 := <span class="built_in">new</span>([]<span class="keyword">string</span>)</span><br><span class="line">*s8 = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"s8: %#v\n"</span>, s8) <span class="comment">// s8: &amp;[]string&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">arr := [<span class="number">5</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">s9 := arr[:]</span><br><span class="line">fmt.Printf(<span class="string">"s9: %#v\n"</span>, s9) <span class="comment">// s9: []string&#123;"a", "b", "c", "", ""&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里我重点分析一下s6、s7、s8这三种初始化方式。先说s6，使用的是new。</p>
<blockquote>
<p>new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针<br>这里所谓的值为0，并不是数值0，而是go的默认0值，对应 ::slice:: 就是nil。</p>
</blockquote>
<p>在Go中绝对不会采用这种方式来初始化 ::slice:: 的，原因是为什么呢？我这里先简单说一下，是因为Go中::slice::是如下定义的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果用 new 因为返回的是 <em>T 的内存地址，无法完成对 ::slice::的初始化，无法让slice正常使用，想要让他可以正常使用，就得像s8的处理方式一样，再用make对应  </em>T 进行一次初始化。如果这么干，你说是不是有毛病才用的方式？</p>
<blockquote>
<p>slice 的初始化需要初始化 len、cap的值，让 array 指向一个数组的指针。完成这些初始化后，slice才能正常使用。  </p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于自定义结构的初始化与上面string的初始化一样，map、channel与slice一样。大家可以自己写点代码试试</p>
<ul>
<li>记住make只用于map，slice和channel，并且不返回指针。</li>
<li>要获得一个显式的指针，使用new进行分配，或者显式地使用一个变量的地址。</li>
</ul>
<p>接下来计划分享的内容：</p>
<ol>
<li>Go中值、引用、指针方面的知识，重点是函数参数的传参方式</li>
<li>Go中::slice::与::array::的亲密关系</li>
<li>Go中接口的知识，从::sort::的源代码角度来介绍</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Go语言中的Interface]]></title>
      <url>http://dayutalk.cn/2018/02/13/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84Interface/</url>
      <content type="html"><![CDATA[<p>interface大法好<br><a id="more"></a></p>
<p><strong>先给大家拜个早年：狗年旺旺旺</strong></p>
<p>最近在看Go语言的面向对象的知识点时，发现它的面向对象能力全靠 interface 撑着，而且它的 interface 还与我们以前知道的 interface 完全不同。故而整个过程不断的思考为什么要如此设计？这样设计给我们带来了什么影响？</p>
<h1 id="interface-我不懂你"><a href="#interface-我不懂你" class="headerlink" title="interface 我不懂你"></a>interface 我不懂你</h1><p>Rob Pike 曾说：</p>
<blockquote>
<p>如果只能选择一个Go语言的特 性移植到其他语言中，他会选择接口</p>
</blockquote>
<p>被Go语言设计者如此看重，想来 interface 一定是资质不凡，颜值爆表。但是说实话，当我第一次读这部分内容的时候，我产生了以下三个问题：</p>
<ol>
<li>原来的 <code>implement</code> 方式产生了什么问题，我用的不好好的吗？</li>
<li>如果不通过 <code>implement</code> 把接口与实现类强制关联起来，它怎么知道我实现的哪个接口？</li>
<li>这么干为实际编码带来了什么影响或者说好处？</li>
</ol>
<p>带着这些问题我进行了一些比较与分析，<code>Rob Pike</code> 如此说，不可能是想骗我们都去用 Go，毕竟大家都是上过小学的，骗不了你们。</p>
<h1 id="侵入式与非侵入式"><a href="#侵入式与非侵入式" class="headerlink" title="侵入式与非侵入式"></a>侵入式与非侵入式</h1><p>在诸多的资料中，大家都提到 <strong>侵入式</strong> 与 <strong>非侵入式</strong> 这样的概念，我用代码来解释下这两个概念。</p>
<p><strong>PHP 中的侵入式：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> $name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAge</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Go 中的非侵入式</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetAge() <span class="keyword">int</span></span><br><span class="line">	GetName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person= Student&#123;<span class="number">20</span>, <span class="string">"Elon"</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"This person name is"</span>, p.GetName())</span><br><span class="line">	fmt.Println(<span class="string">"This person age is"</span>, p.GetAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码我总结了以下问题：</p>
<ol>
<li>侵入式通过 <code>implements</code> 把实现类与具体接口绑定起来了，因此有了强耦合;</li>
<li>如果我修改了接口，比如改了接口方法，则实现类必须改动；</li>
<li>如果我希望实现类再实现一个接口，实现类也必须进行改动；</li>
<li>后续跟进者，必须了解相关的接口。</li>
</ol>
<p>这几个问题是开发中经常遇到的问题，而 Go 非侵入式的方式完美解决了这几个问题。他只要实现了与接口定义相同的方法，就算实现了某个接口，最重要的，随着代码的增加，你的类结构不会像 Java 那样发生爆炸。因为你根本不用关心你实现了什么接口，你只需要关心你的类有什么方法，方法有什么功能。在实现类的时候也不需要像 Java、PHP 一样引入各种接口，有可能你定义类的时候，某个接口还不存在，接下来我单独说说该方式的意义。</p>
<h1 id="interface-意义非凡"><a href="#interface-意义非凡" class="headerlink" title="interface 意义非凡"></a>interface 意义非凡</h1><p>在我没有理解之前，我觉得Go的接口很变扭，以前的码代码的思路都是：先设计好接口，再去做具体的实现。现在一个类你可能根本分不清他实现了那个接口。还是上面的例子，稍微改一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetAge() <span class="keyword">int</span></span><br><span class="line">	GetName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetAge() <span class="keyword">int</span></span><br><span class="line">	GetName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个接口 <code>Person</code>、<code>Car</code> 他们有相同的方法，而 <code>Student</code> 实现了这两个方法，在 Go 里边就可以说他同时实现了这两个接口，不信你试试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person= Student&#123;<span class="number">20</span>, <span class="string">"Elon"</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"This person name is"</span>, p.GetName())</span><br><span class="line">	fmt.Println(<span class="string">"This person age is"</span>, p.GetAge())</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> c Car= Student&#123;<span class="number">1</span>, <span class="string">"BMW"</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"This car name is"</span>, c.GetName())</span><br><span class="line">	fmt.Println(<span class="string">"This car age is"</span>, c.GetAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是为了说明问题，名字上看起来有点诡异(Student 竟然可以是车？上车就是上 Student？)</p>
<p>这种能力带来的真正让人吃惊的地方是什么？从此以后我可以先写类了，我先根据实际情况把类的功能做好，在某个我具体需要使用的地方，我再定义接口。说的专业点：也就是接口是由使用方根据自己真实需求来定义，并且不用关心是否有其它使用方定义过。</p>
<p>这样子到底解决了什么开发中的问题？举个例子：我们一个大团队在开发一个商城系统，m端、app端、pc端都有购物车的需求，底层根据不同的需求已经实现了一个Cart类，通过该类可以获取购物车价格、数量等。例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cart <span class="keyword">struct</span> &#123;</span><br><span class="line">	price <span class="keyword">float32</span></span><br><span class="line">	num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cart)</span> <span class="title">GetPrice</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cart)</span> <span class="title">GetNum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我觉得这才是真正做到了：<code>依赖于接口而不是实现，优先使用组合而不是继承</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP的引用，你知道多少]]></title>
      <url>http://dayutalk.cn/2017/12/15/PHP%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91/</url>
      <content type="html"><![CDATA[<p>除了学到引用知识，文末还给你带来了一家2018年上海最值得加入的公司。<br><a id="more"></a></p>
<p>真的是变懒了，一个月一篇的节凑都很难保证了。</p>
<p>最近面试他人的过程中，问了一些关于PHP引用的知识，发现很多同学对这方面知之甚少，还有很多工作中基本没有使用过。甚至有人告诉我要少用引用，引用会带来一些诡异的问题。我心里默默说，避免诡异的问题是要去理解引用而不是少用引用。今天一起来解析解析。</p>
<h1 id="场景假设"><a href="#场景假设" class="headerlink" title="场景假设"></a>场景假设</h1><p>先从一个引用的所谓诡异问题开始。假设我们有这个场景：我们从数据库中读取了一组订单数据，需要把订单的每条数据单独做些处理。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$list = [</span><br><span class="line">    [<span class="string">'orderid'</span> =&gt; <span class="string">'123'</span>, <span class="string">'total_fee'</span> =&gt; <span class="number">10</span>, <span class="string">'name'</span> =&gt; <span class="string">'zhangsan'</span>],</span><br><span class="line">    [<span class="string">'orderid'</span> =&gt; <span class="string">'456'</span>, <span class="string">'total_fee'</span> =&gt; <span class="number">17</span>, <span class="string">'name'</span> =&gt; <span class="string">'lisi'</span>],</span><br><span class="line">    [<span class="string">'orderid'</span> =&gt; <span class="string">'789'</span>, <span class="string">'total_fee'</span> =&gt; <span class="number">14</span>, <span class="string">'name'</span> =&gt; <span class="string">'wangwu'</span>],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> &amp;$item) &#123;</span><br><span class="line">    <span class="comment">// 对订单做了些什么处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了一些其它操作</span></span><br><span class="line"></span><br><span class="line">$result = [];<span class="comment">// 需要返回的结果</span></span><br><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> $item) &#123;<span class="comment">// 重新映射名字</span></span><br><span class="line">    $result[] = [</span><br><span class="line">        <span class="string">'order_id'</span> =&gt; $item[<span class="string">'orderid'</span>],</span><br><span class="line">        <span class="string">'amount'</span> =&gt; $item[<span class="string">'total_fee'</span>],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序会输出如下结果：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var_dump($result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="number">0</span>]=&gt;</span><br><span class="line">  <span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    [<span class="string">"order_id"</span>]=&gt;</span><br><span class="line">    string(<span class="number">3</span>) <span class="string">"123"</span></span><br><span class="line">    [<span class="string">"total_fee"</span>]=&gt;</span><br><span class="line">    int(<span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="number">1</span>]=&gt;</span><br><span class="line">  <span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    [<span class="string">"order_id"</span>]=&gt;</span><br><span class="line">    string(<span class="number">3</span>) <span class="string">"456"</span></span><br><span class="line">    [<span class="string">"total_fee"</span>]=&gt;</span><br><span class="line">    int(<span class="number">17</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="number">2</span>]=&gt;</span><br><span class="line">  <span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    [<span class="string">"order_id"</span>]=&gt;</span><br><span class="line">    string(<span class="number">3</span>) <span class="string">"456"</span></span><br><span class="line">    [<span class="string">"total_fee"</span>]=&gt;</span><br><span class="line">    int(<span class="number">17</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是经常遇到的一种所谓的诡异问题，先用引用循环处理数据，后面又用了与引用相同的临时变量继续处理数据。这里就是：<code>$item</code>。很多同学说预防这种问题，就要少用引用。这种态度太消极了，引用在很多地方带来了代码书写的简洁，并且针对大数组使用引用能够节省大量的内存。</p>
<h1 id="诡异问题解析"><a href="#诡异问题解析" class="headerlink" title="诡异问题解析"></a>诡异问题解析</h1><p>现在我们来分析下上面问题出现的原因。先来看引用的定义</p>
<blockquote>
<p>引用意味着用不同的名字访问同一个变量内容。</p>
</blockquote>
<p>那么在这部分代码中</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> &amp;$item) &#123;</span><br><span class="line">    <span class="comment">// 对订单做了些什么处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>$item</code> 最后跟 <code>$orders[2]</code> 指向了同一个变量内容。并且在 <code>foreach</code> 循环完后，<code>$item</code> 并没有被销毁，因此在后续如果同名的话，会继续生效。图示如下：<br><img src="http://ol59nqr1i.bkt.clouddn.com/1.jpeg" alt="image"></p>
<p>那么再接下来的的另一个循环中。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> $item) &#123;<span class="comment">// 重新映射名字</span></span><br><span class="line">    $result[] = [</span><br><span class="line">        <span class="string">'order_id'</span> =&gt; $item[<span class="string">'orderid'</span>],</span><br><span class="line">        <span class="string">'amount'</span> =&gt; $item[<span class="string">'total_fee'</span>],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每当 <code>$orders</code> 把变量赋值给 <code>$item</code> 的时候，都同时改变了 <code>$orders[2]</code> 的值。因此才会出现上面诡异的情况。我来逐步给大家演示下：</p>
<ul>
<li>第一次循环 <code>$orders[0]</code>，<code>$item</code> 指向 <code>orderid=123</code> 的订单，由于 <code>$item</code> 是 <code>$orders[2]</code> 的引用，此时导致 <code>$orders[2]</code> 也指向了 <code>orderid=123</code> 的订单；</li>
<li>第二次循环 <code>$orders[1]</code>, <code>$item</code> 指向 <code>orderid=456</code> 的订单，因此 <code>$orders[2]</code> 也指向了 <code>orderid=456</code>；</li>
<li>第三次循环 <code>$orders[2]</code>的时候，明显其值已经变成了 <code>orderid=456</code> 的订单。</li>
</ul>
<p>通过上面的分析，我相信大家对引用所谓的诡异有了了解。那么又该如何避免这种情况出现呢？其实很简单，每次使用完引用后，记得 <code>unset</code> 调引用。在后面便可毫无顾忌的继续使用了。具体到本例子就是：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> &amp;$item) &#123;</span><br><span class="line">    <span class="comment">// 对订单做了些什么处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unset</span>($item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了一些其它操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> $item) &#123;<span class="comment">// 重新映射名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="引用的妙用"><a href="#引用的妙用" class="headerlink" title="引用的妙用"></a>引用的妙用</h1><p>前面我说过，引用可以写出简洁的代码。无限级分类的使用便是一个使用场景。比如说我们有个分类的数据：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$catList = [</span><br><span class="line">    <span class="string">'1'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">1</span>, <span class="string">'name'</span> =&gt; <span class="string">'颜色'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">    <span class="string">'2'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">2</span>, <span class="string">'name'</span> =&gt; <span class="string">'规格'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">    <span class="string">'3'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">3</span>, <span class="string">'name'</span> =&gt; <span class="string">'白色'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">    <span class="string">'4'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">4</span>, <span class="string">'name'</span> =&gt; <span class="string">'黑色'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">    <span class="string">'5'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">5</span>, <span class="string">'name'</span> =&gt; <span class="string">'大'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">2</span>],</span><br><span class="line">    <span class="string">'6'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">6</span>, <span class="string">'name'</span> =&gt; <span class="string">'小'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">2</span>],</span><br><span class="line">    <span class="string">'7'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">7</span>, <span class="string">'name'</span> =&gt; <span class="string">'黄色'</span>, <span class="string">'parent_id'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>如果我想得到下面这种形式<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$result = [</span><br><span class="line">    [<span class="string">'id'</span> =&gt; <span class="number">1</span>, <span class="string">'name'</span> =&gt; <span class="string">'颜色'</span>, <span class="string">'children'</span> =&gt; [</span><br><span class="line">        [<span class="string">'id'</span> =&gt; <span class="number">3</span>, <span class="string">'name'</span> =&gt; <span class="string">'白色'</span>],</span><br><span class="line">        [<span class="string">'id'</span> =&gt; <span class="number">4</span>, <span class="string">'name'</span> =&gt; <span class="string">'黑色'</span>],</span><br><span class="line">        [<span class="string">'id'</span> =&gt; <span class="number">7</span>, <span class="string">'name'</span> =&gt; <span class="string">'黄色'</span>]</span><br><span class="line">    ]],</span><br><span class="line">    [<span class="string">'id'</span> =&gt; <span class="number">2</span>, <span class="string">'name'</span> =&gt; <span class="string">'规格'</span>, <span class="string">'children'</span> =&gt; [</span><br><span class="line">        [<span class="string">'id'</span> =&gt; <span class="number">5</span>, <span class="string">'name'</span> =&gt; <span class="string">'大'</span>],</span><br><span class="line">        [<span class="string">'id'</span> =&gt; <span class="number">6</span>, <span class="string">'name'</span> =&gt; <span class="string">'小'</span>]</span><br><span class="line">    ]]</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>如果使用引用，可以非常简单的得出结果。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$treeData = [];<span class="comment">// 保存结果</span></span><br><span class="line"><span class="keyword">foreach</span> ($catList <span class="keyword">as</span> $item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>($catList[$item[<span class="string">'parent_id'</span>]]) &amp;&amp; ! <span class="keyword">empty</span>($catList[$item[<span class="string">'parent_id'</span>]])) &#123;<span class="comment">// 肯定是子分类</span></span><br><span class="line">        $catList[$item[<span class="string">'parent_id'</span>]][<span class="string">'children'</span>][] = &amp;$catList[$item[<span class="string">'id'</span>]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 肯定是一级分类</span></span><br><span class="line">        $treeData[] = &amp;$catList[$item[<span class="string">'id'</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家可以试试不用引用的方式，把无限级实现出来试试，比较下代码。</p>
<hr>
<p>年底了。没钱给大家发红包，给大家推荐一家上海的好公司。为大家跳槽助力。<br><img src="http://ol59nqr1i.bkt.clouddn.com/yimishiji-1.jpg" alt="image"><br><img src="http://ol59nqr1i.bkt.clouddn.com/yimishiji-2.jpg" alt="image"></p>
<p>公司网站：<a href="https://www.yimishiji.com/" target="_blank" rel="external">https://www.yimishiji.com/</a></p>
<p>手机网站：<a href="https://m.yimishiji.com/" target="_blank" rel="external">https://m.yimishiji.com/</a></p>
<p>公司目前正在招聘高级PHP工程师，要求：</p>
<ul>
<li>2-5年的PHP开发经验；</li>
<li>本科学历；</li>
<li>至少熟悉Laravel、Yii2框架中的一种；</li>
<li>有电商、生鲜相关的经验加分；</li>
<li>有博客、GitHub的加分。</li>
</ul>
<p>待遇优厚：五险一金；每日内购零农残、有机食材水果；薪资15k-30k。</p>
<p>公司使用的是PHP7语法，对新技术是保持激进的态度。对于上海的小伙伴或者想去上海的小伙伴，强烈建议去看看。</p>
<ul>
<li>公司地址：上海市长宁区天山西路789号中山国际广场B座一米市集</li>
<li>CTO邮箱：alex.chang@yimishiji.com</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我想成为一个真的程序员]]></title>
      <url>http://dayutalk.cn/2017/10/25/%E6%88%91%E6%83%B3%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%9C%9F%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98/</url>
      <content type="html"><![CDATA[<p>是的，当了4年假程序员，我想要变成真的<br><a id="more"></a></p>
<p>最近看了 <code>左耳朵耗子</code> 写的一段话：</p>
<blockquote>
<p>所以，我和一些人开玩笑说，我们可能都是在写一样的 for(int i=0; i&lt;n; i++) 语句，但是，你写在那个地方一文不值，而我写在这个地方，这行代码就值 2000 元。不要误会，我只是想用这种“鲜明的方式”来加强我的观点。</p>
</blockquote>
<p>读到时，脑袋一阵晕眩。为了让你往后的日子不被嫌弃，现在自己必须抓紧时间沉下来。</p>
<p>编程时间越久，越觉得需要回头看，啃基础。写业务的时间再久，天花板的高度也不会被你撑高。</p>
<p>业务的编码，为我带来的一些成长是：如何更好的代码复用；如何将具体的业务进行拆分成代码模块；如何组织项目的结构，方便快速开发与维护；如何进行日常的运维；如何配置相关的系统、环境等等。</p>
<p>那么这些技巧学会之后，该如何往深入走？特别是当前云技术的发展，让很多基础的运维工作变得相当简单。如果仅仅是掌握了基础的编码工作，随着时间的增长，5年、10年程序员的竞争力如何体现？每当想起这些，不能不让人焦虑。</p>
<p>但是过份的焦虑，会让人丧失学习能力。我们需要在认识到自己局限的同时，脚踏实地的耕耘自己这一方水土。不要想着速成，现在知识付费很流行，但是你花钱买别人嚼过的东西，提高不了自己。问渠那得清如许？为有源头活水来。特别是做为程序员我觉得更应该自己去研究、去尝试、去思考。<br>社会并不会嫌弃变老变慢的程序员，而是会嫌弃哪些年龄变老了，技能却依然没有变化的人。</p>
<h1 id="程序员"><a href="#程序员" class="headerlink" title="程序员"></a>程序员</h1><p>当别人问我的职业时，我会骄傲的说：程序员。可是仔细想想感觉自己不是程序员。为什么？并不是仅仅因为月薪没上5万，而是：</p>
<blockquote>
<p>程序 = 数据结构 + 算法</p>
</blockquote>
<p>我在想我写的代码中，哪些包含了数据结构，哪些又包含了算法呢？都不好意思继续往下想了，我一定是个假的程序员。</p>
<p>为了让自己成为一个真正的程序员，不是薪水上而是能力上的。需要改变自己的学习、工作策略。多去学习需要不断练习与思考的技能，特别是需要思考的东西。因为大部分人不愿意思考，多思考一份就比别人多一份优势。将重复性的工作最大程度自动化，不要浪费自己宝贵的时间。</p>
<h1 id="学习，需要先找到目标"><a href="#学习，需要先找到目标" class="headerlink" title="学习，需要先找到目标"></a>学习，需要先找到目标</h1><p>学习需要具有目标性，要不然就是芝麻西瓜都在捡。当前很多公司都在强调全栈工程师，但是根据个人发现，真正的全栈一定是某个方面很牛，其它方面则比较平均。而很多公司要全栈的原因（特别是小公司），仅仅是为了要一个什么都能够做点的工程师，让你今天做做h5，明天搞搞小程序，后天再写个api。</p>
<p>上面的情况不会让你发展成为全栈，会让你发展成为三不像，没有自己的核心能力区。现在的技术不管是前端还是后端，都变得越来越细致，都需要投入大量的时间才可能成为专家。</p>
<p>你是想在某个领域成为专家，还是成为爱好者，会让结果千差万别。在开始前，先定位自己当前所处位置以及目标。找出二者之间的差距进行弥补。</p>
<p>我一边觉得庆幸自己在现在意识到了这一切，另一方面又对自己以前的种种无知表示后悔。知识应该由点极面的逐步展开。用php来讲，我肯定第一步是写好php代码，学好面向对象与设计模式，这一部分工作在业务阶段可以很好掌握，那么之后php相关的性能问题、扩展开发问题就需要逐步去深入了解，这就需要去学数据结构、算法、c语言等等知识。这是由php带来的深入方向，对于横向的，就需要去了解linux、mysql、nginx相关的知识点。这样一步步下来完成自己的深度与广度。</p>
<p><strong>好的知识与技能都不可能短时间学成。让自己变得具有专业性、稀缺性很重要。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[飞跃绝境长城]]></title>
      <url>http://dayutalk.cn/2017/09/13/%E9%A3%9E%E8%B7%83%E7%BB%9D%E5%A2%83%E9%95%BF%E5%9F%8E/</url>
      <content type="html"><![CDATA[<p>首发微信公众号，结果被删除了。所以博客还是得坚持<br><a id="more"></a></p>
<p>《冰与火之歌》中有一道绝境长成保护着七国子民。我们也有一道绝境长成，给我们打造良好健康的信息环境。</p>
<p>不过我们程序员想用github快一点，google查询资料全一点，怎么破？我今天将把走出绝境长成的地图交给你们。</p>
<blockquote>
<p>记得收藏保存，万一被删了呢。</p>
</blockquote>
<h1 id="免费方案"><a href="#免费方案" class="headerlink" title="免费方案"></a>免费方案</h1><p>用的最多的就是蓝灯，下载地址：<a href="https://github.com/getlantern/forum" target="_blank" rel="external">https://github.com/getlantern/forum</a></p>
<p>另外还有个集合大全：<a href="https://github.com/bannedbook/fanqiang/wiki" target="_blank" rel="external">https://github.com/bannedbook/fanqiang/wiki</a></p>
<p>下面开始我要开始进行openvpn的翻墙技术交流了，通过 openvpn 实现的穿越长城。</p>
<h1 id="OpenVPN"><a href="#OpenVPN" class="headerlink" title="OpenVPN"></a>OpenVPN</h1><blockquote>
<p>OpenVPN 是一个用于创建虚拟专用网络加密通道的软件包，最早由James Yonan编写。OpenVPN允许创建的VPN使用公开密钥、电子证书、或者用户名／密码来进行身份验证。</p>
<p>它大量使用了OpenSSL加密库中的SSLv3/TLSv1协议函数库。</p>
</blockquote>
<p>OpenVPN 实现翻墙的原理是它虚拟了一张网卡，客户端所有的请求通过这张网卡的包装进行重新的请求与接受。从而完成翻墙。下面来看具体的操作。</p>
<h2 id="安装-OpenVPN"><a href="#安装-OpenVPN" class="headerlink" title="安装 OpenVPN"></a>安装 OpenVPN</h2><p>为了详细说明每一个软件的安装原因，我将会按照依次顺序进行，每一个可能的错误尽可能展示。</p>
<p>安装的环境:</p>
<ul>
<li>CentOS: 6.8 64位</li>
<li>1核  1G内存</li>
<li>服务器位置：香港</li>
</ul>
<p><strong>下载：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://swupdate.openvpn.org/community/releases/openvpn-2.4.3.tar.gz</span><br></pre></td></tr></table></figure></p>
<p><strong>解压：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf openvpn-2.4.3.tar.gz &amp;&amp; cd openvpn-2.4.3</span><br></pre></td></tr></table></figure></p>
<p><strong>生成Makefile，为编译做准备：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/openvpn</span><br></pre></td></tr></table></figure></p>
<p>第一个报错：</p>
<blockquote>
<p>checking for SSL_CTX_new… no</p>
<p>configure: error: openssl check failed</p>
</blockquote>
<p><strong>错误原因：</strong> 没有 <code>openssl</code> 服务，安装： <code>yum install openssl openssl-devel -y</code></p>
<p>第二次执行： <code>./configure --prefix=/usr/local/openvpn</code></p>
<p>第二个报错：</p>
<blockquote>
<p>configure: error: lzo enabled but missing</p>
</blockquote>
<p>因为 openvpn 会用到 <code>lzo</code> 压缩算法。安装：<code>yum install lzo lzo-devel -y</code></p>
<p>第三次执行：<code>./configure --prefix=/usr/local/openvpn</code></p>
<p>第三个报错：</p>
<blockquote>
<p>configure: error: libpam required but missing</p>
</blockquote>
<p>根据提示安装 <code>yum install pam pam-devel -y</code></p>
<p>再次执行：<code>./configure --prefix=/usr/local/openvpn</code></p>
<p>成功运行，生成了编译需要的 Makefile，进行编译安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p><strong>备注：在安装 openall lzo pam 的时候，我们同时安装了 *-devel 包。该包是开发库，一般编译软件的时候都需要。大家也可以试试看不安装是否报错，报错的时候在装上去</strong></p>
<h2 id="加密证书生成"><a href="#加密证书生成" class="headerlink" title="加密证书生成"></a>加密证书生成</h2><p>为了确保数据交互的安全，在客户端与服务端交互时，需要进行加密，签名等操作。在进行这一步前我们需要生成供客户端、服务端使用的相关证书。证书生成工具 <code>easy-rsa</code></p>
<p><strong>准备工作</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/OpenVPN/easy-rsa.git</span><br><span class="line">cd /easy-rsa/easyrsa3/</span><br><span class="line">cp vars.example vars</span><br></pre></td></tr></table></figure></p>
<p>然后修改以下信息，主要是跟自己组织相关的信息，自己随意改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim vars</span><br><span class="line"></span><br><span class="line">// 这些组织信息，根据自己的实际情况进行修改</span><br><span class="line">set_var EASYRSA_REQ_COUNTRY     &quot;CN&quot;</span><br><span class="line">set_var EASYRSA_REQ_PROVINCE    &quot;Beijing&quot;</span><br><span class="line">set_var EASYRSA_REQ_CITY        &quot;Zhao Yang&quot;</span><br><span class="line">set_var EASYRSA_REQ_ORG &quot;Ai Zhong Guo&quot;</span><br><span class="line">set_var EASYRSA_REQ_EMAIL       &quot;foo@aiguo.com&quot;</span><br><span class="line">set_var EASYRSA_REQ_OU          &quot;aiguo Openvpn&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>创建 ca 证书</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa init-pki</span><br><span class="line">./easyrsa build-ca</span><br></pre></td></tr></table></figure></p>
<p>这个过程需要输入密码，与 ca 证书的名称； 请记住这个密码，后面签名服务端与客户端密钥的时候需要。<br>假设我这里是：</p>
<ul>
<li>名称: aiguoca</li>
<li>密码：123456</li>
</ul>
<p><strong>创建服务端证书</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa gen-req server-aiguo nopass</span><br></pre></td></tr></table></figure></p>
<p>又需要一个名字，不能跟之前的ca冲突: aiguoserver</p>
<p>对服务端证书签名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa sign server server-aliguo</span><br></pre></td></tr></table></figure></p>
<p>根据提示输入：<code>yes</code>  以及ca证书的密码：<code>123456</code></p>
<p><strong>创建Diffie-Hellman证书</strong></p>
<blockquote>
<p>该证书主要作用是确保共享KEY安全穿越不安全网络</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa gen-dh</span><br></pre></td></tr></table></figure>
<p>这一步时间有点久。可以倒杯水在过来继续</p>
<p><strong>创建客户端证书</strong><br>有的教程这里又 init 了一个 pki环境。其实完全没有必要。直接继续在原先的基础上继续即可。</p>
<p>跟着我的姿势继续往下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa gen-req client-aiguo nopass</span><br></pre></td></tr></table></figure></p>
<p>客户端创建证书的命令是不是跟服务端创建命令很像？仅仅是取了个不同名字。当然名字还是不要跟上面用过的名字冲突就好: aiguoclient</p>
<p>紧接着对它签名，步骤跟服务端一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa sign client client-ssl</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意呃,签名的 sign 后面 server 换成了 client 。也正是基于此，才能够知晓那个是服务端证书，那个是客户端证书。签名过程中还是需要输入 <code>yes</code> 以及ca证书的密码 <code>123456</code>。</p>
<p>至此证书生成完毕。现在开始相关配置。</p>
<h1 id="OpenVPN-服务端配置"><a href="#OpenVPN-服务端配置" class="headerlink" title="OpenVPN 服务端配置"></a>OpenVPN 服务端配置</h1><p>准备工作已经搞定，现在来做服务端的配置，以及让他运行起来。</p>
<p>由于我们是通过编译安装的，在 /etc/ 下面并没有 openvpn 这个目录。手动创建该目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/openvpn/</span><br></pre></td></tr></table></figure></p>
<p>拷贝 <code>openvpn</code> 提供的样板配置文件进去<br><code>cp sample-config-files/server.conf /etc/openvpn/</code></p>
<p>然后把服务端需要的证书，也全部拷贝进去<br><code>cp pki/ca.crt pki/issued/server-aiguo.crt pki/private/server-aiguo.key pki/dh.pemy /etc/openvpn/</code><br>这里千万不要选错了目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ll /etc/openvpn/ </span><br><span class="line"></span><br><span class="line"># 完成后，该目录有以下文件</span><br><span class="line">-rw------- 1 root root  1159 Sep  7 13:27 ca.crt</span><br><span class="line">-rw-r--r-- 1 root root 10782 Sep  7 13:25 server.conf</span><br><span class="line">-rw------- 1 root root  4547 Sep  7 13:27 server-aiguo.crt</span><br><span class="line">-rw------- 1 root root  1708 Sep  7 13:27 server-aiguo.key</span><br></pre></td></tr></table></figure>
<p><strong>server.conf 文件的配置</strong></p>
<p>该文件配置项含义中文翻译，看这里： <a href="https://my.oschina.net/liucao/blog/863112" target="_blank" rel="external">https://my.oschina.net/liucao/blog/863112</a></p>
<p>这里只讲诉几个关键配置。其他未说明的默认即可。<br>首先修改协议，建议使用 <code>tcp</code> 协议。网络上讲 <code>udp</code> 在高延时的情况下会存在很多丢包现象。</p>
<p>配置证书路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ca /etc/openvpn/ca.crt</span><br><span class="line">cert /etc/openvpn/server-ssl.crt</span><br><span class="line">key /etc/openvpn/server-ssl.key</span><br><span class="line">dh /etc/openvpn/dh.pem</span><br></pre></td></tr></table></figure></p>
<p>这里的文件路径，自己根据实际情况调整</p>
<p>注释掉： ;tls-auth ta.key 0 。因为我们并没有生存该key文件。</p>
<p>打开 comp-lzo 压缩</p>
<p>日志开启到 verb 6 ，方便后续调试</p>
<p>;explicit-exit-notify 1  注释掉，仅有 udp 才可使用</p>
<p>设置dns<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push &quot;dhcp-option DNS 8.8.8.8&quot;</span><br><span class="line">push &quot;dhcp-option DNS 8.8.4.4&quot;</span><br></pre></td></tr></table></figure></p>
<p>打开 <code>duplicate-cn</code> 项，默认是关闭状态。</p>
<p>注释 <code>explicit-exit-notify 1</code> 默认是关闭。</p>
<p>到这一步，配置全部完成。保存退出。</p>
<p><strong>启动服务端</strong></p>
<p>先检查一下，可以在前台运行 openvpn 服务，检查错误以及调试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/openvpn/sbin/openvpn --config /etc/openvpn/server.conf</span><br></pre></td></tr></table></figure></p>
<p>以守护进行运行的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/openvpn/sbin/openvpn --daemon --config /etc/openvpn/server.conf</span><br></pre></td></tr></table></figure></p>
<p>这里两个命令的使用，是因为以下原因：</p>
<ul>
<li>本教程安装路径是 /usr/local/openvpn</li>
<li>本教程配置都是放在 /etc/openvpn 中。</li>
</ul>
<p>情况不同者，根据实际情况设置即可</p>
<h1 id="防火墙与路由转发"><a href="#防火墙与路由转发" class="headerlink" title="防火墙与路由转发"></a>防火墙与路由转发</h1><p><strong>！！！如果你用的是 CentOS7 以上的操作系统，下面部分不适合你</strong></p>
<p>首先关闭SELinux：<code>SELINUX=disabled</code></p>
<p>配置防火墙，准许 <code>1194</code> 端口通过，如果你修改了默认端口，这里记得修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 1194 -m comment --comment &quot;openvpn&quot; -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>允许vpn客户端所在网段流量转发到其它网卡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I FORWARD -s 10.8.0.0/24 -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>将 vpn 流量转到eth0网卡上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j  MASQUERADE</span><br></pre></td></tr></table></figure></p>
<p>保存配置结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/iptables save</span><br></pre></td></tr></table></figure></p>
<p>开启路由转发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &apos;/net.ipv4.ip_forward/s/0/1/&apos; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>sysctl -p 是查看修改后的结果，如果你看到 net.ipv4.ip_forward = 1 ，说明配置正确</p>
</blockquote>
<p>至此，服务器上的事情，全部搞定。下面列举一个android手机客户端的配置。其它端也是大同小异。</p>
<h1 id="客户端-Android-的配置"><a href="#客户端-Android-的配置" class="headerlink" title="客户端 Android 的配置"></a>客户端 Android 的配置</h1><p>当我们有了服务端，它已经可以进行工作了，如果再有一个客户端，那就能够天下我有了。这里就仅以android为代表说明一下客户端配置，其它端大同小异。</p>
<p><strong>下载开源的android客户端</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://f-droid.org/repo/de.blinkt.openvpn_153.apk</span><br></pre></td></tr></table></figure></p>
<p>客户端的主要作用，就是用来连接上我们的服务器。</p>
<p>将服务器上面的客户端证书拷贝到本地，我选用的是scp。任何能够完成该项任务的手段都可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp root@192.168.11.11:/home/easy-rsa/easyrsa3/pki/private/client-aiguo.key ./</span><br><span class="line">scp root@192.168.11.11:/home/easy-rsa/easyrsa3/pki/issued/client-aiguo.key ./</span><br><span class="line">scp root@192.168.11.11:/home/easy-rsa/easyrsa3/pki/ca.crt ./</span><br></pre></td></tr></table></figure></p>
<p>唯一需要注意的是，不要搞错了文件路径，这个路径根据每个人设置是不同的，不要完全进行拷贝。</p>
<p>在完成上面步骤后，可以通过qq或者手机助手之类的，将文件发送到自己的手机，请记得文件路径位置。下面会用到。</p>
<p>打开客户端app，新建一个配置文件。名字任意取（最好别用中文）。下面开始说需要配置的项目，未提到的项目默认即可，不需要设置。</p>
<h2 id="BASIC-项目配置"><a href="#BASIC-项目配置" class="headerlink" title="BASIC 项目配置"></a>BASIC 项目配置</h2><p><img src="http://ol59nqr1i.bkt.clouddn.com/vpn-basic.png" alt="image"></p>
<p>注意图中标红的地方。类型一定要选择 <strong>用户名／密码 + 证书</strong> 的类型。</p>
<ul>
<li>ca证书 找到刚刚拷贝到手机上的 <code>ca.crt</code> 文件</li>
<li>客户端证书 找到刚刚拷贝到手机上的 <code>client-aiguo.crt</code> 文件</li>
<li>客户端证书密钥 找到刚刚拷贝到手机上的 <code>client-aiguo.crt</code> 文件</li>
</ul>
<p>另外，这里一定要启用 lzo 压缩算法。</p>
<p>在底部的用户与密钥。用户随便填写接口，密码留空（在本教程中，我们没有为用户分配用户名与密码，因此可以这样操作）</p>
<h2 id="服务器列表-项目配置"><a href="#服务器列表-项目配置" class="headerlink" title="服务器列表 项目配置"></a>服务器列表 项目配置</h2><p><img src="http://ol59nqr1i.bkt.clouddn.com/vpn-serlist.png" alt="image"></p>
<p>这一比较简单，主要就是两个配置。其一是：<br>服务器的地址，填写你购买的服务器外网地址。端口如果没有修改过，请默认</p>
<p>其二是将协议修改为：tcp</p>
<h2 id="AUTHENTICATION-ENCRYPTION-项目配置"><a href="#AUTHENTICATION-ENCRYPTION-项目配置" class="headerlink" title="AUTHENTICATION/ENCRYPTION 项目配置"></a>AUTHENTICATION/ENCRYPTION 项目配置</h2><p>该项配置很简单，将默认所有打勾的选项，全部取消即可。</p>
<hr>
<p>至此，配置全部完成，篇幅虽然长，但是并没有什么难点。现在可以回到首页，你会看到刚配置的文件名称，点击它即可连接。</p>
<p>本教程的目的仅仅是技术交流，希望大家翻跃长城后技术实力更上一层楼。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP中static与yield关键字的思考]]></title>
      <url>http://dayutalk.cn/2017/09/10/PHP%E4%B8%ADstatic%E4%B8%8Eyield%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>语言的本身，远远重要于其它。<br><a id="more"></a></p>
<p>你以为你知道了一切，只是你以为而已。知识的美妙就在于，一生的时光在它面前显得多么的短暂。</p>
<p>嗯嗯，扯远了，我今天只想说说：<strong>static</strong> 与 <strong>yield</strong>。</p>
<p>先来说说 <code>static</code> 关键字。本篇只讲静态方法的使用与后期绑定的知识点。</p>
<h1 id="static-什么时候用来修饰方法"><a href="#static-什么时候用来修饰方法" class="headerlink" title="static 什么时候用来修饰方法"></a>static 什么时候用来修饰方法</h1><p><code>static</code> 关键字大家都知道是用来修饰方法与属性的。 那么大家在项目中会在哪些场景下使用它？</p>
<p>我遇到过几个项目，要求所有的方法全部 <code>static</code> 化，当然控制器方法不能这么干。原因之一就是：静态方法执行效率高？那么我们基于此来分析一下。</p>
<p>首先执行效率高我是没有意见的。哪么是不是因为它效率高，就该毫无节制的使用在项目中？讨论这个问题先来回顾下编程语言的历史。在早一点的时候，还没有面向对象，采用的都是结构化编程，当时基本上所有的方法都是 <strong>静态方法</strong>，然后有了面向对象，产生了实例化的概念。</p>
<p>从上面简短的发展过程可以看出，如果仅仅为了性能，哪么面向对象好像没有存在的必要。那么这些大师为了要在 <code>c++</code> <code>java</code> 这些语言中引入面向对象、引入实例化的感念呢？我觉得是因为伴随发展，项目越来越大，需要更好的组织代码方式与编程思维。</p>
<p>再回过头来看 <code>static</code> ，它定义的静态方法，效率确实高，但是会持续占用内存，只有在程序退出时才结束生命周期，期间无法进行销毁等副作用是其一；其二从设计模式上来说，它具有强耦合性，外部可修改 static 属性；其三static定义的方法没有办法override来重写，ioc di等概念无用武之地；其四在进行单元测试时，静态方法让人头痛。</p>
<p>那么通过上面所说，感觉以后还是别用 <strong>static</strong> 方法了，老老实实的实例化然后调用方法？咱们得理性，不能极端到什么地方都用，也不能一丁点都不用。一句话：学会面向对象的方式来思考。我们写代码的第一考虑点我觉得是：可扩展性（应对业务快速变化），可维护性（线上问题及时修复）。高效率应该是最后再来考虑（因为优化效率的手段非常之多，并不一定非要给每个方法加个: static）。如果从面向对象的角度出发，这个方法完全独立跟类属性无关，那么就用 <strong>static</strong> 吧。</p>
<p>总之是站在面向对象的角度，软件设计的层次来考虑语法的使用，而不是为了效率破坏掉代码的美。</p>
<h1 id="static-后期静态绑定"><a href="#static-后期静态绑定" class="headerlink" title="static 后期静态绑定"></a>static 后期静态绑定</h1><p>这一点php的文档做了详细的介绍，但是我以前一直很少关注这个地方，基本上都是使用 <code>self::</code> 的方式进行静态方法与属性的调用。</p>
<p>我觉得后期绑定某种程度上，像是静态方法的重载。这里贴出 php 文档中的例子来进行一下讲述<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>::who();</span><br><span class="line">        <span class="keyword">static</span>::who();<span class="comment">// 后期静态绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test();</span><br></pre></td></tr></table></figure></p>
<p>如果是 <code>self::who()</code> 调用，会输出：<strong>A</strong>。如果是 <code>static::who()</code> 会输出 <strong>B</strong></p>
<p>这样来看，是不是相当于 class B重写了父类 A 的 <code>who()</code> 方法？那么如果灵活使用这个特性，可以让 static 具备更强的灵活性。充分发挥其性能优势，又能解决扩展性差的问题。当然还是一样，要从面向对象的角度出发，一切适可而止。</p>
<h1 id="PHP-中-yield-的使用场景"><a href="#PHP-中-yield-的使用场景" class="headerlink" title="PHP 中 yield 的使用场景"></a>PHP 中 yield 的使用场景</h1><p>说实话，很长一段时间我并不知道 <code>php</code> 还有这么个语法。直到有一天我在 js 中遇到了这个关键字，感觉这么不明觉厉的东西，世界上最好的语言怎么没有？回头看文档，真有，不愧为世界上最好的语言。</p>
<p>那么 <strong>yield</strong> 的使用场景是什么？刚好最近有人 sg 上面问道我，借此整理一下。希望大家能够将它更多的结合自己的业务进行使用。这里不会进行 <code>yield</code> 与 <code>Iterator</code> 的比较。相信看完后，你能够明了二者的谁更简介。</p>
<p>先说它的使用场景，还是得先回顾历史，在没有 yield 之前，我们要生成一个数组，只能一次性把所有内容全部读入内存（当然也可以通过实现 <code>Iterator</code>接口实现一个迭代）。有了 <code>yield</code> 之后，我们可以通过一个简单的 <code>yield</code> 关键字，完成一个数组的生成，并且是用到的时候才会产生值，相对而言内存占用肯定会下降。空口无凭，咱们下面通过代码实际检验一下上面的结论。</p>
<p><strong>先来看普通模式</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateData</span><span class="params">($max)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    $arr = [];</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt;= $max; $i++) &#123;</span><br><span class="line">        $arr[] = $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'开始前内存占用：'</span> . memory_get_usage() . PHP_EOL;</span><br><span class="line">$data = generateData(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'生成完数组后内存占用：'</span> . memory_get_usage() . PHP_EOL;</span><br><span class="line"><span class="keyword">unset</span>($data);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'释放后的内存占用：'</span> . memory_get_usage() . PHP_EOL;</span><br></pre></td></tr></table></figure></p>
<p>运行得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始前内存占用：231528</span><br><span class="line">生成完数组后内存占用：231712</span><br><span class="line">释放后的内存占用：231576</span><br></pre></td></tr></table></figure></p>
<p>前后的差值是：<strong>184</strong></p>
<hr>
<p><strong>使用yield后的效果</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateData</span><span class="params">($max)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt;= $max; $i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> $i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'开始前内存占用：'</span> . memory_get_usage() . PHP_EOL;</span><br><span class="line">$data = generateData(<span class="number">100000</span>);<span class="comment">// 这里实际上得到的是一个迭代器</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'生成完数组后内存占用：'</span> . memory_get_usage() . PHP_EOL;</span><br><span class="line"><span class="keyword">unset</span>($data);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'释放后的内存占用：'</span> . memory_get_usage() . PHP_EOL;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始前内存占用：228968</span><br><span class="line">生成完数组后内存占用：229824</span><br><span class="line">释放后的内存占用：229016</span><br></pre></td></tr></table></figure></p>
<p>前后的差值是：<strong>856</strong></p>
<p>奇怪，使用了 <strong>yield</strong> 后，内存占用反而上升了，这是什么鬼？别急。上面我们参数传入的是 <strong>1,000,00</strong>，我现在将传入参数改成改成 <strong>1,000,000</strong>试试。</p>
<p>第一个方法得到的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始前内存占用：231528</span><br><span class="line"></span><br><span class="line">Fatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 32 bytes) in /test/yield.php on line 6</span><br></pre></td></tr></table></figure></p>
<p>看了吧，一百万次的循环时，一次性载入内存，超出了限制。那么再来看 yield 的执行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始前内存占用：228968</span><br><span class="line">生成完数组后内存占用：229824</span><br><span class="line">释放后的内存占用：229016</span><br></pre></td></tr></table></figure></p>
<p>前后的差值依然是：<strong>856</strong></p>
<p>好了到这里，应该看出来了，<strong>yield</strong>无论数组大小，占用均是 <strong>856</strong> ，这是因为它自身，它在你进行迭代的时候才会产生真实数据。</p>
<p>所以如果你的数据来源非常大，那么用 yield 吧。如果数据来源很小，当然选择一次载入内存。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Web开发中说高并发的时候，我们在说什么]]></title>
      <url>http://dayutalk.cn/2017/08/25/Web%E5%BC%80%E5%8F%91%E4%B8%AD%E8%AF%B4%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<p>概念背后的实质，才值得我们真正去畅谈与思考。<br><a id="more"></a></p>
<p>这并不是一个回答的问题的文章，而是由此引发的一个思考。</p>
<p><strong>大家心里仔细想想，当你们听到高并发网站时，心里对这个网站是个什么概念？首先想到的是淘宝吗？带着问题，我们一起思考技术</strong></p>
<p>写这个话题是因为我对搜索引擎给我的答案很不满意，然后决定把思考的一些东西分享出来，希望可以大家彼此讨论下。</p>
<p>我们经常在面试的时候，被问到有没有高并发的经验？先不说哪些考高并发的公司（我觉得很多时候是面试官想装逼）。我思考的是什么才算是高并发？你一天几个pv肯定高不了。首先在网上查找一下，并未找到明确的标准定义。那么什么是并发呢？</p>
<blockquote>
<p>并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p>
</blockquote>
<p><em>摘自百度百科</em></p>
<h1 id="我们说的高并发是什么？"><a href="#我们说的高并发是什么？" class="headerlink" title="我们说的高并发是什么？"></a>我们说的高并发是什么？</h1><p>上面的定义明显不是我们通常所言的并发，在互联网时代，所讲的并发、高并发，通常是指并发访问。也就是在某个时间点，有多少个访问同时到来。</p>
<p>我看到有人给高并发下了类似的定义：</p>
<blockquote>
<p>高并发通常是指我们提供的系统服务能够同时并行处理很多请求。</p>
</blockquote>
<p>来看看这个定义，这里首先把并发给混淆到并行了。关于<a href="https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/" target="_blank" rel="external">并发并行的区别看这里</a>，我就不多说，继续探讨并发。</p>
<p>然后定义又说很多请求？什么叫很多请求？做为中国人，这个词让我想象力一发不可收拾……好了，拉回来，继续本文。</p>
<p>那么从上面的分析，可以看出来高并发在网络上业界也没有明确的定义。但根据我搜索情况，一般都是pv在千万级别以上的公司才会涉及到这个概念。所以我得出一个自定义概念：如果某个系统的日pv在千万级别以上，他就可能是一个高并发的系统。</p>
<p>为什么说是可能？那是因为有的公司完全不走技术路线，全靠机器堆，这不在我们的讨论范围。</p>
<h1 id="高并发的问题，我们具体该关心什么？"><a href="#高并发的问题，我们具体该关心什么？" class="headerlink" title="高并发的问题，我们具体该关心什么？"></a>高并发的问题，我们具体该关心什么？</h1><p>讲真话，高并发是个比较抽象的概念。很难有一个统一的可衡量的标准。哪么有一些其它维度的标准指标来衡量系统的性能吗？搬出以前计算机课程里边的一些指标来跟大家聊聊。</p>
<p>先声明几个概念，别打瞌睡。</p>
<ul>
<li>QPS（TPS）：每秒钟 request/事务 数量，在互联网领域，指每秒响应请求数（指http请求）；</li>
<li>吞吐量：单位时间内处理的请求数量（通常由QPS与并发数决定）；</li>
<li>响应时间：系统对一个请求做出响应的平均时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间（我认为这里应该仅包含处理时间，网络传输时间忽略）。</li>
</ul>
<p><strong>这里一定要注意呃，QPS ≠ 并发数</strong></p>
<p>并发是指，某个时刻有多少个访问同时到来。QPS是指秒钟响应的请求数量。那么这里就肯容易推算出一个公式：</p>
<p>QPS = 并发数 / 平均响应时间</p>
<p>后面我们的分析都是围绕这个公示来进行展开，没明白的再回味一下。</p>
<p>现在我们来假设一个场景：既然QPS是每秒钟处理的http请求数量。那么1s = 1000ms。假设我们当前一个http请求服务器处理完成需要100ms（即那么 <strong>平均响应时间 = 100ms </strong>）。那么它1s钟可以处理10个请求。也就是说 <strong>qps = 10</strong>。推算出 <strong>并发数 = 10</strong></p>
<p>常常我们被问到高并发的问题，其实从某种程度上来说是怎么提高现有程序的性能。现在我们基于上面的假设，来进行分析。假设现在有个系统性能上就是我们上面的假设，它每天有 300万pv，运行在单机上（当然经常宕机），按照上面的系统性能数据，给出优化解决方案。</p>
<h1 id="提高并发能力"><a href="#提高并发能力" class="headerlink" title="提高并发能力"></a>提高并发能力</h1><p>通过上面的分析，要提升并发能力，我们就需要提升我们的qps（<em>其实这里并不完全正确，为了说明问题，我们先放弃一部分正确性</em>）</p>
<p>最快速解决方案，就是增加机器。我们根据以上情况来实际计算一下。</p>
<ul>
<li>访问量：200w pv</li>
<li>QPS：10</li>
</ul>
<p>根据日常经验，80% 的访问量集中在 20%的时间，算一下这 200w pv实际需要机器达到多少qps才能满足。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qps = (200w * 0.8) / (24 * 3600 * 0.3)</span><br><span class="line"></span><br><span class="line">qps = 61.7</span><br></pre></td></tr></table></figure>
<p>实际上如果在单机上，要求我们每秒钟处理请求必须达到 61.7 以上才行，而实际上我们当前系统的qps是 <code>10</code>。那么怎么解决？</p>
<p><strong>方案一：上机器</strong></p>
<p>个人的能力是有限的，团队的力量是无穷的。既然一台机器搞不定，我们就多上几台机器。这就涉及到db主从、读写分离、负载均衡等技术。</p>
<p>它的原理就是分流，把以前集中的压力分散开来。改方案见效快，灵活，实践起来也更快。</p>
<p><strong>方案二：增加单机性能</strong></p>
<p>单机到底性能能够增加到一个什么程度，这取决于你的机器配置，也取决于你的服务到底有多复杂。</p>
<blockquote>
<p>ps： 写到这里突然有点能够理解为什网上对高并发都是讲很多请求，没有具体数据了，因为这真的只能针对业务来讲，100个并发对静态网页来说根本没有的事儿，但是对于某些密集计算型的估计…</p>
</blockquote>
<p>那么常见的单机如何提升性能？比如：增加不常变化数据的缓存，开启php的opcache，优化代码（如：n+1问题、多重嵌套循环、深层递归等），db表优化等等。由于这些每一个点拿出来都够写一本书了。咋就不继续下去。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于笔者自己也是没有实际经历过kw级别pv场景，很多东西讲的不一定对，本文也是理清自己的一点思路。希望能够与更多朋友进行讨论。</p>
<p>也希望本文能够解决你的一点疑惑，让我们能够从高大上的概念落实到实际问题中去。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/" target="_blank" rel="external">并发和并行的区别</a></li>
<li><a href="http://www.ha97.com/5095.html" target="_blank" rel="external">系统性能测试想个概念</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP后端该如何组织项目结构]]></title>
      <url>http://dayutalk.cn/2017/08/07/PHP%E5%90%8E%E7%AB%AF%E8%AF%A5%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>全栈系列后端项目结构的思考，不夸夸其谈，只想写好代码。<br><a id="more"></a></p>
<p>这是 <strong>后端开发者从零做一个移动应用</strong> 的后端部分第二篇。介绍下一个新项目，后端该如何从零去搭建。我们先假设这个项目由两部组成</p>
<ul>
<li>提供给wap站点、app使用的api；</li>
<li>提供给运营人员使用的管理后台。</li>
</ul>
<p>整个项目采用 Phalcon，项目的demo可以 <a href="https://github.com/helei112g/x-api" target="_blank" rel="external">点这里</a> 参阅</p>
<p><em>备注：跟随文章进度，项目持续更新，最后会与配套的wap app形成一个整体</em></p>
<p>项目最终至少会包含以下内容：</p>
<ul>
<li>小米消息推送</li>
<li>支付集成（支付宝、招商、微信）</li>
<li>基于 Codeception 的api测试</li>
<li>登陆api（这部分采用oauth2，会基于 ‘bshaffer/oauth2-server-php’ 做）</li>
</ul>
<h1 id="项目结构回顾"><a href="#项目结构回顾" class="headerlink" title="项目结构回顾"></a>项目结构回顾</h1><p>后端系统一般都是采用 MVC 结构（这里均以PHP为例），M 代表模型，V 代表视图，C 代表控制器。我在啰嗦几句</p>
<blockquote>
<p>Model指的是数据模型，这个数据模型包括你的Mysql中的表结构，或者redis的缓存对象结构都可以。它代表一个数据操作单元。</p>
<p>View指的展示给用户浏览、直接操作的界面，这个大家都懂，不多说</p>
<p>Controller 控制器，主要是为了隔离 View 与 Model 直接打交道，他做为一个中间人，两头传递小纸条。</p>
</blockquote>
<p>在我过往的项目中，我主要的困惑在于，业务逻辑是放在 C 还是放在 M。</p>
<p>从对象角度出发，业务逻辑无非就是操作数据，要么读取，要么修改，那么应该放在M层，因为一个对象应该有自己的属性与方法。</p>
<h2 id="业务放在M中"><a href="#业务放在M中" class="headerlink" title="业务放在M中"></a>业务放在M中</h2><p>实际工作中我们常常有这样的场景，比如：读取一个游戏列表数据，数据包括游戏的详情以及游戏的版本信息以及下载信息。因为游戏app会存在升级，因此一个游戏会对应多个包。那么这里至少存在两个model</p>
<ul>
<li>游戏详情model，包括游戏的名称，logo等基本信息</li>
<li>游戏的包信息model，包括包所属平台，大小，下载地址，版本信息等</li>
</ul>
<p>那么这个动作的方法应该封装在哪里呢？以前的做法是，分别封装对应的操作到对应的model，然后在控制器中分别调用。说回到这里，游戏model封装了查询游戏列表的method，然后包model封装了根据游戏id查询包信息的method。</p>
<p>然后我们在控制器中分别调用这个两个方法，然后再进行组装，把游戏对应的包设置到对应的游戏中。</p>
<p>那么有一个问题，假设我们在游戏详情这个控制器方法中，需要返回一个相关游戏的集合，难道又重复一次上面的操作？<br><em>有人会说把处理游戏部分抽离成一个公共方法，那么假设是要在新闻详情里边调用呢？这根本不该在同一个控制器里边啊！</em></p>
<h2 id="业务放在C中"><a href="#业务放在C中" class="headerlink" title="业务放在C中"></a>业务放在C中</h2><p>上面我们把方法放在model中遇到了复用的小麻烦，那么继续看看放到controller中会怎样？</p>
<p>这个时候的一个好处是：我们可以使用连接查询，将刚刚的2次查询，通过连接查询1次完成，对于mysql的时间减少了，程序性能提升，然后对查询结果啪啪啪处理完成。</p>
<p>好吧，不往后面说了，相信大家已经发现了，这个查询过程还是不可复用。自然而然的，我们这里应该想到，将它提炼成一个方法，无法满足其他控制器使用（一个控制器调用另外一个控制器的想法想都别想啊）。那么只能提炼成一个类了，这个类来封装所有的业务。</p>
<p>这样之后，任何需要游戏列表数据的地方，直接调用这个GameServer（假设封装的业务逻辑都放在xxxServer中）就可以获得相同的数据，然后如果业务变动，我们也只需要改动这一处，所有地方得到的数据也将会是一致的。</p>
<p>因此通过回顾，我们得出我们的后端项目需要一个server的层次，来存放业务逻辑。</p>
<h2 id="Server层存在的意义"><a href="#Server层存在的意义" class="headerlink" title="Server层存在的意义"></a>Server层存在的意义</h2><p>分离出来的这一层，集中涵盖了所有的业务功能，极大的提高了代码的复用性，除了不同控制器不同方法的直接使用，还包括了不同模块之间的复用。</p>
<p>但是在不同模块之前服用，server层也需要考虑一些额外的东西，比如我们有一个app api模块，有一个后台管理模块。那么都是获取列表数据，可能给app api模块可能不需要某些字段，但是后台管理需要知悉全部内容，以及后台用户权限上的一些问题。这些部分可以继续进行拆分，与server组合。需要结合自己的业务来进行管理。</p>
<p>我个人实践过程中代码的另外一个好处是，server层从某种层度上让C层变得简单，这让团队中的新人能够快速上手接触代码。比如小明是团队新人，那么在他熟悉所使用框架的前提下，他可以立刻在C层开始做事情，因为这里没有业务，有的只是验证客户端传过来的数据，以及对server层的调用返回。通过这个过程可以加速其融入团队的进程。</p>
<h1 id="统一的返回格式"><a href="#统一的返回格式" class="headerlink" title="统一的返回格式"></a>统一的返回格式</h1><p>约定api返回的数据格式，这基本上是系统开发开始的第一步，原先常用的方式就是在每个控制器中通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">return json_encode([</span><br><span class="line">    &apos;msg&apos; =&gt; &apos;ok&apos;,// 携带的信息，可以用来前端 alert 提示用户</span><br><span class="line">    &apos;data&apos; =&gt; [// 具体数据</span><br><span class="line">        ... ...</span><br><span class="line">    ],</span><br><span class="line">    &apos;code&apos; =&gt; &apos;0&apos;, // 0表示成功，其他表示对应错误</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<p>那么这里首先遇到的第一个问题，为了简化前端对类型的判断，基本上所有的字段值，都是返回字符串形式。那么 data 里边的内容就需要在每个控制器中进行处理字符串、utf-8编码等问题。要重复代码，就算你抽离成一个方法，也需要面对该问题。好点的解决方案是在返回数据的拦截器（每一个框架都有类似的概念）内进行统一的处理。</p>
<p>像上面这样的代码写法，带来的额外问题可能有，字段名称打错，比如： code 写成 cdoe ，data 写成 date。为程序代码额外的风险（尤其是bug修复时最容易出现该情况）</p>
<p>那么一种解决办法就该由此想到，采用对象的方式来规范化返回的数据结构。比如我们定义一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class ResultData &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 返回的信息提示</span><br><span class="line">     * @var string $msg</span><br><span class="line">     */</span><br><span class="line">    private $msg;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回的数据结构</span><br><span class="line">     * @var array|object|string</span><br><span class="line">     */</span><br><span class="line">    private $data;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * api 状态码</span><br><span class="line">     * @var int $apiCode</span><br><span class="line">     * @see ApiCode</span><br><span class="line">     */</span><br><span class="line">    private $apiCode;</span><br><span class="line">    </span><br><span class="line">    public function __construct(int $apiCode, string $msg = &apos;ok&apos;, $data = null)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;apiCode = strval($apiCode);</span><br><span class="line">        $this-&gt;msg = trim(strval($msg));</span><br><span class="line">        $this-&gt;data = $data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获取数据结果</span><br><span class="line">     * @return array</span><br><span class="line">     */</span><br><span class="line">    public function getRetData()</span><br><span class="line">    &#123;</span><br><span class="line">        if (! is_array($this-&gt;data) &amp;&amp; is_object($this-&gt;data) &amp;&amp; method_exists($this-&gt;data, &apos;toArray&apos;)) &#123;</span><br><span class="line">            $this-&gt;data = $this-&gt;data-&gt;toArray();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // valueToString 将data的value转化为 string 并且做utf-8转码</span><br><span class="line">        $result = [</span><br><span class="line">            &apos;code&apos; =&gt; $this-&gt;apiCode,</span><br><span class="line">            &apos;msg&apos; =&gt; $this-&gt;msg,</span><br><span class="line">            &apos;data&apos; =&gt; $this-&gt;data ? ArrayUtil::valueToString($this-&gt;data) : [],</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        if (! APP_ENV_PROD) &#123;// 测试环境显示 api 的处理时间信息 方便优化</span><br><span class="line">            $result[&apos;use_time&apos;] = microtime(true) - $_SERVER[&apos;REQUEST_TIME_FLOAT&apos;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了上面这个类，我们所有的服务层或者controller都应该用它作为返回值。然后在拦截器中统一进行json encode即可。这样子即减少了犯错的可能性，同时对统一处理数据的地方做了统一管理集中到 ResultData 中，那么以后有什么特殊变动，调整一处，处处生效。</p>
<h1 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h1><p>另外还有关于 oauth2 如何集成到项目中等等问题，这部分均放到 x-api 项目中进行说明，纸上说来终觉浅嘛。</p>
<p>日志的记录也是系统开发非常重要的部分，这部分没什么太多说的，用规范的格式，存储指定的数据（介质可以是：db、file）。</p>
<p>系统开发中应该拒绝使用 <code>var_dump</code>、<code>echo</code> 这些方式进行调试，另外建议采用：PhpStorm IDE来进行系统开发。</p>
<h1 id="后续分享"><a href="#后续分享" class="headerlink" title="后续分享"></a>后续分享</h1><p>接下来会完善一个 <code>x-api</code> 的基本结构，以及php自动化测试部分文档教程，然后后端部分就告一段落。（本系列的分享主要集中在代码层面，不涉及相关系统部署问题）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[后端开发者从零做一个移动应用（后端篇）]]></title>
      <url>http://dayutalk.cn/2017/07/16/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E4%BB%8E%E9%9B%B6%E5%81%9A%E4%B8%80%E4%B8%AA%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%EF%BC%88%E5%90%8E%E7%AB%AF%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>后端开发，不手摸手，也不嘴对嘴。只想写好代码<br><a id="more"></a></p>
<p>先来上一张前端页面的效果图（Vue + Vux + Vuex + Vue-Router）。<br><img src="http://ol59nqr1i.bkt.clouddn.com/x-app-1.gif" alt="image"></p>
<p><strong> 第一次做gif 没什么经验，太大了。加载慢 </strong></p>
<p>项目地址： <code>http://m.jiasux.com</code>  ，大家可以自行手机打开查看效果。</p>
<hr>
<p>好了，废话少说，来聊聊后端</p>
<p>后端写些什么，什么东西写出来对我是更好的总结，也是对大家更好的帮助？在准备写的时候，我思考了很久。</p>
<p>之前准备了 <code>手摸手，嘴对嘴</code> 教程。想一想这样子没什么意思，如果是一步步做的教程还不如看视频去，就想也许通过总结后端结构（注意是结构不是架构）设计、代码组织、模块划分对大家更有帮助。</p>
<h1 id="后端开发的疑惑"><a href="#后端开发的疑惑" class="headerlink" title="后端开发的疑惑"></a>后端开发的疑惑</h1><p>后端开发最常面对的一个问题：性能、高并发等等。但是这不在本文的讨论范围，我们只讲基本的怎么把代码写好，如何把业务模块划分好。</p>
<p>性能、高并发的解决方案， 大部分是在代码之外的扩展。</p>
<p>那么站在纯粹的 <code>写代码</code> 角度，如何写好后端的代码呢？我以前的疑惑常常有：Controller 层到底放哪些代码？Model 又可以做哪些事情？自己的一些扩展、工具类，该如何组织？</p>
<p><em>发现现在能够想起的疑惑变少了，如果你有什么疑惑，欢迎留言我们一起学习讨论</em></p>
<p>虽然代码主要是实现业务逻辑，但是选择一款好的框架，非常有助于提升团队作业能力，让代码层面的性能无忧。</p>
<h1 id="框架的选择"><a href="#框架的选择" class="headerlink" title="框架的选择"></a>框架的选择</h1><p>说实话，自感 <code>php7</code> 出来后，代码层面的性能，已经到了一个非常高的层度。基本上在百万级别左右的系统，在语言层面没有什么顾虑了。</p>
<p>框架方面，自己用过的php框架包括（时间先后）：<code>ThinkPHP</code> <code>Laravel</code> <code>非著名自造框架</code> <code>Yii</code> <code>Phalcon</code></p>
<p>本文所有代码结构设计与组织设计基于 <code>Phalcon</code> ，其它除了 <code>自造框架</code> 都是非常优秀的框架，不过框架层面的性能，就自身而言，是逐步升高。但是通过一些整合，也可以逐步提升其自身性能，如：<code>Laravel</code> <code>Yii</code>与<code>Swoole</code>结合，也可达到 <code>Phalcon</code> 的程度。</p>
<p>php的版本是：7.1（如果你是一个新项目，一定要用php7）</p>
<h1 id="后端要做些什么"><a href="#后端要做些什么" class="headerlink" title="后端要做些什么"></a>后端要做些什么</h1><p>当然肯定需要先把db设计好，不过这不在我们讨论范围，假设已经完成了这一步。</p>
<p>我们的代码需要提供以下几部分能力：命令行脚本、api版本、后台管理这三部分。当然这三部分也可以拆分成三个项目，不过小公司、小项目没有必要（放在一个项目，加强了代码的复用性）</p>
<p>这三个是大的模块，然后再一个个接下来分析。</p>
<h2 id="命令行脚本"><a href="#命令行脚本" class="headerlink" title="命令行脚本"></a>命令行脚本</h2><p>先说 <strong>命令行脚本</strong> 它是比较独立的部分，不需要用户调用，主要用来完成一些定时任务等。现代一点的框架，都提供这个模块。<br>Phalcon提供了一个 <a href="https://docs.phalconphp.com/zh/3.2/application-cli" target="_blank" rel="external"><code>CLI</code></a> 模块，可以方便的完成这部分能力。他的代码写起来还是 mvc 的结构，只不过访问是通过命令行来进行。</p>
<p>比如一个最简单的 cli<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainTask</span> <span class="keyword">extends</span> <span class="title">Task</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">mainAction</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fwrite(\STDOUT, <span class="string">'hello task!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="api模块"><a href="#api模块" class="headerlink" title="api模块"></a>api模块</h2><p>我在最早接触api概念的时候，很懵逼，觉得很高大上。现在我对它的理解就是：前后端纯数据通信的一种方式。以前做web开发，我们不提供api，直接后段把数据渲染在页面上，用户直接在渲染的界面上操作，然后通过按钮或者什么触发一个请求到后端。</p>
<p>而到了api时代，在web方面有了前后端分离概念；移动app后端更是无力渲染（天然前后端分离）。所以要后台需要把数据发给前端，前端根据数据的描述把数据用用户看得懂的方式展现出来。比如一个商品的api可能结构如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 1,</span><br><span class="line">    msg: 'query ok',</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: '最凉快的空调',</span><br><span class="line">        price: '9999.00',</span><br><span class="line">        img: 'xxx.webp',</span><br><span class="line">        stock: '10'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式让前后端的开发彼此独立，大家专注做自己的事情。但是这也带来另外一个问题：前端有了所谓的版本，后端必须兼顾所有使用的版本。如果我们永远只使用一个api地址。那么代码可能会相当难看。</p>
<p>比如现在有了一个新的需求，以前 空调 只有一张图片。现在空调展示的时候有多张图片。那么有两种办法，一种是增加字段，一种是将原字段 <code>img</code> 变为一个数组。</p>
<p>如果是增加字段不会带来兼容性的问题。但是如果是粗暴的将img类型变更为数组，之前的版本将无法解析这个类型，因此要想变为数组，只能是api的整体升级（一般不会因为这个问题就进行升级）。</p>
<p>那么api做版本有哪些办法呢？我采用了Phalcon的模块来做api的版本控制。以前还尝试过控制器版本。比如：<br><code>ApiV1Controller</code> 表示这是v1版本。<code>ApiV2Controller</code>表示是v2版本。Phalcon的模块为版本提供了非常大的便利，直接新开一个模块，取名 <code>v1</code>，如果之后要升级，新开一个模块叫做 <code>v2</code>。对于不需要修改的功能，可以简单的让v2控制器继承v1中的控制器。</p>
<p>api的版本方面，我们就可以简单通过url的方式完成，比如：</p>
<ul>
<li><a href="https://api.xxx.com/v1/user/123" target="_blank" rel="external">https://api.xxx.com/v1/user/123</a></li>
<li><a href="https://api.xxx.com/v2/user/123" target="_blank" rel="external">https://api.xxx.com/v2/user/123</a><br>版本信息就非常的一目了然。</li>
</ul>
<h2 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h2><p>绝大部分系统，都需要一个cms来上传、修改相关资料。以加速侠为例：需要上传游戏，需要编辑一些游戏合辑等。你可以单独成一个项目，也可以还是用模块来进行开发（我推荐，极大程度的提供了代码复用）。</p>
<p>我最不能接受的一句话是：后台顺便弄一下，反正给公司内部用的。</p>
<p>做为一个有追求的程序员，我们必须要有底线，我们的目标是：让大家工作起来更便捷，更轻松，最后让大家没有工作（哈哈哈）。所以后台我也建议采用前后端分离，通过Vue来进行开发。</p>
<p>当前的后台使用了 Vue + Element UI + Vuex + Vue-Roter来进行开发。参考了，网络上的： <a href="https://segmentfault.com/a/1190000009275424" target="_blank" rel="external">手摸手，带你用vue撸后台</a>，写的真不错，为我学习省了很多弯路，特别是前端在权限控制上这一部分，他的方式让我眼前一亮。我的后台现在才刚刚搭建完基本的部分（路由规划、一些自己扩展的vue插件）<br><img src="http://ol59nqr1i.bkt.clouddn.com/vue-control.jpeg" alt="image"></p>
<p>前后端分离后，后段其实也可以归结到api的开发部分。并且这样带来的一个好处是：如果以后后段要做移动版的一些功能，api都是现成的。</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>写代码越久，越发现语言层面的东西，只要多动手，很快就能达到一个水平。但是业务代码写的再多，也不能让你再技术领域走的更远。因此如果你有幸在大公司，有机会接触大型项目（百万、千万用户级）的，一定好好观察为了这个项目这么多人开发，还能够很好的运作？他是如何解耦业务逻辑与系统架构？如果是在小的公司，那么就尽可能自己尝试去做一些系统的搭建，让大家在这个基础上进行业务开发，而不需要关心一些底层的东西，一个新手也能很快上手写业务。</p>
<p>后面可能还会有两篇到四篇讲后端部分。主要包括，后端项目结构的划分（这个结构我已经尝试过在3、4个项目中使用，目前都运行的很好），后端登陆控制（会开源一个Phalcon的oauth2的代码），后段api的自动化测试。</p>
<p>相关代码我将会陆续放在github上面。所有的代码就叫 <code>x-</code> 吧。x 从小学数学给我留下了深刻印象。</p>
<ul>
<li>x-api  是php的后端项目</li>
<li>x-control 是vue写的后端管理系统</li>
<li>x-client 是vue系的客户端界面</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[后端开发者从零做一个移动应用（一）]]></title>
      <url>http://dayutalk.cn/2017/06/24/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E4%BB%8E%E9%9B%B6%E5%81%9A%E4%B8%80%E4%B8%AA%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>移动互联网时代，我不想只当一个后端工程师<br><a id="more"></a></p>
<p>是时候学习一些新的东西了！</p>
<p>一直以来想要学习一些前端的知识，扩宽自己的技术栈，但是一直以来对前端都是进行了解，没有用一个产品把这些东西给展示出来。最近终于痛定思痛，做了一个 android应用，目前的产品确实很一般，但决定以此为起步，逐步完善、逐步提高。</p>
<p><a href="http://m.jiasux.com/#/share" target="_blank" rel="external">android 1.0版本：欢迎围观</a> </p>
<p>今后一段时间内，博客、公众号的主要内容将会是该产品涉及的技术分享，包括：我的开发思路、技术选择、技术学习等。内容至少保证一月一篇的进度（因为初期还有很多知识需要学习，精力有限）。一来对自己是一个总结，二来是希望可以对打通任督二脉的同学起到一定的帮助。</p>
<h1 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h1><p>先简单介绍一下做的是一个什么产品，大家之后看的时候，做到心中有数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是以提供游戏下载、游戏礼包发放为核心的移动端应用。可以简单理解成一个游戏的应用市场。</span><br></pre></td></tr></table></figure>
<p>当然除了普通的游戏下载外，还提供由我制作的加速游戏下载，是个什么意思呢？这里的加速并不是说优化手机环境，让游戏运行更流畅。而是进入游戏后，可以加速游戏进程，别人通过这个剧情需要10分钟，你只需要5分钟（所有加速的游戏均以取得对方授权）</p>
<p>这个产品也将会以真实的形态进行运营。</p>
<h1 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h1><p>作为一个想要成为 <code>跨端工程师</code> 的我，想以此为契机找到了学习新技术、运用新技术的支撑点。<br>为了完成这个app，最开始想全部采用原生，但这样会遗漏掉 混合应用 的学习，所以决定改为混合应用的方式进行开发。</p>
<ul>
<li>服务端：phalcon + nginx + mysql</li>
<li>前端技术：android + vue + vux（提供 app 与 手机网站）</li>
<li>后台界面：vue + iviewui</li>
</ul>
<p>为了完成上面的任务，服务端方面只需要看一下 <code>phalcon</code> 这个php框架，这对于我还是很容易上手的。一周时间做完了服务端的内容。后面的分享也先从它开始。</p>
<p>在写后端的时候，产出了一个基于 <code>phalcon</code> 的 oauth2 授权的lib。当时本来想找个开源的，没找到。之后也会开源到github上。借鉴了 <a href="https://github.com/Filsh/yii2-oauth2-server" target="_blank" rel="external">Filsh/yii2-oauth2-server</a> 项目。</p>
<p>后端做完后，需要前端展示出来，于是先学了android的一些基础知识（以前有java web开发经历），然后重点了解：<code>Fragment</code> <code>RecyclerView</code> <code>WebView</code>，然后途中了解到 Rxjava，又对它进行了解学习并使用。</p>
<p>这年代学习js，<code>npm</code>，<code>webpack</code>都是必知必会的。</p>
<p>js框架方面，选择目前最火也最好用的 <code>Vue</code>，这部分知识还是学习中，产出的唯一成果就是<a href="http://m.jiasux.com/#/share" target="_blank" rel="external">这个页面</a> <code>http://m.jiasux.com/#/share</code></p>
<p>当然css的布局样式，怎么也没有办法绕过去了（我以前最讨厌的东西，各种浮动让我烦躁）。还好现在工作几年有了耐心，然后又出现了 <code>flex</code> 这种新的布局方案。<br>现在css的写法也是种类繁多，我学习了其中一种<code>less</code>，因为使用的开源项目中采用了该技术。</p>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>最近有些朋友一直再问我，<code>Payment</code> 项目的文档什么时候补全，放心，不会弃坑的。目前已经全部介入支付宝的新版本支付接口。</p>
<p>后期会先从后段开始写，然后写前端。之后逐步记录每一次迭代时就按照开发顺序来进行。也希望大家能够持续关注这个产品，给我提出更好的意见。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[推荐三款我常备开发辅助神器]]></title>
      <url>http://dayutalk.cn/2017/05/02/%E6%8E%A8%E8%8D%90%E4%B8%89%E6%AC%BE%E6%88%91%E5%B8%B8%E5%A4%87%E5%BC%80%E5%8F%91%E8%BE%85%E5%8A%A9%E7%A5%9E%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>好的工具不但提升我们的开发效率，也为工作带来乐趣。这三款工具你绝对值得拥有。<br><a id="more"></a></p>
<p>五一假期过完了，大家都去哪些地方浪了？上班第一天是不是倍感无趣？哈哈，不要紧，今天我来给大家推荐几个神器，让你明天神清气爽，这可是程序员开发必备之良品呀。</p>
<hr>
<h1 id="Api-与-Postman-的不离不弃"><a href="#Api-与-Postman-的不离不弃" class="headerlink" title="Api 与 Postman 的不离不弃"></a>Api 与 Postman 的不离不弃</h1><p>自从有了前后端的分离概念，我就一致在寻找着这样一款工具，我需要把我的接口如何使用告诉前端人员，我需要自己方便的测试api有没有问题，我需要能够自动化完整的测试一下我的接口运行流程有没有问题。当然它还是不能替代代码级别的自动化测试。</p>
<p>期间试过 <code>swagger</code> ，说实话也不错，界面也很漂亮，这是以前写过<a href="http://blog.csdn.net/hel12he/article/details/46547863" target="_blank" rel="external">关于 swagger ui</a> 的一篇文章，感兴趣的可以看看。当我找到 <code>Postman</code> 之后，就果断放弃了 <code>swagger</code> ，为什么呢？</p>
<p><code>swagger</code> 我是通过注解的方式来自动生成文档，所以就导致代码里边又很多文档注释，本来代码只需要10行，结果为了注释，整个文件变成了30行，看代码的时候给人一种很不清爽的感觉；<br>团队作战的时候，改动很频繁，因为文档内置在代码里边，更容易出现冲突的问题；注解的格式需要额外的学习成本。</p>
<p>反观 <code>Postman</code> 是一个独立的应用，提供团队协作（需要购买）；通过google帐号登陆，在任何地方登陆后可以获取到同步的数据；支持所有的http请求方法；能够自动化测试api接口；配合 <code>Postman Interceptor</code> chrome 浏览器插件，方便 phpstrome 进行debug。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/postman.jpeg" alt="image"></p>
<ul>
<li>大家注意看截图，<code>postman</code> 的 collections 功能，方便不同模块的分类；</li>
<li>其中标记为<code>1</code>圈红的地方，可以添加api的详细说明，比如干什么的，字段含义；</li>
<li>标记<code>2</code>的地方，保存了各种情况的返回结果，可以不需要网络就查看各种情况的返回数据；</li>
<li>标记<code>3</code>的地方，可以配置各种环境变量，方便切换。</li>
</ul>
<p>我这里配置了常用的：dev:开发环境，test:测试环境，prod:线上环境。</p>
<blockquote>
<p>postman如果团队开发需要购买，才能方便的同步看到更新的信息。价格还挺贵，我们小公司没钱，我用了一个偷懒的办法：share link 方法。</p>
</blockquote>
<p>同类的工具还有 atom，不过没怎么用过，大家可以比较下。</p>
<h1 id="charles-在我眼前没有秘密"><a href="#charles-在我眼前没有秘密" class="headerlink" title="charles 在我眼前没有秘密"></a>charles 在我眼前没有秘密</h1><p>程序员喜欢把自己的东西加密加密再加密，而面对别人的东西，总喜欢能够看的一清二楚，然后从中学习一些经验。</p>
<p>比如通过观察别人的app请求流程，可以看一下返回什么样的数据？一些基本的参数有哪些？有些接口如何组织请求流程等。</p>
<p>要完成上面的任务， <code>charles</code> 真的是不二之选。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/charles.jpeg" alt="image"></p>
<p>截图我是监控到的某电商的请求数据，左边部分显示的是请求接口，右边是响应的结果。</p>
<p>我就通过这款工具学习过如何对api进行版本维护，如何有效组织首页数据的返回（到底是一个接口搞定所有还是多个接口，前端多次调用？）</p>
<p>当然上面仅仅是它的一个作用。另外一个效果就是，自己的应用出了问题，可以方便的通过它看到请求的数据，以此来进行一些判断，修复bug。特别是强烈推荐测试人员使用，有很多bug是有前后的因果关系，需要看到数据开发人员更容易进行修正。</p>
<blockquote>
<p>如果想要查看 https 请求的数据，需要安装ssl证书到设备上，大家到官网看一下就知道。</p>
</blockquote>
<h1 id="图片压缩，我用-tinypng"><a href="#图片压缩，我用-tinypng" class="headerlink" title="图片压缩，我用 tinypng"></a>图片压缩，我用 tinypng</h1><p>今天推荐的最后一个工具<code>tinypng</code>。我之前再博客也推荐过 google 新的图片压缩算法 <code>guetzli</code>，这个算法真的非常牛逼。但是目前没有好用的客户端，只有命令行。</p>
<p>关于它没有太多的说的，就是压缩图片嘛。支持批量，压缩比率高，效果强。就是好用，把它分享给你的ui妹子，她会对你喜笑颜开。</p>
<p>下载地址：<a href="https://github.com/kyleduo/TinyPNG4Mac" target="_blank" rel="external">https://github.com/kyleduo/TinyPNG4Mac</a></p>
<h1 id="额外赠品"><a href="#额外赠品" class="headerlink" title="额外赠品"></a>额外赠品</h1><p>最后推荐一个集成第三方支付的开源项目：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>目前已经集成：支付宝支付、微信支付、招商一网通支付。如果你在开发中被各个第三方支付提供的demo搞得焦头烂额，我相信它能够帮助到你。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：支付的回调统一处理]]></title>
      <url>http://dayutalk.cn/2017/05/01/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>有20天没有更新了，主要原因有二：其一这期间对自己的职业规划做了一些调整；其二生了一场小病。所以大家一定要保重身体，平时得多锻炼锻炼了。<br><a id="more"></a></p>
<p>根据大家反馈，大家对 <code>Payment</code> 还是很认同，这让我很开心。五一花了两天时间把招商一网通集成进来了。希望能够帮助到更多的人。</p>
<hr>
<p><strong>Payment使用文档</strong>：<a href="https://helei112g.github.io/categories/payment-3/" target="_blank" rel="external">https://helei112g.github.io/categories/payment-3/</a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>言归正传，这篇拖了很久了，借着五一假期的最后一天，搞定它！先上一个支付的一般流程图。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/pay_path.jpg" alt="image"><br><em>图片来源：支付宝</em></p>
<h1 id="异步与同步"><a href="#异步与同步" class="headerlink" title="异步与同步"></a>异步与同步</h1><p>在我们完成支付后，要确认用户是否真的支付了这笔钱，以及这笔钱支付的金额是否符合预期。怎么知道这些事情呢？</p>
<p>用户告诉我们？我们肯定不能确认是否真假。比较恰当的方式是，第三方（支付宝、微信、招商一网通等）收到用户付款后，他来告诉我们。所以这里就引出了通知这个概念。</p>
<p>通知的方式又有两种：同步通知，异步通知。同步通知的概念存在于网站支付或者H5支付中，因为只有在浏览器中才可以通过url进行跳转。那么我们应该使用同步通知作为支付成功的依据还是使用异步通知呢？</p>
<p>我的答案是：同步通知不做服务端的更新，可用于客户端的显示，异步收到通知时才做相关的更新处理。原因有三：</p>
<ol>
<li>并不是所有的支付模块都有同步通知这个概念；</li>
<li>同步通知的参数在url中，就算采用https协议，也存在更大被篡改的风险；</li>
<li>异步通知提供完整的失败重发机制，更值得信耐。</li>
</ol>
<h1 id="异步通知处理"><a href="#异步通知处理" class="headerlink" title="异步通知处理"></a>异步通知处理</h1><p>所以在 Payment 中只针对异步通知到达的数据进行了签名相关处理。下面我们来看看代码。</p>
<p>不管你是支付宝的异步通知，还是微信的异步通知或者招商一网通的异步通知，<code>Payment</code> 都提供了统一的异步处理接口，并且调用者完全不必去关心如何验证签名，如何核实数据，只需要专注自己的业务逻辑即可。</p>
<p>回调使用了一个开发的小技巧：依赖注入，我先上代码，后面稍微解释下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$callback = new TestNotify();</span><br><span class="line"></span><br><span class="line">$type = &apos;ali_charge&apos;;// ali_charge wx_charge  cmb_charge</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    // 获取第三方的原始数据，未进行签名检查，根据自己需要决定是否需要该步骤</span><br><span class="line">    //$retData = Notify::getNotifyData($type, $config);</span><br><span class="line"></span><br><span class="line">    $ret = Notify::run($type, $config, $callback);// 处理回调，内部进行了签名检查</span><br><span class="line">&#125; catch (PayException $e) &#123;</span><br><span class="line">    echo $e-&gt;errorMessage();</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return $ret;</span><br></pre></td></tr></table></figure></p>
<p>回调 的代码就这么简单，其中 <code>Notify::getNotifyData($type, $config);</code> 可以获取到第三方的回调数据，sdk仅仅是解析成数组返回，没有做签名检查，不能直接用来进行回调处理。</p>
<p><code>Notify::run($type, $config, $callback);</code> 则是进行回调相关的处理，它返回的值，是需要返回给第三方支付机构的，第三方机构通过返回值来识别商户是否正确处理了回调通知，并且以此来处理是否需要重发。</p>
<p>这里的重点就是 <code>$callback</code>，注意看上面的代码 <code>$callback = new TestNotify();</code>，</p>
<p>大家的重点就是创建这个 <code>TestNotify</code> 这个类，我们就叫它：商户回调业务处理类，名字大家随便取，根据自己的需要。看一下我示例中 <code>TestNotify.php</code> 的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">use Payment\Notify\PayNotifyInterface;</span><br><span class="line">use Payment\Config;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 客户端需要继承该接口，并实现这个方法，在其中实现对应的业务逻辑</span><br><span class="line"> * Class TestNotify</span><br><span class="line"> * anthor helei</span><br><span class="line"> */</span><br><span class="line">class TestNotify implements PayNotifyInterface</span><br><span class="line">&#123;</span><br><span class="line">    public function notifyProcess(array $data)</span><br><span class="line">    &#123;</span><br><span class="line">        $channel = $data[&apos;channel&apos;];</span><br><span class="line">        if ($channel === Config::ALI_CHARGE) &#123;// 支付宝支付</span><br><span class="line"></span><br><span class="line">        &#125; elseif ($channel === Config::WX_CHARGE) &#123;// 微信支付</span><br><span class="line"></span><br><span class="line">        &#125; elseif ($channel === Config::CMB_CHARGE) &#123;// 招商支付</span><br><span class="line"></span><br><span class="line">        &#125; elseif ($channel === Config::CMB_BIND) &#123;// 招商签约</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其它类型的通知</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 执行业务逻辑，成功后返回true</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的核心就是，客户端创建的 <code>商户回调业务处理类</code> 一定要实现 <code>PayNotifyInterface</code> 这个接口，并且实现 <code>notifyProcess</code> 这个方法，在这个方法中完成自己的商户逻辑。然后根据处理结果返回布尔值。</p>
<p>这里要重点说明的是 <code>TestNotify::notifyProcess(array $data)</code> 这个方法的参数 <code>$data</code>，它是通过sdk内部传过来的，它返回的信息与配置文件 <code>return_raw</code>的设置有关系。</p>
<p>如果 <code>return_raw = false</code> 返回的是我映射的结果，这里需要小心，如果你的php报错级别设置的太高，可能会出现报错，因为内部有很多 <code>Undefined index</code>  错误，因为我并未进行检查，当前可能暂时也不打算修复这个问题。<br>如果  <code>return_raw = true</code> 则返回的是第三方支付机构的原始数据。</p>
<p>不管是设置成什么，该参数里边都有一个 <code>channel</code> 参数，大家可以根据这个参数区分回调属于那一个类别。像上面的示例一样。</p>
<h1 id="PayNotifyInterface-接口"><a href="#PayNotifyInterface-接口" class="headerlink" title="PayNotifyInterface 接口"></a>PayNotifyInterface 接口</h1><p>最近有很多人在微信中问我，干嘛一定要实现这个接口？我这里举个例子：<br>你出去旅行，到了突然发现ios的手机充电线没带，怎么办？找个便利店买一根好了（因为附近没有苹果店），那么怎么买的充电线确保你手机可以用呢？这个很简单，因为苹果把自己充电线的接口标准公布了，凡事想造苹果手机充电线的按照这个标准造出来的，你都可以用。</p>
<p>所以接口的作用就是制定一个标准；你们都实现我规定的接口，然后返回布尔值给我，我就可以处理了。至于内部你们想怎么做，是你们的事情。</p>
<p>通过这个接口完全将签名与商户业务逻辑进行了分离，以后你的调整只围绕这一个类即可。当然这里涉及到的思想有 ioc/di ，这又是另外一个话题，空的时候我们聊聊。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[团队开发Git分支管理策略]]></title>
      <url>http://dayutalk.cn/2017/04/14/%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>开发生涯的前三年都是使用 <code>svn</code>，回首放佛如前世。自从用了 <code>git</code> ，整个人都神经了。<br><a id="more"></a></p>
<p>下面的内容肯定不是什么教你如何用git提交代码，合并分支之类的。现在本人要<strong>从写术的层面提升一下自己文章的品质到道的层面</strong>。</p>
<h1 id="使用git带来的分支疑惑"><a href="#使用git带来的分支疑惑" class="headerlink" title="使用git带来的分支疑惑"></a>使用git带来的分支疑惑</h1><p><code>git</code> 为什么好，为什么要用 <code>git</code>，这不是我本文想要说明的问题。</p>
<p>这里想要给大家分享一下自己使用过程中产生的疑惑，以及解决的这些疑惑的过程。话又说回来，我现在依然充满疑惑。真不知道30岁的时候会不会不惑。</p>
<p>在使用 <code>git</code> 过程中，它的分支功能让我真的欣喜若狂，不过这是把双刃剑，一不小心你会得到这种<code>git</code>路径图：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/git/bg2012070502.png" alt="image"></p>
<p><em>图片来源：阮一峰老师博客</em></p>
<p>我的疑惑：</p>
<ol>
<li>那么团队中我们该使用怎样的分支策略来进行开发协作？</li>
<li>在多人的团队中，我们应该在 <code>master</code> 分支上直接开发吗？</li>
<li>如果线上产生了bug该通过什么样方式的分支去修复？</li>
<li>当有多个分支的时候，测试如何有效的参与进来每一个分支的测试？</li>
</ol>
<h1 id="用成熟的工作流来解决问题"><a href="#用成熟的工作流来解决问题" class="headerlink" title="用成熟的工作流来解决问题"></a>用成熟的工作流来解决问题</h1><p>在解答上面的疑惑前，先介绍几个工作流，然后通过工作流的模式，来进行解答。因为我们必须在某种设定的情景下，才能讨论解决问题的思路。</p>
<p>下面三种工作流方式，都是采用功能驱动开发，也就是先有需求产生，然后诞生对应的分支，然后开发，最后合并回来，完成使命被删除。</p>
<ul>
<li>Git flow</li>
<li>Github flow</li>
<li>Gitlab flow</li>
</ul>
<p>关于这三种工作流的详细介绍，建议看看<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="external">这篇文章-阮一峰</a></p>
<p>我现在采用的是 <code>Git flow</code> ，经过自己的实践，确实好用，解决不少问题。然后如果发现与自己的实际情况有些出入，可以根据需求做出些变动调整。</p>
<h2 id="我的选择"><a href="#我的选择" class="headerlink" title="我的选择"></a>我的选择</h2><p>我选择了 Git flow，它的主要特点是，长期存在两个分支：</p>
<ul>
<li>主分支master</li>
<li>开发分支develop</li>
</ul>
<p>然后，存在三种辅助分支，都是短期的，并且一半情况下只应该存在本地，不要提交到远程库。</p>
<ul>
<li>功能分支（feature branch）</li>
<li>补丁分支（hotfix branch）</li>
<li>预发分支（release branch）<br>在进行上面的分支时，建议的命名规范：feature-xxx、release-xxx、hotfix-xxx</li>
</ul>
<blockquote>
<p>话外：我以前喜欢用下划线，后来发现打中线不需要按 <code>shift</code> ，哈哈，从此开始中线时代。</p>
</blockquote>
<p><strong>什么时候要功能分支？</strong></p>
<p>当你拿到一个需求，或者不是一个立马需求上线的bug修复，那么就应该从 <code>develop</code> 开一个分支出来，完成这部分工作。完成后合并到 <code>develop</code> 分支。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/git/25142846_iM1D.png" alt="image"></p>
<p><strong>什么时候要预发分支？</strong></p>
<p>这个分支是为预发准备的，测试的介入，也只应该在该分支产生时才介入。当我们不管是新功能开发，还是一般的bug修改都差不多了。就应该从<code>develop</code>产生一个<code>release</code>分支，交给测试，如果有bug直接在上面修改。全部完成后，合并回<code>develop</code>，并且合并到<code>master</code>。</p>
<p>关于这个分支我得再多说几句。因为这是非常重要的一步，如果我们使用了 git 钩子，当合并到 <code>master</code> 的时候，会自动发布到线上，所以这是临上线的最后一道屏障。</p>
<p>同时这里也解决了我一个疑惑，测试如何参与到<code>git</code>的每个分支中来？答案是：测试不应该参与到每个分支中来，只应该参与到<code>release</code>分支中去。其它的开发分支，都应该由开发人员自己测试，测试没有问题的时候才准许合并到<code>develop</code>，这就要求每一个开发要提高自己交付的产品质量，如何确保自己交付的产品质量？自动化测试是个不错的选择，好了，打住，这不是咋们今天的主要任务，这个话题改天再聊。</p>
<p><strong>什么时候需要补丁分支？</strong></p>
<p>这种情况越少越好。因为它产生的原因是：线上出了bug，并且必须马上修复，不管你身在何方，当手机响起，拿出电脑改bug吧。</p>
<p>它与<code>release</code> 很像，都需要完成后，同时合并到:<code>master</code>与<code>develop</code>。不同的是，它需要从<code>master</code> 上开一个分支出来。<br><img src="http://ol59nqr1i.bkt.clouddn.com/git/hotfix.png" alt="image"></p>
<p>注意这里没有测试的介入，一半来说都是代码上某一个小的紧急bug，虽然很严重，但是可以很容易改动。当然如果有一些例外情况，应该让测试进行测试后再合并、发布。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>git</code> 开发很好用，但是要按照一定规则合理使用分支。</p>
<p>另外，除了:<code>master</code>与<code>develop</code> 分支，其它分支都不应该出现在远程仓库中。</p>
<p>用<code>git</code>一定要结合它的各种钩子来使用，提升开发效率。这里后面来介绍下。</p>
<p>参考资料:</p>
<ul>
<li>[1]<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="external">Git 工作流程</a></li>
<li>[2]<a href="http://www.oschina.net/translate/a-successful-git-branching-model?lang=chs&amp;page=1" target="_blank" rel="external">介绍一个成功的 Git 分支模型</a></li>
</ul>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>我是何磊，主要工作就是写代码，持续创业者（之所以持续是因为到现在还没有干成功过一件事）。如果你有兴趣欢迎关注我，我会分享技术，还有生活，当然还有我创业的故事（说出我的痛，让你开心一下）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：微信支付发起支付请求文档]]></title>
      <url>http://dayutalk.cn/2017/04/10/Payment%EF%BC%9A%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%8F%91%E8%B5%B7%E6%94%AF%E4%BB%98%E8%AF%B7%E6%B1%82%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<p>文档更新太慢，自己都忍不住要抱怨了。可能越来越慢了<br><a id="more"></a></p>
<p><strong><code>Payment 3.0</code></strong> 微信的配置设置文档请 <a href="https://helei112g.github.io/2017/03/28/Payment%EF%BC%9A%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%AF%B4%E6%98%8E/" target="_blank" rel="external">点击这里</a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>为了调用方便，提供了统一的 <code>Client\Charge</code> 类来发起支付。需要设置的参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>body</td>
<td>boolean</td>
<td>是</td>
<td>商品描述</td>
</tr>
<tr>
<td>subject</td>
<td>string</td>
<td>是</td>
<td>商品名称,该参数最长为128个汉字</td>
</tr>
<tr>
<td>order_no</td>
<td>string</td>
<td>是</td>
<td>商户网站唯一订单号</td>
</tr>
<tr>
<td>timeout_express</td>
<td>string</td>
<td>是</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。</td>
</tr>
<tr>
<td>amount</td>
<td>float</td>
<td>是</td>
<td>该笔订单的资金总额，单位为RMB-Yuan</td>
</tr>
<tr>
<td>return_param</td>
<td>string</td>
<td>是</td>
<td>附加数据，在查询API和支付通知中原样返回</td>
</tr>
<tr>
<td>client_ip</td>
<td>string</td>
<td>是</td>
<td>用户端实际ip</td>
</tr>
<tr>
<td>terminal_id</td>
<td>string</td>
<td>是</td>
<td>自定义参数，可以为终端设备号(门店号或收银设备ID)，PC网页或公众号内支付可以传”WEB”</td>
</tr>
<tr>
<td>product_id</td>
<td>string</td>
<td>否</td>
<td>商品ID</td>
</tr>
<tr>
<td>openid</td>
<td>string</td>
<td>否</td>
<td>此参数为微信用户在商户对应appid下的唯一标识</td>
</tr>
</tbody>
</table>
<p>在上面的参数中，无论微信的哪一种支付都必须提供：</p>
<ul>
<li>body</li>
<li>order_no</li>
<li>timeout_express</li>
<li>amount</li>
<li>return_param</li>
<li>client_ip</li>
<li>terminal_id<br>这几个参数，是必须进行设置的。</li>
</ul>
<h1 id="扫码支付"><a href="#扫码支付" class="headerlink" title="扫码支付"></a>扫码支付</h1><p>用户扫描商户展示在各种场景的二维码进行支付。这里采用的是模式二。</p>
<p>对于扫码支付，必须提供: product_id  参数，该 <code>product_id</code> 是商户自己平台的信息，可用使用sku。</p>
<p>如果扫码支付时，传入了 <code>openid</code>，则扫码时，只能使用对应的微信扫码才能完成支付。这里可以根据自己的需求来决定。<br><a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_5" target="_blank" rel="external">扫码支付，模式二介绍</a></p>
<h1 id="刷卡支付"><a href="#刷卡支付" class="headerlink" title="刷卡支付"></a>刷卡支付</h1><p>刷卡支付，就是用于用户向商户展示二维码，商户通过扫码枪获取二维码或者条码信息，完成收款。与上面的扫码支付相对应。<br><code>auth_code</code> 是必须设置的参数，扫码支付授权码，设备读取用户微信中的条码或者二维码信息</p>
<h1 id="app支付"><a href="#app支付" class="headerlink" title="app支付"></a>app支付</h1><p>适用于商户在移动端APP中集成微信支付功能。<br>商户APP调用微信提供的SDK调用微信支付模块，商户APP会跳转到微信中完成支付，支付完后跳回到商户APP内，最后展示支付结果。<br>目前微信支付支持手机系统有：IOS（苹果）、Android（安卓）和WP（Windows Phone）。</p>
<p>该支付方式，无需额外的参数信息，只需要上面表格中标记的必须参数。</p>
<p><a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5" target="_blank" rel="external">客户端教程</a></p>
<h1 id="公众号支付"><a href="#公众号支付" class="headerlink" title="公众号支付"></a>公众号支付</h1><p>商户已有H5商城网站，用户通过消息或扫描二维码在微信内打开网页时，可以调用微信支付完成下单购买的流程。</p>
<p>这里记住一定时微信内部打开h5页面。</p>
<p><code>openid</code> 是公众号支付必须提供的信息，微信用户在商户对应appid下的唯一标识。openid如何获取，可参考<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_4" target="_blank" rel="external">获取openid</a></p>
<p>这里用到了 openid，也就说明该支付只能由发起支付请求的公众号完成支付。</p>
<p>因此，如果有时候遇到：“下单账号和支付账号不一致”  ，那么肯定是发起支付请求的时候是一个帐号，而进行支付时变成了另外一个微信帐号导致的。</p>
<blockquote>
<p>小程序支付与公众号支付具有相同的请求参数</p>
</blockquote>
<p><a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6" target="_blank" rel="external">公众号调起支付</a><br><a href="https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&amp;index=3" target="_blank" rel="external">小程序调起支付</a></p>
<h1 id="h5支付"><a href="#h5支付" class="headerlink" title="h5支付"></a>h5支付</h1><p>H5支付是指商户在微信客户端外的移动端网页展示商品或服务，用户在前述页面确认使用微信支付时，商户发起本服务呼起微信客户端进行支付。<br>主要用于触屏版的手机浏览器请求微信支付的场景。可以方便的从外部浏览器唤起微信支付</p>
<p>微信这个支付能力，并未完全开放，申请的条件也比较苛刻。不过说实话也不好用。</p>
<p>参数跟app支付一样，不需要添加额外的信息。</p>
<p><a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_4" target="_blank" rel="external">外部网页唤起微信支付</a></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>下面代码实例一下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Client</span>\<span class="title">Charge</span>;</span><br><span class="line"></span><br><span class="line">$config = <span class="keyword">require_once</span>(<span class="string">'./wxconfig.php'</span>);<span class="comment">// 微信的配置信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$channel = <span class="string">'wx_app'</span>;<span class="comment">// wx_app    wx_pub   wx_qr   wx_bar  wx_lite   wx_wap</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$payData = [</span><br><span class="line">    <span class="string">'body'</span> =&gt; <span class="string">'一个苹果'</span>,</span><br><span class="line">    <span class="string">'subject'</span> =&gt; <span class="string">'牛逼公司--付款吧'</span>,</span><br><span class="line">    <span class="string">'order_no'</span> =&gt; <span class="string">'NB12312355'</span>,</span><br><span class="line">    <span class="string">'timeout_express'</span> =&gt; <span class="string">'1489241888'</span>,</span><br><span class="line">    <span class="string">'amount'</span> =&gt; <span class="string">'100'</span>,</span><br><span class="line">    <span class="string">'return_param'</span> =&gt; <span class="string">'buy some'</span>,</span><br><span class="line">    <span class="string">'client_ip'</span> =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">'terminal_id'</span> =&gt; <span class="string">'WEB'</span>,</span><br><span class="line">    <span class="comment">//'product_id' =&gt; '888',</span></span><br><span class="line">    <span class="comment">//'openid' =&gt; 'xxxxxxx',</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">// product_id  openid  参数，并不是每一个支付都需要，具体行为阅读上面文档</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $str = Charge::run($channel, $config, $payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_array($ret)) &#123;</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    header(<span class="string">'Location:'</span> . $ret);</span><br><span class="line">    <span class="keyword">echo</span> htmlspecialchars($ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">exit</span>;</span><br></pre></td></tr></table></figure></p>
<p>关于 <code>channel</code> 的说明：</p>
<table>
<thead>
<tr>
<th>渠道</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>wx_app</td>
<td>代表app支付</td>
</tr>
<tr>
<td>wx_pub</td>
<td>代表公众号支付</td>
</tr>
<tr>
<td>wx_qr</td>
<td>代表扫码支付</td>
</tr>
<tr>
<td>wx_bar</td>
<td>代表刷卡支付</td>
</tr>
<tr>
<td>wx_lite</td>
<td>代表小程序支付</td>
</tr>
<tr>
<td>wx_wap</td>
<td>代表h5支付</td>
</tr>
</tbody>
</table>
<p>关于支付返回的各种数据，以及相关支付方式，如果调起微信支付，请自行查看对应文档。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[php工程狮感知的前端工作流程]]></title>
      <url>http://dayutalk.cn/2017/04/01/php%E5%B7%A5%E7%A8%8B%E7%8B%AE%E6%84%9F%E7%9F%A5%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>这个时代不懂点前端知识，真的没有办法生存。就算不会写，也得了解它的原理吧！<br><a id="more"></a></p>
<p>最近做了一些总结，之前都是迷迷糊糊，搞不清楚前端之前的相关定位。好好梳理了一下。错误之处请各位指正。</p>
<p>本文主要说的是 JavaScript 工作流程</p>
<hr>
<p>目前前端真的该叫大前端，其越来越细化，越来越复杂。在这种背景下，诞生了很多工具很多前端工作流程。比如热门的：</p>
<ul>
<li>react</li>
<li>vue</li>
<li>webpack</li>
<li>babel</li>
<li>gulp</li>
<li>node.js</li>
<li>npm</li>
<li>nvm</li>
<li>angular</li>
<li>bower<br>… …</li>
</ul>
<p>如果继续写，估计光这个，字数久能够达到1000+<br>这里边有的是前端js框架，有的是一些开发工具，但他们种类这么多，各自能够解决什么问题？互相之间有什么联系？是不是一个项目就必须用上这么多东西？使用时候，如何相互配合？</p>
<p>带着这些疑问，作为一个后端程序员，进行了系列调查，要把我的成果分享出来（可能错误百出）。<br>首先前端开发的三大基础：</p>
<ul>
<li><strong><code>html</code></strong> 这个是最基础的，被称为：超文本标记语言。什么意思？简单来说就是描述一个页面的结构，比如：页面的头部，页面的内容，页面的尾部。也就说，它控制一个页面的结构。浏览器会按照它定义的结构来进行解析，显示不同内容。</li>
<li><strong><code>css</code></strong> 我们对美的追求是无止境的，光有结构，看起来没有色彩，有些地方不突出。就像衣服：原始人用树叶、兽皮，随着进步，我们穿丝绸、破洞牛仔，搭配丝巾、手表等等，所以就是用来控制html的样式，让它变的更好看。</li>
<li><strong><code>JavaScript</code></strong> 这是本文主要阐述的地方，有了html+css，显然还不能满足我们的追求，会html、css的人不能叫做前端工程师、更不能叫程序媛。但是如果你会了 JavaScript，江湖就有你的依稀之地，这也是本文主要介绍的部分。</li>
</ul>
<p>目前我们很多时候常说的前端工程师，其实主要指的就是其 js工程师。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。</p>
<p>功能越强大，责任也越多。现在 js（后面全部使用简称，字太多，不想写）使用的越来越多，早期 js 仅仅用来做一些简单的交互，随着现在移动互联网的发展，各项硬件设备的性能提升。项目越来越复杂，效果越来越酷炫。js 做的事情也更多。</p>
<p>当然今天不讲这么多发展历史（关键是我也没理清呀），总的来说就是 js 开发工作原来比较简单，大家随便写写久搞定工作了，但是现在工作的复杂度越来越高，像以前那么任性的工作，开发麻烦、维护麻烦。还好具备程序员三大美德人，开始构建一些工具。</p>
<p>Perl语言的发明人Larry Wall说，好的程序员有3种美德： 懒惰、急躁和傲慢（Laziness, Impatience and hubris）。</p>
<blockquote>
<p>懒惰：<br>是这样一种品质，它使得你花大力气去避免消耗过多的精力。它敦促你写出节省体力的程序，同时别人也能利用它们。为此你会写出完善的文档，以免别人问你太多问题。<br>急躁：<br>是这样一种愤怒—-当你发现计算机懒洋洋地不给出结果。于是你写出更优秀的代码，能尽快真正的解决问题。至少看上去是这样<br>傲慢：<br>极度的自信，使你有信心写出（或维护）别人挑不出毛病的程序</p>
</blockquote>
<p>先是大家感觉js代码复用是个问题，我们想用别人写的某个功能，只能网上去翻别人写的源码，拷贝下来。后段语言都有自己的包管理工具，比如：java的maven，python的pip，php的composer等。于是在历史的使命召唤中，npm诞生了，js的包管理工具。<br>比如以前要使用 jquery，你的到官网去下载，现在 npm install jquery 就可以了。</p>
<p>npm是运行在node的环境上，它们的关系又是另外一个话题，这里按下暂且不表。<br>像 react、vue都可以通过npm来安装。</p>
<p>包管理的问题解决了，接下来又有另外一个问题，由于 js 是 <code>Brendan Eich</code> 这大哥花了 10 天时间设计的（牛人就是这么屌）。虽然如今广泛应用，也由于时间紧导致留下了很多设计缺陷。</p>
<p>伴随了 <code>ES6</code> 的发布，js越来越规范了，我们程序员肯定都想用好用的简洁的语法来完成任务，好早点下班回家打lol呀。可惜呀，世界上成百上千万的网站，不可能一下子全部升级，浏览器也不可能立马就支持最新语法，怎么办？<code>babel</code> 诞生了，它牛逼在那里？让你可以用es6的语法写代码，然后在现在的环境下可以运行（在这里请自行忽略ie9以下浏览器）。</p>
<p>在你用es6写完代码后，用它转码一下，可以得到es5的代码。不信？来个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转码前</span></span><br><span class="line">input.map(item =&gt; item + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转码后</span></span><br><span class="line">input.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。</p>
<p>另外 babel 其实也是用js写的一个工具，所以它还是可以通过 <code>npm install babel-cli</code> 来安装。</p>
<p>关于它怎么用，自己看官方文档。</p>
<p>好。到目前为止，解决了两个大问题。接着看前端还有什么问题？那么在开发中还有什么问题需要解决？合并文件、压缩代码、检查语法错误、将Sass代码转成CSS代码等等这些都是开发中的重复性任务，以前这些任务都需要单独人工解决，然后为了提高效率，早点下班，就有了:Gulp  Grunt这些task runner。推荐使用gulp来自动化的执行这些任务。</p>
<p>那么到了这里，是不是就截止了？还没有，现在的基本都讲究什么前后端分离，也就是变成了web app的方式，那么就要求页面重新加载要变少，用户交互要变多，也就导致一个页面上js越来越多。这么多的js怎么管理？如何提高浏览器的加在速度？能否将css img html 字体这些资源也当成模块来处理？在这些问题下，产生了很多模块打包工具，毫无疑问：webpack是最耀眼的，也是用起来最爽的。</p>
<p>所以模块打包的问题也解决了，另外说一句，gulp的部分功能可能通过webpack的插件也能解决，但并不意味着不再需要它，一般来说gulp运行在webpack之后。</p>
<p>再次声明，上面所有介绍的东西，都可以通过npm来安装获得。所以说到底它们都是用js写的一个工具。</p>
<p>ok，那么工具基本介绍完了，到底页面怎么呈现给用户？后台传过来的数据怎么绑定到dom里边去？如果向后台发起请求获得数据？等等，这些需要一个js业务框架来完成。所以react、vue就是来解决这些问题的</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>至此前端的一个工作结构介绍至此结束。再瞎逼逼两句，学习是一件持续的事情，在学习某个新东西前，先要对它是干吗的，它解决一个什么样的问题有个认识，然后面对知识你才能在自己的脑海中建立一个体系。</p>
<p>参考了很多资料，贴在这里供参考:</p>
<ul>
<li>[1] <a href="https://chenyiqiao.gitbooks.io/webpack/content/motivation_of_webpack.html" target="_blank" rel="external">我们为什么需要Webpack？</a></li>
<li>[2] <a href="https://cn.vuejs.org/v2/guide/comparison.html" target="_blank" rel="external">Vue 对比其他框架</a></li>
<li>[3] <a href="https://www.zhihu.com/question/37020798" target="_blank" rel="external">Webpack、Browserify和Gulp三者之间到底是怎样的关系？</a></li>
<li>[4] <a href="http://es6.ruanyifeng.com/#docs/intro#Babel-转码器" target="_blank" rel="external">Babel-转码器</a></li>
<li>[5]<a href="http://www.gulpjs.com.cn" target="_blank" rel="external">用自动化构建工具增强你的工作流程！</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：微信支付配置文件设置说明]]></title>
      <url>http://dayutalk.cn/2017/03/28/Payment%EF%BC%9A%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<p>终于写到微信了。加油干，撸起袖子奔小康。<br><a id="more"></a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>微信支付个人觉得在帐号设置上有些麻烦，帐号太多啦，支付宝目前就是一个应用基本涵盖了所有的接口开发。</p>
<p>可能是由于微信支付的后端是财付通，反正咱们写代码的，也别管那么多。理清楚各配置的关系，然后写出高质量的代码就好。</p>
<p>关于如何申请微信支付，只讲两个问题，服务号支付能力的申请在公众号后后台申请，app应用的支付能力申请在开发者中心申请。其他细节请自行查询。</p>
<hr>
<p>登陆微信商户平台：<a href="https://pay.weixin.qq.com" target="_blank" rel="external">https://pay.weixin.qq.com</a></p>
<p>拿到微信给的商户号后，登陆商户平台，点击【账户中心】进入【API安全】<br>会看到下面的截图：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/pay/set-md5-key.jpeg" alt="image"></p>
<p>微信支付发起请求的数据需要进行签名，签名的密钥就是在这里设置，设置时候请记录一下。等会配置中会需要。</p>
<p>下载微信的安全证书，相关说明<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=4_3" target="_blank" rel="external">看这里</a></p>
<p>配置文件<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'app_id'</span>            =&gt; <span class="string">'应用ID'</span>,</span><br><span class="line">    <span class="string">'mch_id'</span>            =&gt; <span class="string">'商户id'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>           =&gt; <span class="string">'刚刚设置的密钥'</span>,</span><br><span class="line">    <span class="string">'app_cert_pem'</span>      =&gt; <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'app_key_pem'</span>       =&gt; <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">    <span class="string">'sign_type'</span>         =&gt; <span class="string">'MD5'</span>,<span class="comment">// MD5  HMAC-SHA256</span></span><br><span class="line">    <span class="string">'limit_pay'</span>         =&gt; [</span><br><span class="line">        <span class="comment">//'no_credit',</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'fee_type'</span>          =&gt; <span class="string">'CNY'</span>,<span class="comment">// 货币类型  当前仅支持该字段</span></span><br><span class="line">    <span class="string">'notify_url'</span>        =&gt; <span class="string">'https://helei112g.github.io/'</span>,</span><br><span class="line">    <span class="string">'redirect_url'</span>      =&gt; <span class="string">'https://helei112g.github.io/'</span>,</span><br><span class="line">    <span class="string">'return_raw'</span>        =&gt; <span class="keyword">false</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>下面表格中 <strong>是否必须</strong> 列如果标记为 <code>是</code>  ，则该项必须设置，否则sdk将无法得到结果。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>app_id</td>
<td>string</td>
<td>是</td>
<td>应用id，下面会详细解释</td>
</tr>
<tr>
<td>mch_id</td>
<td>string</td>
<td>是</td>
<td>微信支付分配的商户号</td>
</tr>
<tr>
<td>md5_key</td>
<td>string</td>
<td>是</td>
<td>用户在商户中心设置的api密钥</td>
</tr>
<tr>
<td>sign_type</td>
<td>string</td>
<td>是</td>
<td>签名类型，默认为MD5，支持HMAC-SHA256和MD5。</td>
</tr>
<tr>
<td>app_cert_pem</td>
<td>string</td>
<td>是</td>
<td>证书pem格式</td>
</tr>
<tr>
<td>app_key_pem</td>
<td>string</td>
<td>是</td>
<td>证书密钥pem格式</td>
</tr>
<tr>
<td>limit_pay</td>
<td>array</td>
<td>否</td>
<td>上传此参数no_credit–可限制用户不能使用信用卡支付</td>
</tr>
<tr>
<td>fee_type</td>
<td>string</td>
<td>否</td>
<td>默认人民币：CNY</td>
</tr>
<tr>
<td>notify_url</td>
<td>string</td>
<td>是</td>
<td>异步通知的地址</td>
</tr>
<tr>
<td>redirect_url</td>
<td>string</td>
<td>否</td>
<td>回调页面地址</td>
</tr>
<tr>
<td>return_raw</td>
<td>boolean</td>
<td>否</td>
<td>是否返回微信原始数据</td>
</tr>
</tbody>
</table>
<p><strong><code>app_id</code>:</strong> 对于公众号支付，是微信支付分配的公众账号ID，如果是app支付则是微信开放平台审核通过的应用APPID</p>
<p>微信支付接口中，一定要注意区分不同的帐号类别</p>
<ul>
<li>公众号支付，需要对应服务号在公众号后台申请，该帐号无法用来进行app支付</li>
<li>app支付，微信开放平台审核通过的应用APPID，无法用来进行公众号支付</li>
<li>小程序支付也是一个独立的帐号，微信分配的小程序ID</li>
<li>扫码支付，可以使用app支付的帐号，也可使用公众支付的帐号</li>
<li>刷卡支付，两个帐号也可以使用</li>
</ul>
<p>由于我没有小程序的帐号，没办法测它是否可以用于扫码支付与刷卡支付，有测过的朋友请告诉我一下（微信号：<code>helei543345</code>）</p>
<p><strong><code>mch_id</code>:</strong> 商户号，申请商户号成功后，腾讯给你发的邮件里边有</p>
<p><strong><code>md5_key</code>:</strong> 在商户中心自己设置的api密钥，主要用来签名支付数据</p>
<p><strong><code>sign_type</code>:</strong> 签名方式，当前微信支持HMAC-SHA256和MD5，默认使用 MD5</p>
<p><strong><code>app_cert_pem</code>:</strong> 从apiclient_cert.p12中导出证书部分的文件，为pem格式，请妥善保管不要泄漏和被他人复制</p>
<p><strong><code>app_key_pem</code>:</strong> 从apiclient_key.pem中导出密钥部分的文件，为pem格式</p>
<p>关于 <code>app_cert_pem</code> 与 <code>app_key_pem</code> 的详情请看这里 : <a href="https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=4_3" target="_blank" rel="external">https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=4_3</a></p>
<p><strong><code>limit_pay</code>：</strong> no_credit–指定不能使用信用卡支付  ，当前微信仅这一个参数，设置了，支付时，用户无法使用信用卡</p>
<p><strong><code>fee_type</code>:</strong> 货币类型，默认是人民币，其他可选值看这里：<a href="https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=4_2" target="_blank" rel="external">https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=4_2</a></p>
<p><strong><code>notify_url</code>：</strong> 异步接收微信支付结果通知的回调地址，通知url必须为外网可访问的url，不能携带参数。</p>
<p><strong><code>redirect_url</code>:</strong> 只有在使用h5支付时，才需要设置，也可以选择不设置。用来控制在h5中支付成功后，跳转的页面。</p>
<p><strong><code>return_raw</code>：</strong> 是否返回微信的原始数据，默认为false，建议设置为true</p>
<ul>
<li>该参数如果设置为 <code>false</code>，sdk内部会映射一些key，并且把微信的金额处理为元</li>
<li>如果参数值为 <code>true</code> ，则只对异步数据进行签名检查，检查通过，返回一个数据类型的数据（微信原始为xml），其中包含的key是微信本身的，并且金额相关的单位都是分</li>
</ul>
<p>微信的配置文件相对来说比较简单，只是它的帐号体系有点多，大家在使用时，根据自己使用不同支付，读取不同配置，来完成相互间的切换。</p>
<p>另外，如果还需要转账或者发红包，请设置以下图中的信息。<br><img src="http://ol59nqr1i.bkt.clouddn.com/pay/set-other.jpeg" alt="image"></p>
<p>今天晚上公司部署新项目，在等待过程中把微信的配置文档搞定。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Guetzli 图片压缩到底有多牛]]></title>
      <url>http://dayutalk.cn/2017/03/28/Guetzli%20%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E7%89%9B/</url>
      <content type="html"><![CDATA[<p>忙里偷闲，把一张图片用 guetzli 压缩了13次。你要不要来看看结果<br><a id="more"></a></p>
<p>在上一篇文章中，介绍了 guetzli 的安装。伴随 1.0.1 版本移除 gflags ，安装也变的异常简单了。</p>
<p>本篇带领大家看一下他的压缩效果。我下面放几张图。大家可以看看效果。看谁能够识别那张图是压缩了的。</p>
<p>下面全是图片。</p>
<p>图片一：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb01.jpg" alt="image"></p>
<p>图片二：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1.jpg" alt="image"></p>
<p>图片三：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb02.jpg" alt="image"></p>
<p>图片四：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb03.jpg" alt="image"></p>
<p>图片五：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb04.jpg" alt="image"></p>
<p>图片六：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb05.jpg" alt="image"></p>
<p>图片七：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb06.jpg" alt="image"></p>
<p>图片八：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb07.jpg" alt="image"></p>
<p>图片九：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb08.jpg" alt="image"></p>
<p>图片十：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb09.jpg" alt="image"></p>
<p>图片十一：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb10.jpg" alt="image"></p>
<p>图片十二：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb11.jpg" alt="image"></p>
<p>图片十三：<br><img src="http://ol59nqr1i.bkt.clouddn.com/guetzli/t1-thumb12.jpg" alt="image"></p>
<p>整个验证过程，我将原图进行了13次压缩。</p>
<p>原始图片是： 1.3M ，压缩到最后只剩下 254KB。这是很高的压缩比，而且很难察觉图片质量是否变低。</p>
<p>但是 guetzili 当前还仅支持单图压缩，而且很慢，希望以后可以改善。自己用python写了一个 批量处理图片的脚本。如果有需要的朋友，关注我的微信公众号，留下的邮箱，我会将脚本发送给你。随便把你猜的答案发给我。</p>
<p>后期计划可能出一个在线api，方便大家使用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何在 CentOs7 中安装guetzli]]></title>
      <url>http://dayutalk.cn/2017/03/21/%E5%A6%82%E4%BD%95%E5%9C%A8-CentOs7-%E4%B8%AD%E5%AE%89%E8%A3%85guetzli/</url>
      <content type="html"><![CDATA[<p>CentOs7 中安装 <code>guetzli</code> 教程，我的承诺，今天兑现。带你上车<br><a id="more"></a></p>
<p>周六的时候收到 36kr 推送的一篇文章： <a href="http://36kr.com/p/5067258.html" target="_blank" rel="external">Google开源新算法，可将JPEG文件缩小35%</a></p>
<p>测试了结果，惊的我目瞪口呆。如果非要我用一个词形容的话：</p>
<p>牛逼</p>
<p>太牛逼</p>
<p>先来教大家如何在 CentOs7 中安装，项目的说明文档没有很好的说明如何完成 redhat 系列的 linux 如何安装。我是踩了不少坑才完成的。</p>
<p>这里边最简单的安装就是 mac 上了，直接通过 <code>brew install guetzli</code> 就ok。ubuntu 上的安装也是满多坑，如果出了问题，也可以借鉴本文。</p>
<p><a href="https://github.com/google/guetzli" target="_blank" rel="external">Guetzli 项目地址</a></p>
<hr>
<p>首先为自己的系统设置epel源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rpm -ivh http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br></pre></td></tr></table></figure></p>
<p>上面这一步并不是必须的。我只是为了讲解后面的错误。</p>
<p>在安装 Guetzli 之前，需要先安装：</p>
<ul>
<li><code>libpng</code> <a href="http://www.libpng.org/pub/png/libpng.html" target="_blank" rel="external">link</a></li>
<li><code>gflags</code> <a href="https://gflags.github.io/gflags/" target="_blank" rel="external">link</a></li>
</ul>
<h1 id="libpng的安装"><a href="#libpng的安装" class="headerlink" title="libpng的安装"></a>libpng的安装</h1><p>先说 <code>libpng</code> 的安装。该库是一款C语言编写的比较底层的读写PNG文件的跨平台的库。</p>
<p>如果搞不懂c语言，你也不用管他，简单说就是 <code>guetzli</code> 内部会使用它，所以需要先把它安装好。否则 <code>guetzli</code> 没办法读取png图片（并且也不能编译通过）</p>
<p>这个库可以直接通过yum来进行安装。安装出来的是 <code>1.5.13</code>  。当前最新的版本是 <code>1.6.29</code><br>由于我的源里边没有最新版，所以这里安装的版本就是：1.5.13</p>
<p>安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libpng-devel</span><br></pre></td></tr></table></figure></p>
<p>这里一定注意，不要直接安装 libpng  。安装 libpng-devel 会依赖安装 <code>libpng</code></p>
<p>ps: <code>libpng-devel</code> 是 用于程序操作PNG图片的开发工具</p>
<blockquote>
<p>The libpng-devel package contains header files and documentation necessary<br>for developing programs using the PNG (Portable Network Graphics) library.<br>If you want to develop programs which will manipulate PNG image format<br>files, you should install libpng-devel.  You’ll also need to install<br>the libpng package.</p>
</blockquote>
<p>如果没有安装依赖成功，请自行手动安装。命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libpng</span><br></pre></td></tr></table></figure></p>
<p>检查是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info libpng libpng-devel</span><br></pre></td></tr></table></figure>
<p>看到如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">已安装的软件包</span><br><span class="line">名称    ：libpng</span><br><span class="line">架构    ：x86_64</span><br><span class="line">时期       ：2</span><br><span class="line">版本    ：1.5.13</span><br><span class="line">发布    ：7.el7_2</span><br><span class="line">大小    ：602 k</span><br><span class="line">源    ：installed</span><br><span class="line">来自源：base</span><br><span class="line">简介    ： A library of functions for manipulating PNG image format files</span><br><span class="line">网址    ：http://www.libpng.org/pub/png/</span><br><span class="line">协议    ： zlib</span><br><span class="line"></span><br><span class="line">名称    ：libpng-devel</span><br><span class="line">架构    ：x86_64</span><br><span class="line">时期       ：2</span><br><span class="line">版本    ：1.5.13</span><br><span class="line">发布    ：7.el7_2</span><br><span class="line">大小    ：211 k</span><br><span class="line">源    ：installed</span><br><span class="line">来自源：base</span><br><span class="line">简介    ： Development tools for programs to manipulate PNG image format files</span><br><span class="line">网址    ：http://www.libpng.org/pub/png/</span><br><span class="line">协议    ： zlib</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>yum info</code> 命令查看已安装的软件选项。如果看到上面的结果说明安装成功。</p>
<h1 id="gflags的错误安装"><a href="#gflags的错误安装" class="headerlink" title="gflags的错误安装"></a>gflags的错误安装</h1><p>为了把他安装好，搞得我神魂颠倒，忘乎所以。真的是太多坑。最后通过 <a href="https://github.com/google/guetzli/issues/86" target="_blank" rel="external">issue</a> 得到了自己想要的答案。下面将给大家重现一下我的错误过程。</p>
<p>记得文章开头让大家设置的 <code>epel</code> 源吗？我用 <code>yum search gflags</code> 找到如下信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@play ~]# yum search gflags</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: centos.nethub.com.hk</span><br><span class="line"> * epel: ftp.jaist.ac.jp</span><br><span class="line"> * extras: mirrors.btte.net</span><br><span class="line"> * updates: mirror.lzu.edu.cn</span><br><span class="line">======================================================= N/S matched: gflags =======================================================</span><br><span class="line">gflags-devel.x86_64 : Development files for gflags</span><br><span class="line">gflags.x86_64 : Library for commandline flag processing</span><br></pre></td></tr></table></figure></p>
<p>因此，直接使用 <code>yum install gflags gflags-devel</code></p>
<p>然后去编译 <code>Guetzli</code> ，出现下面的错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">==== Building guetzli (release) ==== </span><br><span class="line">guetzli.cc &lt;命令行&gt;:0:18: 错误：‘google’不是一个命名空间名 guetzli/guetzli.cc:33:17: 附注：in expansion of macro ‘GFLAGS_NAMESPACE’ using namespace GFLAGS_NAMESPACE;</span><br><span class="line">^ guetzli/guetzli.cc:33:33: 错误：expected namespace-name before ‘;’ token using namespace GFLAGS_NAMESPACE; </span><br><span class="line">^ guetzli/guetzli.cc: 在函数‘int main(int, char**)’中: guetzli/guetzli.cc:194:55: 错误：‘SetUsageMessage’在此作用域中尚未声明 &quot;guetzli [flags] input_filename output_filename&quot;); </span><br><span class="line">^ guetzli/guetzli.cc:194:55: 附注：建议的替代： In file included from guetzli/guetzli.cc:24:0: /usr/include/gflags/gflags.h:331:29: 附注： ‘gflags::SetUsageMessage’ extern GFLAGS_DLL_DECL void SetUsageMessage(const std::string&amp; usage); </span><br><span class="line">^ guetzli/guetzli.cc:195:43: 错误：‘ParseCommandLineFlags’在此作用域中尚未声明 ParseCommandLineFlags(&amp;argc, &amp;argv, true); </span><br><span class="line">^ guetzli/guetzli.cc:195:43: 附注：建议的替代： In file included from guetzli/guetzli.cc:24:0: /usr/include/gflags/gflags.h:346:31: 附注： ‘gflags::ParseCommandLineFlags’ extern GFLAGS_DLL_DECL uint32 ParseCommandLineFlags(int argc, char** argv, bool remove_flags); </span><br><span class="line">^ guetzli/guetzli.cc:198:31: 错误：‘ShowUsageWithFlags’在此作用域中尚未声明 ShowUsageWithFlags(argv[0]); </span><br><span class="line">^ guetzli/guetzli.cc:198:31: 附注：建议的替代： In file included from guetzli/guetzli.cc:24:0: /usr/include/gflags/gflags.h:175:29: 附注： ‘gflags::ShowUsageWithFlags’ extern GFLAGS_DLL_DECL void ShowUsageWithFlags(const char *argv0); </span><br><span class="line">// what --help does </span><br><span class="line">^ make[1]: *** [obj/Release/guetzli.o] 错误 1 </span><br><span class="line">make: *** [guetzli] 错误 2</span><br></pre></td></tr></table></figure></p>
<p>错误中出现了多处 <strong>xx在此作用域中尚未声明</strong> 对应的 c++ 文件刚好是:<code>gflags.h</code></p>
<p>因此我猜测，可能是版本不对。通过 <code>yum info gflags</code> 确认一下当前的版本信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">名称    ：gflags</span><br><span class="line">架构    ：x86_64</span><br><span class="line">版本    ：2.1.1</span><br><span class="line">发布    ：6.el7</span><br><span class="line">大小    ：72 k</span><br><span class="line">源    ：epel/x86_64</span><br><span class="line">简介    ： Library for commandline flag processing</span><br><span class="line">网址    ：http://code.google.com/p/gflags</span><br><span class="line">协议    ： BSD</span><br></pre></td></tr></table></figure></p>
<p>是2.1版本。因为我mac上的 <code>Guetzli</code> 是可以运行的，因此查看一下mac上的 <code>gflags</code> 版本，得到如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gflags: stable 2.2.0 (bottled)</span><br><span class="line">Library for processing command-line flags</span><br></pre></td></tr></table></figure>
<p>ok，两者之间差了一个小版本。在 <a href="https://github.com/gflags/gflags" target="_blank" rel="external">gflags github</a> 查看发布的 <strong>release</strong> 版本。看到了最新的 2.2.0 版本。然后看到其对应的描述：</p>
<blockquote>
<p>This release adds support for use of the gflags library as external dependency not only in projects using CMake, but also Bazel, or pkg-config. </p>
</blockquote>
<p>我想，不管怎么样，先试试呗。</p>
<h1 id="正确安装-gflags-新版本"><a href="#正确安装-gflags-新版本" class="headerlink" title="正确安装 gflags 新版本"></a>正确安装 gflags 新版本</h1><p>由于 epel 还没有最新的源，只能自己动手编译了。<a href="https://github.com/gflags/gflags/blob/master/INSTALL.md" target="_blank" rel="external">官方编译指南</a></p>
<p><em>ps: Debian/Ubuntu Linux 可以直接使用 apt-get 来安装，但是好像有些版本也会出现版本问题，也可以动手自己编译最新的版本</em></p>
<p>由于 <code>gflags</code> 需要 <code>ccmake</code> 编译。所以需要先安装 cmake (安装 cmake 后，就可以使用 <code>ccmake</code>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install cmake</span><br></pre></td></tr></table></figure></p>
<p>好，搞定 <code>cmake</code> ，接下来开始 <code>gflags</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@play ~]# wget https://github.com/gflags/gflags/archive/v2.2.0.tar.gz</span><br><span class="line">[root@play ~]# tar -zxvf v2.2.0.tar.gz</span><br><span class="line">[root@play ~]# cd gflags</span><br><span class="line">[root@play ~]# mkdir build &amp;&amp; cd build</span><br><span class="line">[root@play ~]# ccmake ..</span><br></pre></td></tr></table></figure></p>
<p>这时会有一个界面，用来生成 configuration files，这里需要特别说明一下，建议大家进入界面后，一直按<code>c</code>，选项不明白的都不要设置，知道出现一个<code>g</code> 的时候，请 press g，截个图<br><img src="http://ol59nqr1i.bkt.clouddn.com/gflags-config.jpeg" alt="image"></p>
<p>接着来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@play ~]# make</span><br><span class="line">[root@play ~]# make install</span><br></pre></td></tr></table></figure></p>
<p>ok，现在安装好了gflags，如果编译过程中还有其他错误，应该是少了一些支持的 lib，根据错误去查一查。</p>
<h1 id="Guetzli安装"><a href="#Guetzli安装" class="headerlink" title="Guetzli安装"></a>Guetzli安装</h1><p>前面都是为了安装它而做的准备工作，接下来就来完成它的编译，so easy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@play ~]# git clone https://github.com/google/guetzli.git</span><br><span class="line">[root@play ~]# make</span><br></pre></td></tr></table></figure>
<p>然后会在目录中生成一个文件</p>
<blockquote>
<p>guetzli/bin/Release/guetzli</p>
</blockquote>
<p>将命令移动到自己的命令环境中，就可以使用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@play ~]# guetzli</span><br><span class="line">guetzli: Guetzli JPEG compressor. Usage:</span><br><span class="line">guetzli [flags] input_filename output_filename</span><br><span class="line"></span><br><span class="line">xxxxxx</span><br><span class="line"></span><br><span class="line">  Flags from guetzli/guetzli.cc:</span><br><span class="line">    -quality (Visual quality to aim for, expressed as a JPEG quality value.)</span><br><span class="line">      type: double default: 95</span><br><span class="line">    -verbose (Print a verbose trace of all attempts to standard output.)</span><br><span class="line">      type: bool default: false</span><br></pre></td></tr></table></figure></p>
<p>然后大家可是试一试压缩效果。后续会有文章介绍它的压缩效果，以及php中使用它。请持续关注。</p>
<h1 id="我要吐槽"><a href="#我要吐槽" class="headerlink" title="我要吐槽"></a>我要吐槽</h1><p>当我费劲心思解决这个问题后，作者 <code>robryk</code> 在issue 中告诉我，最新的代码已经把 gflags 依赖给移除了。因为出现相关问题的人太多了。详情</p>
<ul>
<li><a href="https://github.com/google/guetzli/pull/97" target="_blank" rel="external">https://github.com/google/guetzli/pull/97</a></li>
<li><a href="https://github.com/google/guetzli/issues/89" target="_blank" rel="external">https://github.com/google/guetzli/issues/89</a></li>
</ul>
<p>如果直接下载的是 <code>guetzli</code> 当前最新的代码(git clone <a href="https://github.com/google/guetzli.git)。" target="_blank" rel="external">https://github.com/google/guetzli.git)。</a></p>
<p>将不再需要 <code>gflags</code> 包了。只需要用 <code>yum install libpng-devel</code> 就好</p>
<p>然后编译 <code>guetzli</code> ，进入目录，直接 <code>make</code> 就可得到正确结果。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：接入支付宝当面付（扫码支付与条码支付）教程]]></title>
      <url>http://dayutalk.cn/2017/03/15/Payment%EF%BC%9A%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E5%BD%93%E9%9D%A2%E4%BB%98%EF%BC%88%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98%E4%B8%8E%E6%9D%A1%E7%A0%81%E6%94%AF%E4%BB%98%EF%BC%89%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>越写越觉得支付类的文档写这么细，会不会反而让大家觉得很复杂呀？其实都是同样的调用方式</p>
<p>这一篇，将把支付宝剩下的扫码支付与条码支付全部写清楚。<br><a id="more"></a></p>
<p><strong><code>Payment 3.0</code></strong> 支付宝的配置设置文档请 <a href="https://helei112g.github.io/2017/03/09/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B/" target="_blank" rel="external">点击这里</a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>支付宝的当面付，包括扫码支付与条码支付。</p>
<ul>
<li>扫码支付，是消费者用手机去扫商家生成的二维码。个人觉得也可以将这个功能用在pc支付上。取代即时到账接口。</li>
<li>条码支付，商家用扫码枪读取用户支付宝上的条码。对应微信的刷卡支付。该项广泛用在超市结账时。</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>body</td>
<td>boolean</td>
<td>是</td>
<td>商品描述</td>
</tr>
<tr>
<td>subject</td>
<td>string</td>
<td>是</td>
<td>商品名称,该参数最长为128个汉字</td>
</tr>
<tr>
<td>order_no</td>
<td>string</td>
<td>是</td>
<td>商户网站唯一订单号</td>
</tr>
<tr>
<td>timeout_express</td>
<td>string</td>
<td>是</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。</td>
</tr>
<tr>
<td>amount</td>
<td>float</td>
<td>是</td>
<td>该笔订单的资金总额，单位为RMB-Yuan</td>
</tr>
<tr>
<td>store_id</td>
<td>string</td>
<td>否</td>
<td>商户门店编号 </td>
</tr>
<tr>
<td>operator_id</td>
<td>string</td>
<td>否</td>
<td>商户操作员编号</td>
</tr>
<tr>
<td>terminal_id</td>
<td>string</td>
<td>否</td>
<td>商户机具终端编号</td>
</tr>
<tr>
<td>alipay_store_id</td>
<td>string</td>
<td>否</td>
<td>支付宝店铺的门店ID</td>
</tr>
<tr>
<td>scene</td>
<td>string</td>
<td>是</td>
<td>条码支付时，必须设置</td>
</tr>
<tr>
<td>auth_code</td>
<td>string</td>
<td>是</td>
<td>条码支付时，必须设置</td>
</tr>
</tbody>
</table>
<p><strong><code>body</code></strong> 主要是对商品的描述，根据自己的业务写就好，不过不要用一些非常特殊的字符，支付宝可能会进行一些处理，导致你的结果与预期不一样</p>
<p><strong><code>subject</code></strong> 可以写一下商品名称信息，主要是方便支付宝后台对账时查看</p>
<p><strong><code>order_no</code></strong> 自己生成的订单号，每次下单的单号必须唯一。也就是说：同一个 order_no 他的其他下单数据不能发生变化，价格、名称等等。如果有变化，需要重新生成一个订单号。</p>
<p><strong><code>timeout_express</code></strong> 订单过期时间，很简单，你希望在那一刻过期，就写那个点的时间戳。只会精确到分钟</p>
<p><strong><code>amount</code></strong> 订单的金额，就是用户实际需要支付的金额。</p>
<p><strong><code>store_id</code></strong> 门店编号，这部分数据主要是支付宝为了将业务深化到线下而提供的，如果用不到，不设置就好。</p>
<p><strong><code>operator_id</code></strong> 商户操作员编号，可以不设置。</p>
<p><strong><code>terminal_id</code></strong> 商户机具终端编号，可以不设置。</p>
<p><strong><code>alipay_store_id</code></strong> 支付宝店铺的门店ID，没有的话，也可以不设置。</p>
<p><strong><code>scene</code></strong> 条码支付，必须设置该选项，条码支付，取值：bar_code 声波支付，取值：wave_code</p>
<p><strong><code>auth_code</code></strong> 条码支付必须设置。</p>
<p>在上面的参数中，除了特别说明的，其它部分，扫码支付与条码支付都需要。</p>
<p>代码调用。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Client</span>\<span class="title">Charge</span>;</span><br><span class="line"></span><br><span class="line">$config = <span class="keyword">require_once</span>(<span class="string">'./aliconfig.php'</span>);<span class="comment">// 支付宝的配置信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$channel = <span class="string">'ali_qr'</span>;<span class="comment">// ali_bar</span></span><br><span class="line">$payData = [</span><br><span class="line">    <span class="string">'body'</span> =&gt; <span class="string">'一个苹果'</span>,</span><br><span class="line">    <span class="string">'subject'</span> =&gt; <span class="string">'牛逼公司--付款吧'</span>,</span><br><span class="line">    <span class="string">'order_no'</span> =&gt; <span class="string">'NB12312355'</span>,</span><br><span class="line">    <span class="string">'timeout_express'</span> =&gt; <span class="string">'1489241888'</span>,</span><br><span class="line">    <span class="string">'amount'</span> =&gt; <span class="string">'100'</span>,</span><br><span class="line">    <span class="string">'return_param'</span> =&gt; <span class="string">'buy some'</span>,</span><br><span class="line">    <span class="string">'goods_type'</span> =&gt; <span class="number">1</span>,<span class="comment">// 默认值为1，因此也可以省略</span></span><br><span class="line">    <span class="string">'store_id'</span> =&gt; <span class="string">''</span>,<span class="comment">// 没有就不设置</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $str = Charge::run($channel, $config, $payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> htmlspecialchars($str);</span><br></pre></td></tr></table></figure>
<p>如果使用的扫码支付，  <code>$channel = &#39;ali_qr&#39;</code></p>
<p>则返回一个url。大家可以通过将返回的字符串生成一个二维码。即可进行扫码支付。</p>
<p>另外请记得，如果使用的沙箱请使用对应的沙箱支付宝来扫码。关于沙箱的介绍。<a href="https://helei112g.github.io/2017/03/12/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E6%95%99%E7%A8%8B/" target="_blank" rel="external">看这里</a></p>
<p>如果使用的条码支付，  <code>$channel = &#39;ali_bar&#39;</code></p>
<p>必须设置以下两个字段</p>
<ul>
<li>scene   支付场景 条码支付，取值：bar_code 声波支付，取值：wave_code</li>
<li>auth_code   支付授权码，也就是用户手机条码对应的值。</li>
</ul>
<p>这个接口测试时，大家可以手动把条码的值，输入进去</p>
<p>ok！支付宝支付类的接口基本就讲完了。接下来将开始讲解微信支付的接口。使用起来都一样，不一样的仅仅是参数部分。还是安排将微信支付的配置开一篇单独的文章进行讲解。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：支付宝移动支付服务端教程]]></title>
      <url>http://dayutalk.cn/2017/03/14/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>默默的写文档，为什么要写呢？因为我想要被你们点赞，被你们打赏。</p>
<a id="more"></a>
<p><strong><code>Payment 3.0</code></strong> 支付宝的配置设置文档请 <a href="https://helei112g.github.io/2017/03/09/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B/" target="_blank" rel="external">点击这里</a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>移动支付，适用场景:</p>
<blockquote>
<p>适用于商家在App应用中集成支付宝支付功能。<br>商家APP调用支付宝提供的SDK调用支付宝客户端内的支付模块，商家APP会跳转到支付宝中完成支付，支付完后跳回到商家APP内，最后展示支付结果。<br>目前支持手机系统有：iOS（苹果）、Android（安卓）。</p>
</blockquote>
<p>现在来讲服务端的部分。支持的参数如下表格。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>body</td>
<td>boolean</td>
<td>是</td>
<td>商品描述</td>
</tr>
<tr>
<td>subject</td>
<td>string</td>
<td>是</td>
<td>商品名称,该参数最长为128个汉字</td>
</tr>
<tr>
<td>order_no</td>
<td>string</td>
<td>是</td>
<td>商户网站唯一订单号</td>
</tr>
<tr>
<td>timeout_express</td>
<td>string</td>
<td>是</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。</td>
</tr>
<tr>
<td>amount</td>
<td>float</td>
<td>是</td>
<td>该笔订单的资金总额，单位为RMB-Yuan</td>
</tr>
<tr>
<td>return_param</td>
<td>string</td>
<td>是</td>
<td>公用回传参数</td>
</tr>
<tr>
<td>goods_type</td>
<td>string</td>
<td>否</td>
<td>商品主类型：0—虚拟类商品，1—实物类商品 默认为1</td>
</tr>
<tr>
<td>store_id</td>
<td>string</td>
<td>否</td>
<td>商户门店编号 </td>
</tr>
</tbody>
</table>
<p><strong><code>body</code></strong> 主要是对商品的描述，根据自己的业务写就好，不过不要用一些非常特殊的字符，支付宝可能会进行一些处理，导致你的结果与预期不一样</p>
<p><strong><code>subject</code></strong> 可以写一下商品名称信息，主要是方便支付宝后台对账时查看</p>
<p><strong><code>order_no</code></strong> 自己生成的订单号，每次下单的单号必须唯一。也就是说：同一个 order_no 他的其他下单数据不能发生变化，价格、名称等等。如果有变化，需要重新生成一个订单号。</p>
<p><strong><code>timeout_express</code></strong> 订单过期时间，很简单，你希望在那一刻过期，就写那个点的时间戳。只会精确到分钟</p>
<p><strong><code>amount</code></strong> 订单的金额，就是用户实际需要支付的金额。</p>
<p><strong><code>return_param</code></strong>  希望支付宝异步通知时，原样返回给你的数据，同样注意避免一些特殊字符</p>
<p><strong><code>goods_type</code></strong> 用来区分购买的是实际商品还是虚拟商品，虚拟商品不需要物流发货，并且 虚拟类商品不支持使用花呗渠道</p>
<p><strong><code>store_id</code></strong> 门店编号，这部分数据主要是支付宝为了将业务深化到线下而提供的，如果用不到，不设置就好。</p>
<p>代码调用。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Client</span>\<span class="title">Charge</span>;</span><br><span class="line"></span><br><span class="line">$config = <span class="keyword">require_once</span>(<span class="string">'./aliconfig.php'</span>);<span class="comment">// 支付宝的配置信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$channel = <span class="string">'ali_app'</span>;</span><br><span class="line">$payData = [</span><br><span class="line">    <span class="string">'body'</span> =&gt; <span class="string">'一个苹果'</span>,</span><br><span class="line">    <span class="string">'subject'</span> =&gt; <span class="string">'牛逼公司--付款吧'</span>,</span><br><span class="line">    <span class="string">'order_no'</span> =&gt; <span class="string">'NB12312355'</span>,</span><br><span class="line">    <span class="string">'timeout_express'</span> =&gt; <span class="string">'1489241888'</span>,</span><br><span class="line">    <span class="string">'amount'</span> =&gt; <span class="string">'100'</span>,</span><br><span class="line">    <span class="string">'return_param'</span> =&gt; <span class="string">'buy some'</span>,</span><br><span class="line">    <span class="string">'goods_type'</span> =&gt; <span class="number">1</span>,<span class="comment">// 默认值为1，因此也可以省略</span></span><br><span class="line">    <span class="string">'store_id'</span> =&gt; <span class="string">''</span>,<span class="comment">// 没有就不设置</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $str = Charge::run($channel, $config, $payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> htmlspecialchars($str);</span><br></pre></td></tr></table></figure>
<p>这里返回的是一个拼接好的字符串，客户端（IOS 或者 Android） 拿到后，就可调起支付宝进行支付。客户端如何调起，请看资料</p>
<ul>
<li><strong><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.J4lJwo&amp;treeId=204&amp;articleId=105296&amp;docType=1" target="_blank" rel="external">Andorid集成流程</a></strong></li>
</ul>
<ul>
<li><strong><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.q2sevn&amp;treeId=204&amp;articleId=105295&amp;docType=1" target="_blank" rel="external">Ios集成流程</a></strong></li>
</ul>
<p>这篇文章真的太偷懒了。完全就是把 <a href="https://helei112g.github.io/2017/03/12/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E6%95%99%E7%A8%8B/" target="_blank" rel="external">手机网站支付</a> 拷贝过来了而已。</p>
<p>唯一的差别在于  <code>$channel</code> 参数的不同。</p>
<p><code>$channel</code> 可取值：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ali_web</td>
<td>即时到账</td>
</tr>
<tr>
<td>ali_app</td>
<td>app支付（移动支付）</td>
</tr>
<tr>
<td>ali_wap</td>
<td>H5支付（手机网站支付、wap支付）</td>
</tr>
<tr>
<td>ali_qr</td>
<td>当面付中的扫码支付</td>
</tr>
<tr>
<td>ali_bar</td>
<td>当面付中的条码支付</td>
</tr>
</tbody>
</table>
<blockquote>
<p>还剩下支付宝的当面付，包括：扫码支付  条码支付  将会在下一篇全部写完。 </p>
</blockquote>
<p><a href="https://helei112g.github.io/2017/03/15/Payment%EF%BC%9A%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E5%BD%93%E9%9D%A2%E4%BB%98%EF%BC%88%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98%E4%B8%8E%E6%9D%A1%E7%A0%81%E6%94%AF%E4%BB%98%EF%BC%89%E6%95%99%E7%A8%8B/" target="_blank" rel="external">点击这里看当面付</a> 当面付包括：扫码支付  条码支付</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：支付宝手机网站支付教程]]></title>
      <url>http://dayutalk.cn/2017/03/12/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>支付宝的H5支付体验真不错（支付宝叫他手机网站支付）。</p>
<p>反观微信支付干嘛要把H5支付藏起来？而且体验还那么差。<br><a id="more"></a></p>
<p><strong><code>Payment 3.0</code></strong> 支付宝的配置设置文档请 <a href="https://helei112g.github.io/2017/03/09/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B/" target="_blank" rel="external">点击这里</a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>从本篇开始，将用支付宝的沙箱方式进行演示，在项目的 <code>payment/examples</code> 中我已经提供了我的沙箱帐号。</p>
<p>新版接口已经同时支持 RSA 与 RSA2 。更换签名方式时，注意公钥的变化，在demo中我进行了注释。</p>
<p>另外支付宝为了提升支付体验，可以将 <code>手机网站支付转Native支付</code> ，对于混合应用是非常好的体验。这部分服务器端的业务逻辑无须变动，只需要客户端更新到最新的 <a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.71N4co&amp;treeId=203&amp;articleId=106493&amp;docType=1" target="_blank" rel="external">详情地址</a></p>
<p>还是先讲手机网站支付需要设置哪些参数，后面用代码演示。代码部分大家会发现跟 <a href="https://helei112g.github.io/2017/03/11/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5%E6%95%99%E7%A8%8B/" target="_blank" rel="external"><code>即时到账</code></a> 支付的使用完全一致。他们的不同之处仅仅是下单参数的区别。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>body</td>
<td>boolean</td>
<td>是</td>
<td>商品描述</td>
</tr>
<tr>
<td>subject</td>
<td>string</td>
<td>是</td>
<td>商品名称,该参数最长为128个汉字</td>
</tr>
<tr>
<td>order_no</td>
<td>string</td>
<td>是</td>
<td>商户网站唯一订单号</td>
</tr>
<tr>
<td>timeout_express</td>
<td>string</td>
<td>是</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。</td>
</tr>
<tr>
<td>amount</td>
<td>float</td>
<td>是</td>
<td>该笔订单的资金总额，单位为RMB-Yuan</td>
</tr>
<tr>
<td>return_param</td>
<td>string</td>
<td>是</td>
<td>公用回传参数</td>
</tr>
<tr>
<td>goods_type</td>
<td>string</td>
<td>否</td>
<td>商品主类型：0—虚拟类商品，1—实物类商品 默认为1</td>
</tr>
<tr>
<td>store_id</td>
<td>string</td>
<td>否</td>
<td>商户门店编号 </td>
</tr>
</tbody>
</table>
<p><strong><code>body</code></strong> 主要是对商品的描述，根据自己的业务写就好，不过不要用一些非常特殊的字符，支付宝可能会进行一些处理，导致你的结果与预期不一样</p>
<p><strong><code>subject</code></strong> 可以写一下商品名称信息，主要是方便支付宝后台对账时查看</p>
<p><strong><code>order_no</code></strong> 自己生成的订单号，每次下单的单号必须唯一。也就是说：同一个 order_no 他的其他下单数据不能发生变化，价格、名称等等。如果有变化，需要重新生成一个订单号。</p>
<p><strong><code>timeout_express</code></strong> 订单过期时间，很简单，你希望在那一刻过期，就写那个点的时间戳。只会精确到分钟</p>
<p><strong><code>amount</code></strong> 订单的金额，就是用户实际需要支付的金额。</p>
<p><strong><code>return_param</code></strong>  希望支付宝异步通知时，原样返回给你的数据，同样注意避免一些特殊字符</p>
<p><strong><code>goods_type</code></strong> 用来区分购买的是实际商品还是虚拟商品，虚拟商品不需要物流发货，并且 虚拟类商品不支持使用花呗渠道</p>
<p><strong><code>store_id</code></strong> 门店编号，这部分数据主要是支付宝为了将业务深化到线下而提供的，如果用不到，不设置就好。</p>
<p>代码调用。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Client</span>\<span class="title">Charge</span>;</span><br><span class="line"></span><br><span class="line">$config = <span class="keyword">require_once</span>(<span class="string">'./aliconfig.php'</span>);<span class="comment">// 支付宝的配置信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$channel = <span class="string">'ali_wap'</span>;</span><br><span class="line">$payData = [</span><br><span class="line">    <span class="string">'body'</span> =&gt; <span class="string">'一个苹果'</span>,</span><br><span class="line">    <span class="string">'subject'</span> =&gt; <span class="string">'牛逼公司--付款吧'</span>,</span><br><span class="line">    <span class="string">'order_no'</span> =&gt; <span class="string">'NB12312355'</span>,</span><br><span class="line">    <span class="string">'timeout_express'</span> =&gt; <span class="string">'1489241888'</span>,</span><br><span class="line">    <span class="string">'amount'</span> =&gt; <span class="string">'100'</span>,</span><br><span class="line">    <span class="string">'return_param'</span> =&gt; <span class="string">'buy some'</span>,</span><br><span class="line">    <span class="string">'goods_type'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">    <span class="string">'store_id'</span> =&gt; <span class="string">''</span>,<span class="comment">// 没有就不设置</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $payUrl = Charge::run($channel, $config, $payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> htmlspecialchars($payUrl);</span><br></pre></td></tr></table></figure>
<p>大家在这里可以回到即时到账的部分对比一下，调用代码完全一致。唯一的差别就是 <code>payData</code> 中的些微差别。<br>多了一个 <code>store_id</code> 参数。少了另外两个参数： qr_mod   paymethod</p>
<p>后面的几种支付在调用上也是如此没有差别，变化主要时围绕 <code>payData</code> 进行的。</p>
<p>当然这里最重要的变化是：<strong><code>$channel</code></strong>  。Payment 知道使用那种支付方式，完全是根据这个参数来设置的。因此一定要设置正确。再把对应的信息贴出来。方便大家查看。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ali_web</td>
<td>即时到账</td>
</tr>
<tr>
<td>ali_app</td>
<td>app支付（移动支付）</td>
</tr>
<tr>
<td>ali_wap</td>
<td>H5支付（手机网站支付、wap支付）</td>
</tr>
<tr>
<td>ali_qr</td>
<td>当面付中的扫码支付</td>
</tr>
<tr>
<td>ali_bar</td>
<td>当面付中的条码支付</td>
</tr>
</tbody>
</table>
<p>另外这里返回的依然是一个url。大家根据自己的业务进行合理的处理。<code>htmlspecialchars()</code> 函数的目的还是为了转义，正式使用时，请注意。</p>
<p>关于异步通知部分，会有专门的文章讲解，这里暂时略过。请关注后面的文章。接下来会说到最热门的<a href="https://helei112g.github.io/2017/03/14/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%99%E7%A8%8B/" target="_blank" rel="external">移动支付</a></p>
<hr>
<p>如果你有不清楚的或者愿意交流的地方，请联系我：</p>
<p><strong>邮箱</strong>：dayugog@gmail.com</p>
<p>如果你觉得这个项目有帮助到你，请打赏我，让我有动力持续下去 <a href="#">左边微信，右边支付宝</a>：</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-wx-pay.jpg?imageView2/2/w/500" alt="image"></p>
<p><strong>ps：</strong> 一般性的问题请大家可以先查资料，如果实在无法解决找我吧（不免费服务）。</p>
<h2 id="关于沙箱"><a href="#关于沙箱" class="headerlink" title="关于沙箱"></a>关于沙箱</h2><p>对于支付宝的沙箱功能，我得再啰嗦几句。先把我配置的沙箱帐号贡献出来。方便大家测试</p>
<p><strong>商家信息</strong></p>
<ul>
<li>商家账号  naacvg9185@sandbox.com</li>
<li>商户UID   2088102169252684</li>
<li>appId     2016073100130857</li>
</ul>
<p><strong>买家信息</strong></p>
<ul>
<li>买家账号    aaqlmq0729@sandbox.com</li>
<li>登录密码    111111</li>
<li>支付密码    111111</li>
</ul>
<p>当前沙箱的买家帐号，只能使用 <code>android</code> 版本进行登陆。</p>
<blockquote>
<p>沙箱钱包只支持扫一扫、付款码、门店详情页功能，其余功能不提供</p>
</blockquote>
<p><img src="https://zos.alipayobjects.com/rmsportal/CaXHDDXkdxikcZP.png" alt="image"></p>
<p>所以大家，不要在使用我提供的沙箱帐号时，用你们真实的支付宝帐号去支付，那样子是不会成功的。沙箱的所有功能，都只能使用上面的沙箱帐号去完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：支付宝即时到账接口接入教程]]></title>
      <url>http://dayutalk.cn/2017/03/11/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>记住，如果觉得文档写得不清楚，一定要告诉我。励志写好文档为大家服务！</p>
<a id="more"></a>
<hr>
<p><strong><code>Payment 3.0</code></strong> 支付宝的配置设置文档请 <a href="https://helei112g.github.io/2017/03/09/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B/" target="_blank" rel="external">点击这里</a></p>
<p><strong>项目GitHub地址</strong>：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>支付宝从新版本开始，提供了沙箱方式，方便进行调试。但是，即时到账支付宝没有提供沙箱模式。因此大家在使用过程中，注意设置配置。</p>
<p>我在项目中提供的初始配置也不能用于测试 <strong>即时到账接口</strong>。</p>
<blockquote>
<p>即时到账属于老版本接口。不支持 RSA2 的签名方式，请设置为 RSA 签名方式。</p>
</blockquote>
<p>支付宝的支付种类比较多。先从即时到账开始吧。</p>
<p>即时到账 主要应用于网站支付。当前也可使用支付宝提供的当面付–扫码支付来完成网站支付的业务。</p>
<p>即时到账接口属于支付宝老版本接口，当前 Payment 依然将其进行了保留。后期会跟随支付宝公告进行调整。<br>即时到账的权限需要在支付宝商家平台进行签约。</p>
<p><strong>签约地址:</strong> <a href="https://b.alipay.com/order/productDetail.htm?productId=2015110218012942" target="_blank" rel="external">https://b.alipay.com/order/productDetail.htm?productId=2015110218012942</a></p>
<p>即时到账签约后，默认开通以下两个接口的权限：</p>
<ul>
<li>即时到账交易接口(create_direct_pay_by_user)</li>
<li>即时到账批量退款有密接口(refund_fastpay_by_platform_pwd)</li>
</ul>
<p>但是 <code>Payment3.x</code> 并未接入 <strong>即时到账批量退款有密接口</strong>。大家可以通过 新版退款接口发起退款操作。<br>退款操作文档，可点击这里（TODO）</p>
<p>先上 <strong>即时到账发起支付</strong> 需要的参数列表</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>body</td>
<td>boolean</td>
<td>是</td>
<td>商品描述</td>
</tr>
<tr>
<td>subject</td>
<td>string</td>
<td>是</td>
<td>商品名称,该参数最长为128个汉字</td>
</tr>
<tr>
<td>order_no</td>
<td>string</td>
<td>是</td>
<td>商户网站唯一订单号</td>
</tr>
<tr>
<td>timeout_express</td>
<td>string</td>
<td>是</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。</td>
</tr>
<tr>
<td>amount</td>
<td>float</td>
<td>是</td>
<td>该笔订单的资金总额，单位为RMB-Yuan</td>
</tr>
<tr>
<td>return_param</td>
<td>string</td>
<td>是</td>
<td>公用回传参数</td>
</tr>
<tr>
<td>qr_mod</td>
<td>string</td>
<td>否</td>
<td>扫码支付方式</td>
</tr>
<tr>
<td>paymethod</td>
<td>string</td>
<td>否</td>
<td>默认支付方式</td>
</tr>
<tr>
<td>goods_type</td>
<td>string</td>
<td>否</td>
<td>商品主类型：0—虚拟类商品，1—实物类商品 默认为1</td>
</tr>
</tbody>
</table>
<p><strong><code>body</code></strong> 主要是对商品的描述，根据自己的业务写就好，不过不要用一些非常特殊的字符，支付宝可能会进行一些处理，导致你的结果与预期不一样</p>
<p><strong><code>subject</code></strong> 可以写一下商品名称信息，主要是方便支付宝后台对账时查看</p>
<p><strong><code>order_no</code></strong> 自己生成的订单号，每次下单的单号必须唯一。也就是说：同一个 order_no 他的其他下单数据不能发生变化，价格、名称等等。如果有变化，需要重新生成一个订单号。</p>
<p><strong><code>timeout_express</code></strong> 订单过期时间，很简单，你希望在那一刻过期，就写那个点的时间戳。只会精确到分钟</p>
<p><strong><code>amount</code></strong> 订单的金额，就是用户实际需要支付的金额。</p>
<p><strong><code>return_param</code></strong>  希望支付宝异步通知时，原样返回给你的数据，同样注意避免一些特殊字符</p>
<p><strong><code>qr_mod</code></strong> 这个参数可以不设置，如果没有特殊需求建议不设置，可设置：0 1 2 3  。效果可以自己看看</p>
<p><strong><code>paymethod</code></strong> 当用户进行支付时，默认使用的付款方式。可选值：creditPay（信用支付）directPay（余额支付）</p>
<p><strong><code>goods_type</code></strong> 用来区分购买的是实际商品还是虚拟商品，虚拟商品不需要物流发货，并且 虚拟类商品不支持使用花呗渠道</p>
<hr>
<p>ok，以上就是需要发起支付的全部参数了。具体到 sdk 如何调用。看代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use Payment\Common\PayException;</span><br><span class="line">use Payment\Client\Charge;</span><br><span class="line"></span><br><span class="line">$config = require_once(&apos;./aliconfig.php&apos;);// 这里我假设大家都已经配置好了。不会的请去看配置设置文档</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$channel = &apos;ali_web&apos;;</span><br><span class="line">$payData = [</span><br><span class="line">    // 按照上表格中的信息配置一个数组</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    $payUrl = Charge::run($channel, $config, $payData);</span><br><span class="line">&#125; catch (PayException $e) &#123;</span><br><span class="line">    // 异常处理</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo htmlspecialchars($payUrl);</span><br></pre></td></tr></table></figure>
<p>即时到账的代码就全部完成了。</p>
<p><code>$payUrl</code>  是跳转向支付宝支付的一个连接。访问该连接即可跳转到支付宝。</p>
<p>接下来说下重点，请仔细往下看。</p>
<blockquote>
<p>这里需要注意的一个点： htmlspecialchars() 函数在正式环境上，如果时进行url的跳转操作，请不要用它进行转义。我这里使用它是为了方便输出到页面上。因为 &amp;not 是一个特殊符号，如果不转移，在网页上无法正常显示。</p>
</blockquote>
<p><code>Payment</code> 的设计思路是将配置文件与下单数据进行了分离。配置文件一般来讲是静态的，不会经常变更，并且大家都会用到。而下单的订单数据则不同，每一个支付接口需要的下单数据不同，并且根据业务，其对应的值也不稳定，常常发生变化。</p>
<p>其次，还有一个 <code>$channel</code> 参数，这个简单来讲，就是用来标记，你现在想要使用那种接口。可以取的参数如下：</p>
<p><em>channel可取值</em></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ali_web</td>
<td>即时到账</td>
</tr>
<tr>
<td>ali_app</td>
<td>app支付（移动支付）</td>
</tr>
<tr>
<td>ali_wap</td>
<td>H5支付（手机网站支付、wap支付）</td>
</tr>
<tr>
<td>ali_qr</td>
<td>当面付中的扫码支付</td>
</tr>
<tr>
<td>ali_bar</td>
<td>当面付中的条码支付</td>
</tr>
</tbody>
</table>
<p>接下来将说道<a href="https://helei112g.github.io/2017/03/12/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E6%95%99%E7%A8%8B/" target="_blank" rel="external">手机网站支付</a>，会给大家说到沙箱的问题</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Payment：支付宝支付配置文件设置教程]]></title>
      <url>http://dayutalk.cn/2017/03/09/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>终于把3.0版本做好了。从今天开始好好写文档，让大家做支付做的开心点。<br><a id="more"></a></p>
<p>项目GitHub地址：<a href="https://github.com/helei112g/payment" target="_blank" rel="external">https://github.com/helei112g/payment</a></p>
<p>从2016年6月payment做出来，到这一版本（3.0），坚持了快一年啦。感谢这期间给我支持（打赏与协作）的人。</p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external"><code>Payment</code></a> 主要针对支付宝支付、微信支付的接口进行了聚合。开发者无需重复集成繁琐的支付接口，使用 <a href="https://github.com/helei112g/payment" target="_blank" rel="external"><code>Payment</code></a> 就能应对所有支付场景，快速接入支付功能。</p>
<p><code>Payment</code> 针对不同支付服务商的接口，提供了统一的调用方式，并且内部将签名、验签进行了集成，使用者只需要喂数据然后拿到结果进行自己的业务即可。完全屏蔽支付宝与微信内部繁杂的细节。只要按照我的文档操作，10分钟可完成支付流程。</p>
<p>当前 <a href="https://github.com/helei112g/payment" target="_blank" rel="external"><code>Payment</code></a> 基本接入完支付宝与微信的资金相关接口。到当前为止，<code>Payment SDK</code> 主要支持功能如下：</p>
<p>支持的支付宝相关接口清单：</p>
<ul>
<li>即时到账功能（主要用于pc上支付）</li>
<li>手机网站支付（WAP支付）</li>
<li>APP支付（移动支付）</li>
<li>当面付（扫码支付与条码支付）</li>
<li>交易查询（支付订单查询接口）</li>
<li>退款接口（完成支付的订单，可通过该接口完成退款）</li>
<li>退款查询接口（退款接口需要通过该接口进行查询状态）</li>
<li>单笔转账到支付宝账户接口（只能转到用户支付宝帐号）</li>
<li>转账订单查询接口（查询转账订单状态）</li>
</ul>
<p><em>ps：</em> 支付宝接口从 payment 3.0 开始，仅支持支付宝新版本接口。</p>
<p>支持的微信支付相关接口清单：</p>
<ul>
<li>手机网站支付（H5支付，特殊商家可用）</li>
<li>APP支付（移动支付）</li>
<li>公众号支付</li>
<li>刷卡支付（类似支付宝的条码支付）</li>
<li>小程序支付</li>
<li>交易查询（支付订单查询）</li>
<li>申请退款接口</li>
<li>查询退款接口</li>
<li>企业付款给个人接口</li>
<li>查询企业付款接口</li>
</ul>
<p>微信最糟糕的就是，不同支付接口，需要申请不同的商户号。这里简单总结一下：</p>
<p><strong>APP支付</strong>  必须到 微信开放平台申请一个应用，然后去申请开通支付功能，申请的商户帐号无法用于 公众号支付与小程序支付。</p>
<p><strong>公众号支付</strong> 必须首先有一个认证的服务号，然后到公众号后台进行申请开通支付功能。又会获得一个商户号</p>
<p><strong>小程序支付</strong> 微信分配的小程序ID，所以恭喜你，你又有了一个商户号</p>
<p>至于其他支付，目前检测好像可用共享。也就只剩下一个刷卡支付了。</p>
<hr>
<p>本文主要讲解支付宝的配置文件，配置清单如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'use_sandbox'</span>           =&gt; <span class="keyword">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'partner'</span>               =&gt; <span class="string">'2088102169252684'</span>,</span><br><span class="line">    <span class="string">'app_id'</span>                =&gt; <span class="string">'2016073100130857'</span>,</span><br><span class="line">    <span class="string">'sign_type'</span>             =&gt; <span class="string">'RSA2'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'ali_public_key'</span>        =&gt; <span class="string">'MIIBIjANBgkqhkiG9w0BAQEFAAOCAU3GYXkAaumdWQt7IDAQAB'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>       =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'rsa_private_key.pem'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'limit_pay'</span>             =&gt; [</span><br><span class="line">        <span class="comment">//'balance',</span></span><br><span class="line">        <span class="comment">//'moneyFund',</span></span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>            =&gt; <span class="string">'https://helei112g.github.io/'</span>,</span><br><span class="line">    <span class="string">'return_url'</span>            =&gt; <span class="string">'https://helei112g.github.io/'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'return_raw'</span>            =&gt; <span class="keyword">false</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>在支付中最麻烦的就是配置密钥。这里逐一为大家说明每一个配置的含义、以及如何进行设置。<br>其中 <strong>是否必须</strong> 列表中如果标记为 <code>是</code>  ，则该项必须设置，否则sdk将无法得到结果。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>use_sandbox</td>
<td>boolean</td>
<td>否</td>
<td>是否开启沙箱模式</td>
</tr>
<tr>
<td>partner</td>
<td>string</td>
<td>是</td>
<td>商户UID，以2088开头</td>
</tr>
<tr>
<td>app_id</td>
<td>string</td>
<td>是</td>
<td>支付宝分配给开发者的应用ID</td>
</tr>
<tr>
<td>sign_type</td>
<td>string</td>
<td>是</td>
<td>签名方式</td>
</tr>
<tr>
<td>ali_public_key</td>
<td>string</td>
<td>是</td>
<td>支付宝公钥</td>
</tr>
<tr>
<td>rsa_private_key</td>
<td>string</td>
<td>是</td>
<td>用户应用私钥</td>
</tr>
<tr>
<td>limit_pay</td>
<td>string</td>
<td>否</td>
<td>限制的支付方式</td>
</tr>
<tr>
<td>notify_url</td>
<td>string</td>
<td>是</td>
<td>支付宝异步通知的服务器地址</td>
</tr>
<tr>
<td>return_url</td>
<td>string</td>
<td>否</td>
<td>支付报支付成功返回地址</td>
</tr>
<tr>
<td>return_raw</td>
<td>boolean</td>
<td>否</td>
<td>是否返回支付宝原始数据</td>
</tr>
</tbody>
</table>
<p>接下来对每一个参数详细说明，不同的设置带来的不同效果。</p>
<p><strong><code>use_sandbox</code></strong> 支付宝新版本提供了沙箱模式。如果该选项设置为 <code>true</code> 则使用支付宝的沙箱功能。<br>下面简单介绍沙箱的使用方式。</p>
<p>首先登陆 <a href="https://open.alipay.com" target="_blank" rel="external">蚂蚁金服开放平台</a> 按照下图找到自己的沙箱应用。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-sanbox.jpeg?imageView2/2/w/600" alt="image"></p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-sandbox-info.jpeg?imageView2/2/w/600" alt="image"></p>
<p>大家注意截图，重要的配置信息均来自这里。</p>
<p><strong><code>partner</code></strong> 对应图中的 商户UID，如果是正式应用，可用在【我的应用】=》【应用】中找到对应的信息。<br>这部分信息较敏感，就不截图了。</p>
<p><strong><code>app_id</code></strong> 就是对应的创建的应用的id。图中有很醒目的字标记。</p>
<p><strong><code>sign_type</code></strong> 请求支付时，数据加密的方式，目前支持RSA2和RSA，推荐使用RSA2。你完全不用管签名的实现，只需要这里做一下配置就好。</p>
<p>接下来，密钥的配置是重点，70% 的支付无法成功的原因，均是密钥设置问题。<br>关于密钥如何生成与配置，请看</p>
<p><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.XduKK8&amp;treeId=291&amp;articleId=106103&amp;docType=1" target="_blank" rel="external">支付宝官方密钥生成与配置教程</a></p>
<p><strong><code>ali_public_key</code></strong>  注意看这张图的红线部分，只要上传自己应用的公钥后，可用点这里，查看支付宝公钥，可获取到支付宝的公钥。</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-sandbox-info.jpeg?imageView2/2/w/600" alt="image"></p>
<p>这里一定要记得是 <strong>支付宝的公钥</strong>，不是你自己本地生成的，而是在开发平台中上传自己的公钥后，拿到的支付宝公钥。</p>
<p>接下来就是这个配置该如何填写了。这里支持文件的方式，你可以将支付宝公钥复制到一个单独的文件，然后这个字段填写对应文件的路径。例如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'ali_public_key'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'alipay_public_key_rsa.pem'</span></span><br></pre></td></tr></table></figure></p>
<p>你也可用直接将支付宝公钥的值，填入这里，例如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'ali_public_key'</span> =&gt; <span class="string">'MIIBIjANBgkqhkiG9w0BAQEFAAOO1BU3GYXkAaumdWQt7f+khoFoSw+x8yqQIDAQAB'</span>,</span><br></pre></td></tr></table></figure></p>
<p>这里为了文章排版美观，有删减部分支付宝公钥内容</p>
<p>无论那种方式，强烈建议在填入时，去掉：</p>
<blockquote>
<p>—–BEGIN PUBLIC KEY—–<br>以及  —–END PUBLIC KEY—– 只保留中间部分的内容。</p>
</blockquote>
<p><strong><code>rsa_private_key</code></strong> 商户私钥的设置，按照<a href="(https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.XduKK8&amp;treeId=291&amp;articleId=106103&amp;docType=1">上面发的教程</a>)进行操作，然后把获取到的值，复制出来。跟支付宝公钥一样，也可以单独放在一个文件里，然后引用他的路径，或者直接将它的值，设置在这个字段上。</p>
<p>请记得只保留密钥内容部分。</p>
<p>这里请一定分清楚 <strong>私钥，是商户自己生成的</strong>。  <strong>公钥，是支付宝开发平台看到的</strong></p>
<p><strong><code>limit_pay</code></strong> 在让用户使用支付宝支付过程中，可能想禁止用户使用某些渠道，比如：不准使用 信用卡支付  不准使用 花呗支付。都可以在这里进行配置。详细的可取值，请看图片</p>
<p><img src="http://ol59nqr1i.bkt.clouddn.com/ali-limit-pay.jpeg?imageView2/2/w/600" alt="image"></p>
<p><a href="https://doc.open.alipay.com/doc2/detail.htm?treeId=203&amp;articleId=105463&amp;docType=1#qdsm" target="_blank" rel="external">官方链接</a></p>
<p><strong><code>notify_url</code></strong> 异步通知。当支付宝支付成功后，你想要在服务端收到支付宝支付成功的通知，就必须设置该选项。应该是：http/https 开头的url。</p>
<p>这里强烈建议以支付宝服务器的通知为依据来判断是否支付成功。关于异步通知的处理，在后面的文章将有专题讲解。</p>
<p><strong><code>return_url</code></strong>  当前主要是即时到账、手机网站支付两个接口会用到，在支付成功后，跳转到哪一个链接。也必须是以 HTTP/HTTPS 开头的url。可以理解为同步通知，但请不要以它的结果为准。为了安全还是应该以异步为准。</p>
<p><strong><code>return_raw</code></strong>  之前的版本都没有该参数，是3.0新加入的，它的主要目的是让调用者控制自己拿到什么样的数据。如果设置为true。SDK 则只会向支付宝发出请求，收到数据后进行验签，通过后，会以数组的形式将所有支付宝返回的数据返回给客户端。</p>
<p>如果设置为false ，则会抛弃支付宝的某些字段。并且会对某些字段名称进行重新映射，这种方式带来的好处是，可用确保支付宝、微信返回的数据是基本一致的，但是可能导致调用者损失部分信息。这里大家根据实际情况进行衡量。</p>
<p>至此，支付宝的配置全部讲解完毕。  去看看如何完成<a href="https://helei112g.github.io/2017/03/11/Payment%EF%BC%9A%E6%94%AF%E4%BB%98%E5%AE%9D%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5%E6%95%99%E7%A8%8B/" target="_blank" rel="external">即时到账</a>吧</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP中浮点数位数截取性能大比拼]]></title>
      <url>http://dayutalk.cn/2017/02/16/PHP%E4%B8%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BD%8D%E6%95%B0%E6%88%AA%E5%8F%96%E6%80%A7%E8%83%BD%E5%A4%A7%E6%AF%94%E6%8B%BC/</url>
      <content type="html"><![CDATA[<p>本文没什么好说的，点进来看吧… …<br><a id="more"></a></p>
<p>最近工作中，在处理电商用户下单模块的时候，之前遗留系统保留的是三位小数。这里带来了一个问题：<br>如果用户的订单价格是：6.666元，那么在向支付宝或者微信发起支付时，第三方只会保留两位数，也就是用户实际付款：6.66元。</p>
<p>那么问题来了，支付成功第三方回调系统接口，在接口中的逻辑需要比对支付的金额，会发现 6.666≠6.66，然后后面的逻辑无法运行，处理失败。</p>
<p>这里引申出来的一个问题是：我们对浮点数位数保留时，该使用何种方式？</p>
<p>php中提供了很多种处理浮点数位数的方式。</p>
<ul>
<li>number_format — 以千位分隔符方式格式化一个数字</li>
<li>round — 对浮点数进行四舍五入 (通过传入第三个参数，可以控制舍、入的方式)</li>
<li>sprintf — Return a formatted string</li>
<li>bcadd — 2个任意精度数字的加法计算</li>
</ul>
<p>还有一种方式就是字符串截取，比如以前三位小数，现在只要两位，就把最后一位截去。</p>
<p>但是，这种方式千万别用，非常无耻，万一某个数据查询出来是：9999元，你把最后一位搞掉变成：999元，自己赔公司损失吧。</p>
<p>说完处理的方式，不得不提一下性能问题。这里由于 <code>round</code> 函数如果数字后面全是0的话。不能正确处理小数位数，这里就先不提.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$data = array_fill(0, 1, range(1, 100000, 1.1))[0];</span><br><span class="line"></span><br><span class="line">$start = microtime(true);</span><br><span class="line">foreach ($data as $num) &#123;</span><br><span class="line">    number_format(10000, 2, &apos;.&apos;, &apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">$end = microtime(true);</span><br><span class="line">$need = $end - $start;</span><br><span class="line">print(&quot;number_format time: &#123;$need&#125;&quot; . PHP_EOL);</span><br><span class="line"></span><br><span class="line">$start = microtime(true);</span><br><span class="line">foreach ($data as $num) &#123;</span><br><span class="line">    bcadd($num, 0, 2);</span><br><span class="line">&#125;</span><br><span class="line">$end = microtime(true);</span><br><span class="line">$need = $end - $start;</span><br><span class="line">print(&quot;bcadd time: &#123;$need&#125;&quot; . PHP_EOL);</span><br><span class="line"></span><br><span class="line">$start = microtime(true);</span><br><span class="line">foreach ($data as $num) &#123;</span><br><span class="line">    sprintf(&apos;.2%f&apos;, $num);</span><br><span class="line">&#125;</span><br><span class="line">$end = microtime(true);</span><br><span class="line">$need = $end - $start;</span><br><span class="line">print(&quot;sprintf time: &#123;$need&#125;&quot; . PHP_EOL);</span><br></pre></td></tr></table></figure>
<p>上面的代码运行，会得到以下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number_format time: 0.086385011672974</span><br><span class="line">bcadd time: 0.098035097122192</span><br><span class="line">sprintf time: 0.069508075714111</span><br></pre></td></tr></table></figure></p>
<p>所以通过对比，推荐使用 <code>sprintf</code> 来处理浮点数位数的问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swoole入门指南：PHP7安装Swoole详细教程（一）]]></title>
      <url>http://dayutalk.cn/2017/02/08/Swoole%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9APHP7%E5%AE%89%E8%A3%85Swoole%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>本教程一步步深入swoole，通过demo讲解它的学习与使用方法。<br><a id="more"></a></p>
<p>好久未更新了，不是懒呃，是太忙啦！终于偷得浮生几日闲。<br>这一段时间准备为大家带来swoole的入门教程，感受一下php的nodeJs强悍之处。</p>
<p>所有的示例代码均放在了github上：<a href="https://github.com/helei112g/learn-swoole" target="_blank" rel="external">learn-swoole</a></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>这里不在使用apache做为web server。该用nginx + php-fpm，性能更强大，配置更方便。并且为了跟上php的步伐，也使用了比较新的php版本</p>
<ul>
<li>[x] centos7</li>
<li>[x] php7.0.12</li>
<li>[x] nginx/1.10.2</li>
<li>[x] php-fpm</li>
</ul>
<h1 id="下载-swoole"><a href="#下载-swoole" class="headerlink" title="下载 swoole"></a>下载 swoole</h1><p>首先下载swoole的源码包，这个操作很简单，没有太多说的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://github.com/swoole/swoole-src/archive/v2.0.6.tar.gz</span><br><span class="line"></span><br><span class="line">解压: tar -zxvf v2.0.6.tar.gz</span><br><span class="line"></span><br><span class="line">cd swoole-src-2.0.6/</span><br></pre></td></tr></table></figure></p>
<h1 id="编译-amp-安装"><a href="#编译-amp-安装" class="headerlink" title="编译&amp;安装"></a>编译&amp;安装</h1><p>使用phpize来生成php编译配置</p>
<p><em>./configure</em> 来做编译配置检测</p>
<p>make进行编译，make install进行安装</p>
<p>命令执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 swoole-src-2.0.6]# phpize</span><br><span class="line">[root@php7 swoole-src-2.0.6]# ./configure</span><br><span class="line">[root@php7 swoole-src-2.0.6]# make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>make install后，如果正确，会出现以下内容<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 swoole-src-2.0.6]# make install</span><br><span class="line">Installing shared extensions:     /usr/lib64/php/modules/</span><br></pre></td></tr></table></figure></p>
<p>这表示，在 <code>/usr/lib64/php/modules/</code> 目录中，成功生成了 <code>swoole.so</code> 文件</p>
<h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>要能够使用该模块，还需要在 <code>php.ini</code> 文件中添加该模块。</p>
<p>这里需要注意，php7的模块配置文件均单独分开了。<br>在 <code>php.ini</code> 中可找到如下内容</p>
<blockquote>
<p>;;;;<br>; Note: packaged extension modules are now loaded via the .ini files<br>; found in the directory /etc/php.d; these are loaded by default.<br>;;;;</p>
</blockquote>
<p>因此，如果你的php安装时，如果未特殊设置，可以在<code>/etc/php.d</code> 目录中，找到添加模块的配置文件。</p>
<p>进入到  <em>cd /etc/php.d</em> 目录，完成相关的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 swoole-src-2.0.6]# vim swoole.ini</span><br><span class="line"></span><br><span class="line">; Enable swoole extension module</span><br><span class="line">extension=swoole.so</span><br></pre></td></tr></table></figure>
<h1 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h1><p>新增php模块后，需要重新启动服务，才会生效，如果有时候restart后依然无效，请先关闭，再重新启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 swoole-src-2.0.6]# systemctl restart nginx</span><br><span class="line">[root@php7 swoole-src-2.0.6]# systemctl restart php-fpm</span><br></pre></td></tr></table></figure>
<p>通过php -m或phpinfo()来查看是否成功加载了swoole</p>
<p><img src="https://helei112g.github.io/images/swoole-phpinfo.png" alt="image"></p>
<h1 id="swoole-代码的自动提示"><a href="#swoole-代码的自动提示" class="headerlink" title="swoole 代码的自动提示"></a>swoole 代码的自动提示</h1><p>安装好扩展后，就是使用的问题。由于没有代码的提示，有时候很不方便，github上有人已经提供了swoole代码提示的 ide-helper 。具体设置办法如下：</p>
<p>这里以： phpStorme 为例，download 代码到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:eaglewu/swoole-ide-helper.git ide-helper</span><br></pre></td></tr></table></figure></p>
<p>按照图片内容设置<br><img src="https://helei112g.github.io/images/swoole-setting.png" alt="image"></p>
<p>经过以上步骤，可以在 phpStorme 中使用swoole了。并且提供代码提示。</p>
<h1 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h1><p>所有的测试代码均放在 <a href="https://github.com/helei112g/learn-swoole" target="_blank" rel="external">这里</a></p>
<p>请将该代码 <code>clone</code> 到本地，方便观察效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:helei112g/learn-swoole.git</span><br></pre></td></tr></table></figure></p>
<p>本节所提供的代码实例 <a href="https://github.com/helei112g/learn-swoole/blob/master/demo1-serv.php" target="_blank" rel="external">demo1-serv</a></p>
<p>进入到测试代码目录，</p>
<p>然后在服务端使用 <code>telnet</code> 进行测试</p>
<hr>
<ul>
<li>首先，运行服务端的监听程序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php demo1-serv.php</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>执行这个命令后，服务器会显示： </p>
<blockquote>
<p><code>Client: Connect.</code> </p>
</blockquote>
<ul>
<li>另外开一个终端，使用 <code>telnet</code> 连接当前服务端监听的端口，并且输入一些文字，观察终端的变化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 ~]# telnet 127.0.0.1 9999</span><br><span class="line">Hi!</span><br><span class="line">Server: Hi!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里只是进行简单的模拟回复。客户端发什么，服务器就回应什么消息。<br>退出telnet，观察服务器会显示什么<br>直接关闭窗口，或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 ~]# Ctrl+]</span><br><span class="line">[root@php7 ~]# telnet&gt; quit</span><br></pre></td></tr></table></figure>
<p>此时，会在服务侧看到：</p>
<blockquote>
<p>Client: Close.</p>
</blockquote>
<p>PS：如果测试环境没有安装 <code>telnet</code> ，请自行google安装。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列五：Vagrant使用中遇到的坑]]></title>
      <url>http://dayutalk.cn/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E4%BA%94%EF%BC%9AVagrant%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>这篇文章是在windows上使用了vagrant半年后，突然切换到mac上来，遇到了各种坑，今天补了这篇文章。希望对你有帮助。</p>
<a id="more"></a>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>之前写了一系列的vagrant使用教程，当时写这个教程的时候实在windows的环境下。最近再mac上使用，遇到了一些麻烦。</p>
<p><a href="http://blog.csdn.net/hel12he/article/details/51069269" target="_blank" rel="external">原文章路径</a></p>
<p>今天最想说的一个问题就是权限的问题。</p>
<p>在windows中由于没有文件权限的概念，所有当我们共享目录后，共享目录默认就是777权限。<br>但是当我使用mac时，共享后的目录权限以及用户组都不正确了。无法正常使用。这样导致的一个直接问题就是：</p>
<blockquote>
<p>项目a运行在虚拟机中，需要向runtime目录写入日志或者临时文件之类的，总之就是需要读写权限。</p>
</blockquote>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>当时我直接ssh上vagrang后，给予777权限，无法写入，然后又在主机给予777权限，可以写入一个文件，但是下个文件又拿到权限写入。</p>
<p>后来由各种google与百度，看到说使用nfs的方式可以解决这个问题，但是各方给出的解决方案都很成旧，有的方法使用后甚至虚拟机都无法启动了。</p>
<p>没办法，老老实实上官网看nfs相关的配置吧。老实说官方给的文档真的是有点太简单抽象了，只能结合之前的一些东西结合起来使用。最终终于找到办法，这里将相关的配置贴出来，供大家参考。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">config.vm.define :php7 <span class="keyword">do</span> |p7|</span><br><span class="line">  p7.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> |v|</span><br><span class="line">        v.customize [<span class="string">"modifyvm"</span>, :id, <span class="string">"--name"</span>, <span class="string">"php6"</span>, <span class="string">"--memory"</span>, <span class="string">"512"</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 域名解析慢</span></span><br><span class="line">        v.customize [<span class="string">"modifyvm"</span>, :id, <span class="string">"--natdnshostresolver1"</span>, <span class="string">"on"</span>]</span><br><span class="line">        v.customize [<span class="string">"modifyvm"</span>, :id, <span class="string">"--natdnsproxy1"</span>, <span class="string">"on"</span>]</span><br><span class="line">  end</span><br><span class="line">  p7.vm.box = <span class="string">"CentOs7"</span></span><br><span class="line">  p7.vm.hostname = <span class="string">"php7"</span></span><br><span class="line">  p7.vm.network :private_network, ip: <span class="string">"192.168.33.10"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ssh 奇怪：第一次启动虚拟机无法获取ip</span></span><br><span class="line">  p7.ssh.username = <span class="string">"root"</span></span><br><span class="line">  p7.ssh.password = <span class="string">"vagrant"</span></span><br><span class="line">  p7.ssh.host = <span class="string">"192.168.33.11"</span></span><br><span class="line">  p7.ssh.port = <span class="number">22</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">## nfs文件权限问题  启动了好几次才正常，不知道原因</span></span><br><span class="line">  p7.vm.synced_folder <span class="string">"./www"</span>, <span class="string">"/data/wwwroot"</span>, type: <span class="string">"nfs"</span>, :nfs =&gt; &#123;</span><br><span class="line">    :linux_nfs_options =&gt; [<span class="string">"not_root_squash"</span>],</span><br><span class="line">    :map_uid =&gt; <span class="number">0</span>,</span><br><span class="line">    :map_gid =&gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这个配置是在一个 <code>Vagrantfile</code> 中配置多台机器的配置文档。其中遇到的一些奇怪问题，注释中都标明了。</p>
<ul>
<li>配置的ip地址，首次使用 <code>vagrant up php7</code> 后，无效，需要重新启动，虚拟机才能拿到这个ip。至今不懂为什么，麻烦知道的告诉我一下啊！</li>
<li>nfs配置信息全面解决了权限问题。你需要给出什么权限直接在 vagrang 虚拟机中进行设置。但是在挂载目录时，有时候配置的新机器会莫名其妙重新启动好几次才可以。我启动了三次。</li>
<li><p>另一个坑是，新机器安装后，需要配置dns解析。否则有的资源是无法下载的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/resolv.conf</span><br><span class="line"></span><br><span class="line">## 增加以下内容</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于配置了启动时使用 <code>root</code> 帐号，需要每次在mac上启动的时候输入机器密码，很麻烦，官方指导配置 <code>/etc/sudoers</code> 如下内容</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cmnd_Alias VAGRANT_EXPORTS_ADD = /usr/bin/tee -a /etc/exports</span><br><span class="line">Cmnd_Alias VAGRANT_NFSD = /sbin/nfsd restart</span><br><span class="line">Cmnd_Alias VAGRANT_EXPORTS_REMOVE = /usr/bin/sed -E -e /*/ d -ibak /etc/exports</span><br><span class="line">%admin ALL=(root) NOPASSWD: VAGRANT_EXPORTS_ADD, VAGRANT_NFSD, VAGRANT_EXPORTS_REMOVE</span><br></pre></td></tr></table></figure>
<p><em>该配置仅针对mac</em></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这类问题还是蛮常见，对于使用很久的用户，轻松解决了，但是对于大多数使用vagrant的新手，这个问题很头痛，可能直接导致放弃使用vagrant吧。为了不让你放弃，我必须写出来帮助大家渡过这道坑。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列四：Vagrant搭建redis与redis的监控程序redis-stat]]></title>
      <url>http://dayutalk.cn/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E5%9B%9B%EF%BC%9AVagrant%E6%90%AD%E5%BB%BAredis%E4%B8%8Eredis%E7%9A%84%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8Fredis-stat/</url>
      <content type="html"><![CDATA[<p>redis经常会被用到<br><a id="more"></a></p>
<p><strong>重要提示，从3.2版本后，redis需要设置密码才能够被外部网络访问。</strong><br>所以如果你发现可以链接上redis，但是无法写入或者读取那么请检查是否使用了密码方式。</p>
<h1 id="redis的安装"><a href="#redis的安装" class="headerlink" title="redis的安装"></a>redis的安装</h1><p>哎，写到这儿，说一句，诅咒联通这网络，联通网络一上，打开vpn，照样不能访问外网，联baidu都一卡一卡的。</p>
<p>redis就不用yum来进行安装了。直接从官方下载来安装吧。(老实说，我也不知道yum里边有没有redis的最新版)</p>
<h2 id="下载redis"><a href="#下载redis" class="headerlink" title="下载redis"></a>下载redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c http://download.redis.io/releases/redis-3.0.7.tar.gz</span><br></pre></td></tr></table></figure>
<p>当然你也可以到<a href="http://redis.io/download" target="_blank" rel="external">redis官网</a> 下载最新的版本。当然个人建议，开发中还是使用稳定版本吧！<br><img src="http://img.blog.csdn.net/20160412233549976" alt="这里写图片描述"></p>
<h2 id="解压redis"><a href="#解压redis" class="headerlink" title="解压redis"></a>解压redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf redis-3.0.7.tar.gz</span><br></pre></td></tr></table></figure>
<p>这个命令什么意思，我就不多说了，如果不清楚的同学，建议平时还是多积累点linux的命令知识额。加薪升职的利器额。<br><img src="http://img.blog.csdn.net/20160412233743743" alt="这里写图片描述"></p>
<h2 id="编译安装redis"><a href="#编译安装redis" class="headerlink" title="编译安装redis"></a>编译安装redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd redis-3.0.7</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>进入到解压后的目录，然后执行编译，然后安装。</p>
<p><img src="http://img.blog.csdn.net/20160412233953683" alt="这里写图片描述"></p>
<p>OK，至此，我们的redis安装还没有完额，其实好玩儿的才刚刚开始呢。</p>
<h2 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h2><p>创建redis 配置文件夹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$　mkdir /etc/redis</span><br></pre></td></tr></table></figure></p>
<p>在/var/lib/redis 下创建有效的保存数据的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$　mkdir -p /var/lib/redis/6379</span><br></pre></td></tr></table></figure></p>
<p>redis.conf 是 redis 的配置文件，然而你会看到我们会把这个文件的名字改为 6379.conf ，而这个数字就是 redis 监听的网络端口。如果你想要运行超过一个的 redis 实例，推荐用这样的名字。</p>
<p>复制示例的 redis.conf 到 /etc/redis/6379.conf。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure></p>
<p>修改的内容如下：</p>
<blockquote>
<p>设置 daemonize 为 no，systemd 需要它运行在前台，否则 redis 会突然挂掉。<br>daemonize yes</p>
<p>设置 pidfile 为 /var/run/redis_6379.pid。<br>pidfile /var/run/redis_6379.pid</p>
<p>如果不准备用默认端口，可以修改。<br>port 6379</p>
<p>设置日志级别。<br>loglevel debug</p>
<p>修改日志文件路径。<br>logfile /var/log/redis_6379.log</p>
<p>设置目录为 /var/lib/redis/6379<br>dir /var/lib/redis/6379</p>
</blockquote>
<p>redis配置文件，各项的详解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line">######################### 通用 #########################</span><br><span class="line"></span><br><span class="line"># 启动后台进程</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># 后台进程的pid文件存储位置</span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"></span><br><span class="line"># 默认监听端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 在高并发的环境中，为避免慢客户端的连接问题，需要设置一个高速后台日志</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"># 只接受以下绑定的IP请求</span><br><span class="line"># Examples:</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 设置unix监听，默认为空</span><br><span class="line"># unixsocket /tmp/redis.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line">#客户端空闲多长时间，关闭链接，0表示不关闭</span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"># TCP keepalive.</span><br><span class="line"># 如果是非零值，当失去链接时，会使用SO_KEEPALIVE发送TCP ACKs 到客户端。</span><br><span class="line"># 这个参数有两个作用:</span><br><span class="line"># 1.检测断点。</span><br><span class="line"># 2.从网络中间设备来看，就是保持链接</span><br><span class="line"># 在Linux上，设定的时间就是发送ACKs的周期。</span><br><span class="line"># 注意：达到双倍的设定时间才会关闭链接。在其他内核上，周期依赖于内核设置。</span><br><span class="line"># 一个比较合理的值为60s</span><br><span class="line">tcp-keepalive 0</span><br><span class="line"></span><br><span class="line"># 指定日志级别，以下记录信息依次递减</span><br><span class="line"># debug用于开发/测试</span><br><span class="line"># verbose没debug那么详细</span><br><span class="line"># notice适用于生产线</span><br><span class="line"># warning只记录非常重要的信息</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">#日志文件名称，如果为stdout则输出到标准输出端，如果是以后台进程运行则不产生日志</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 要想启用系统日志记录器，设置一下选项为yes</span><br><span class="line"># syslog-enabled no</span><br><span class="line"></span><br><span class="line"># 指明syslog身份</span><br><span class="line"># syslog-ident redis</span><br><span class="line"></span><br><span class="line"># 指明syslog设备。必须是一个用户或者是local0 ~ local7之一</span><br><span class="line"># syslog-facility local0</span><br><span class="line"></span><br><span class="line">#设置数据库数目，第一个数据库编号为：0</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line">######################### 快照 #########################</span><br><span class="line"></span><br><span class="line"># 在什么条件下保存数据库到磁盘，条件可以有很多个，满足任何一个条件都会进行快照存储</span><br><span class="line"># 在900秒之内有一次key的变化</span><br><span class="line">save 900 1</span><br><span class="line"># 在300秒之内，有10个key的变化</span><br><span class="line">save 300 10</span><br><span class="line"># 在60秒之内有10000个key变化</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 当持久化失败的时候，是否继续提供服务</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 当写入磁盘时，是否使用LZF算法压缩数据，默认为yes</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 是否添加CRC64校验到每个文件末尾--花费时间保证安全</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># 磁盘上数据库的保存名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># Redis工作目录，以上数据库保存文件和AOF日志都会写入此目录</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line">######################### 主从同步 #########################</span><br><span class="line"></span><br><span class="line"># 主从复制，当本机是slave时配置</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"># 当主机需要密码验证时候配置</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line"># 当slave和master丢失链接，或正处于同步过程中。是否响应客户端请求</span><br><span class="line"># 设置为yes表示响应</span><br><span class="line"># 设置为no，直接返回&quot;SYNC with master in progress&quot;（正在和主服务器同步中）</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># 设置slave是否为只读。</span><br><span class="line"># 注意：即使slave设置为只读，也不能令其暴露在不受信任的网络环境中</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"># 无硬盘复制功能</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># 等待多个slave一起来请求之间的间隔时间</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"># 设置slave给master发送ping的时间间隔</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"></span><br><span class="line"># 设置数据传输I/O，主机数据、ping响应超时时间，默认60s</span><br><span class="line"># 这个时间一定要比repl-ping-slave-period大，否则会不断检测到超时</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line"># 是否在SYNC后slave socket上禁用TCP_NODELAY？</span><br><span class="line"># 如果你设置为yes，Redis会使用少量TCP报文和少量带宽发送数据给slave。</span><br><span class="line"># 但是这样会在slave端出现延迟。如果使用Linux内核的默认设置，大概40毫秒。</span><br><span class="line"># 如果你设置为no，那么在slave端研究就会减少但是同步带宽要增加。</span><br><span class="line"># 默认我们是为低延迟优化的。</span><br><span class="line"># 但是如果流量特别大或者主从服务器相距比较远，设置为yes比较合理。</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"># 设置复制的后台日志大小。</span><br><span class="line"># 复制的后台日志越大， slave 断开连接及后来可能执行部分复制花的时间就越长。</span><br><span class="line"># 后台日志在至少有一个 slave 连接时，仅仅分配一次。</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line"># 在 master 不再连接 slave 后，后台日志将被释放。下面的配置定义从最后一个 slave 断开连接后需要释放的时间（秒）。</span><br><span class="line"># 0 意味着从不释放后台日志</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"># 设置slave优先级，默认为100</span><br><span class="line"># 当主服务器不能正确工作的时候，数字低的首先被提升为主服务器，但是0是禁用选择</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"># 如果少于 N 个 slave 连接，且延迟时间 &lt;=M 秒，则 master 可配置停止接受写操作。</span><br><span class="line"># 例如需要至少 3 个 slave 连接，且延迟 &lt;=10 秒的配置：</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line"># 设置 0 为禁用</span><br><span class="line"># 默认 min-slaves-to-write 为 0 （禁用）， min-slaves-max-lag 为 10</span><br><span class="line"></span><br><span class="line">######################### 安全 #########################</span><br><span class="line"></span><br><span class="line"># 设置客户端连接密码，因为Redis响应速度可以达到每秒100w次，所以密码要特别复杂</span><br><span class="line"># requirepass 1413</span><br><span class="line"></span><br><span class="line"># 命令重新命名，或者禁用。</span><br><span class="line"># 重命名命令为空字符串可以禁用一些危险命令比如：FLUSHALL删除所有数据</span><br><span class="line"># 需要注意的是，写入AOF文件或传送给slave的命令别名也许会引起一些问题</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 设置客户端连接密码，因为Redis响应速度可以达到每秒100w次，所以密码要特别复杂</span><br><span class="line">requirepass 1413</span><br><span class="line"></span><br><span class="line"># 命令重新命名，或者禁用。</span><br><span class="line"># 重命名命令为空字符串可以禁用一些危险命令比如：FLUSHALL删除所有数据</span><br><span class="line"># 需要注意的是，写入AOF文件或传送给slave的命令别名也许会引起一些问题</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line"></span><br><span class="line">######################### 限制 #########################</span><br><span class="line"></span><br><span class="line"># 设置最多链接客户端数量，默认为10000。</span><br><span class="line"># 实际可以接受的请求数目为设置值减去32，这32是Redis为内部文件描述符保留的</span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line"># 设置最多链接客户端数量，默认为10000。</span><br><span class="line"># 实际可以接受的请求数目为设置值减去32，这32是Redis为内部文件描述符保留的</span><br><span class="line"># maxclients 10000</span><br><span class="line"># 设置最大使用内存数量，在把Redis当作LRU缓存时特别有用。</span><br><span class="line"># 设置的值要比系统能使用的值要小</span><br><span class="line"># 因为当启用删除算法时，slave输出缓存也要占用内存</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line">#达到最大内存限制时，使用何种删除算法</span><br><span class="line"># volatile-lru  使用LRU算法移除带有过期标致的key</span><br><span class="line"># allkeys-lru -&gt; 使用LRU算法移除任何key</span><br><span class="line"># volatile-random -&gt; 随机移除一个带有过期标致的key</span><br><span class="line"># allkeys-random -&gt;  随机移除一个key</span><br><span class="line"># volatile-ttl -&gt; 移除最近要过期的key</span><br><span class="line"># noeviction -&gt; 不删除key，当有写请求时，返回错误</span><br><span class="line">#默认设置为volatile-lru</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line"># LRU和最小TTL算法没有精确的实现</span><br><span class="line"># 为了节省内存只在一个样本范围内选择一个最近最少使用的key，可以设置这个样本大小</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br><span class="line">######################### AO模式 #########################</span><br><span class="line"></span><br><span class="line"># AOF和RDB持久化可以同时启用</span><br><span class="line"># Redis启动时候会读取AOF文件，AOF文件有更好的持久化保证</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># AOF的保存名称，默认为appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 设置何时写入追加日志，又三种模式</span><br><span class="line"># no：表示由操作系统决定何时写入。性能最好，但可靠性最低</span><br><span class="line"># everysec：表示每秒执行一次写入。折中方案，推荐</span><br><span class="line"># always：表示每次都写入磁盘。性能最差，比上面的安全一些</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># 当AOF同步策略设定为alway或everysec</span><br><span class="line"># 当后台存储进程（后台存储或者AOF日志后台写入）会产生很多磁盘开销</span><br><span class="line"># 某些Linux配置会使Redis因为fsync()调用产生阻塞很久</span><br><span class="line"># 现在还没有修复补丁，甚至使用不同线程进行fsync都会阻塞我们的同步write(2)调用。</span><br><span class="line"># 为了缓解这个问题，使用以下选项在一个BGSAVE或BGREWRITEAOF运行的时候</span><br><span class="line"># 可以阻止fsync()在主程序中被调用，</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># AOF自动重写（合并命令，减少日志大小）</span><br><span class="line"># 当AOF日志大小增加到一个特定比率，Redis调用BGREWRITEAOF自动重写日志文件</span><br><span class="line"># 原理：Redis 会记录上次重写后AOF文件的文件大小。</span><br><span class="line"># 如果刚启动，则记录启动时AOF大小</span><br><span class="line"># 这个基本大小会用来和当前大小比较。如果当前大小比特定比率大，就会触发重写。</span><br><span class="line"># 你也需要指定一个AOF需要被重写的最小值，这样会避免达到了比率。</span><br><span class="line"># 但是AOF文件还很小的情况下重写AOF文件。</span><br><span class="line"># 设置为0禁用自动重写</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">#redis在启动时可以加载被截断的AOF文件，而不需要先执行 redis-check-aof 工具</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line">######################### LUA脚本 #########################</span><br><span class="line"></span><br><span class="line"># Lua脚本的最大执行时间，单位毫秒</span><br><span class="line"># 超时后会报错，并且计入日志</span><br><span class="line"># 当一个脚本运行时间超过了最大执行时间</span><br><span class="line"># 只有SCRIPT KILL和 SHUTDOWN NOSAVE两个命令可以使用。</span><br><span class="line"># SCRIPT KILL用于停止没有调用写命令的脚本。</span><br><span class="line"># SHUTDOWN NOSAVE是唯一的一个，在脚本的写命令正在执行</span><br><span class="line"># 用户又不想等待脚本的正常结束的情况下，关闭服务器的方法。</span><br><span class="line"># 以下选项设置为0或负数就会取消脚本执行时间限制</span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line">####################### redis集群  ########################</span><br><span class="line"></span><br><span class="line"># 是否启用集群</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># 集群配置文件</span><br><span class="line"># 集群配置变更后会自动写入改文件</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"># 节点互连超时的阀值 </span><br><span class="line"># 节点超时时间，超过该时间无法连接主要Master节点后，会停止接受查询服务 </span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"># 控制从节点FailOver相关的设置,设为0，从节点会一直尝试启动FailOver.</span><br><span class="line"># 设为正数，失联大于一定时间（factor*节点TimeOut），不再进行FailOver</span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line"># 最小从节点连接数</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line"># 默认为Yes,丢失一定比例Key后（可能Node无法连接或者挂掉），集群停止接受写操作</span><br><span class="line"># 设置为No，集群丢失Key的情况下仍提供查询服务</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line">######################### 慢查询 #########################</span><br><span class="line"></span><br><span class="line"># Redis慢查询日志记录超过设定时间的查询，且只记录执行命令的时间</span><br><span class="line"># 不记录I/O操作，比如：和客户端交互，发送回复等。</span><br><span class="line"># 时间单位为微妙，1000000微妙 = 1 秒</span><br><span class="line"># 设置为负数会禁用慢查询日志，设置为0会记录所有查询命令</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"># 日志长度没有限制，但是会消耗内存。超过日志长度后，最旧的记录会被移除</span><br><span class="line"># 使用SLOWLOG RESET命令可以回收内存</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line">######################### 延迟监测 #########################</span><br><span class="line"></span><br><span class="line"># 系统只记录超过设定值的操作，单位是毫秒，0表示禁用该功能  </span><br><span class="line"># 可以通过命令“CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;” 直接设置而不需要重启redis  </span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line">######################### 事件通知 #########################</span><br><span class="line">#  当事件发生时， Redis 可以通知 Pub/Sub 客户端。</span><br><span class="line">#  可以在下表中选择 Redis 要通知的事件类型。事件类型由单个字符来标识：</span><br><span class="line"># K     Keyspace 事件，以 _keyspace@&lt;db&gt;_ 的前缀方式发布</span><br><span class="line"># E     Keyevent 事件，以 _keysevent@&lt;db&gt;_ 的前缀方式发布</span><br><span class="line"># g     通用事件（不指定类型），像 DEL, EXPIRE, RENAME, …</span><br><span class="line"># $     String 命令</span><br><span class="line"># s     Set 命令</span><br><span class="line"># h     Hash 命令</span><br><span class="line"># z     有序集合命令</span><br><span class="line"># x     过期事件（每次 key 过期时生成）</span><br><span class="line"># e     清除事件（当 key 在内存被清除时生成）</span><br><span class="line"># A     g$lshzxe 的别称，因此 ”AKE” 意味着所有的事件</span><br><span class="line"># notify-keyspace-events 带一个由 0 到多个字符组成的字符串参数。空字符串意思是通知被禁用。</span><br><span class="line">#  例子：启用 list 和通用事件：</span><br><span class="line"># notify-keyspace-events Elg</span><br><span class="line">#  默认所用的通知被禁用，因为用户通常不需要改特性，并且该特性会有性能损耗。</span><br><span class="line">#  注意如果你不指定至少 K 或 E 之一，不会发送任何事件。</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">#notify-keyspace-events AKE</span><br><span class="line"></span><br><span class="line">######################### 高级设置 #########################</span><br><span class="line"></span><br><span class="line"># 当有少量条目的时候，哈希使用高效内存数据结构。最大的条目也不能超过设定的阈值。# “少量”定义如下：</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># 和哈希编码一样，少量列表也以特殊方式编码节省内存。“少量”设定如下：</span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># 集合只在以下情况下使用特殊编码来节省内存</span><br><span class="line"># --&gt;集合全部由64位带符号10进制整数构成的字符串组成</span><br><span class="line"># 下面的选项设置这个特殊集合的大小。</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"># 当有序集合的长度和元素设定为以下数字时，又特殊编码节省内存</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># HyperLogLog 稀疏表示字节限制</span><br><span class="line"># 这个限制包含了16个字节的头部，当一个HyperLogLog使用sparse representation</span><br><span class="line"># 超过了这个显示，它就会转换到dense representation上</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line"># 哈希刷新使用每100个CPU毫秒中的1毫秒来帮助刷新主哈希表（顶级键值映射表）。</span><br><span class="line">#  Redis哈希表使用延迟刷新机制，越多操作，越多刷新。</span><br><span class="line"># 如果服务器空闲，刷新操作就不会进行，更多内存会被哈希表占用</span><br><span class="line"># 默认每秒进行10次主字典刷新，释放内存。</span><br><span class="line"># 如果你有硬性延迟需求，偶尔2毫秒的延迟无法忍受的话。设置为no</span><br><span class="line"># 否则设置为yes</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"># 客户端输出缓存限制强迫断开读取速度比较慢的客户端</span><br><span class="line"># 有三种类型的限制</span><br><span class="line"># normal -&gt; 正常</span><br><span class="line"># slave  -&gt; slave和 MONITOR</span><br><span class="line"># pubsub -&gt; 客户端至少订阅了一个频道或者模式</span><br><span class="line"># 客户端输出缓存限制语法如下（时间单位：秒）</span><br><span class="line"># client-output-buffer-limit &lt;类别&gt; &lt;强制限制&gt; &lt;软性限制&gt; &lt;软性时间&gt;</span><br><span class="line"># 达到强制限制缓存大小，立刻断开链接。</span><br><span class="line"># 达到软性限制，仍然会有软性时间大小的链接时间</span><br><span class="line"># 默认正常客户端无限制，只有请求后，异步客户端数据请求速度快于它能读取数据的速度</span><br><span class="line"># 订阅模式和主从客户端又默认限制，因为它们都接受推送。</span><br><span class="line"># 强制限制和软性限制都可以设置为0来禁用这个特性</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line"># 设置Redis后台任务执行频率，比如清除过期键任务。</span><br><span class="line"># 设置范围为1到500，默认为10.越大CPU消耗越大，延迟越小。</span><br><span class="line"># 建议不要超过100</span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line"># 当子进程重写AOF文件，以下选项开启时，AOF文件会每产生32M数据同步一次。</span><br><span class="line"># 这有助于更快写入文件到磁盘避免延迟</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure></p>
<p>##　redis开机自启动<br>复制redis的自启动脚本到init.d中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp utils/redis_init_script /etc/init.d/redis_6379</span><br></pre></td></tr></table></figure></p>
<p>这里说明一下哈，镜像还是前面用的CentOs7，所以有的命令稍微跟6不一样。建立一个redis的服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$　vim /etc/systemd/system/redis_6379.service</span><br></pre></td></tr></table></figure></p>
<p>然后输入下面的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Redis on port 6379</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/init.d/redis_6379 start</span><br><span class="line">ExecStop=/etc/init.d/redis_6379 stop</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>注意上面文件的目录，就是刚刚复制的目录，如果有多个redis，这里需要注意。</p>
<h2 id="系统参数的调整"><a href="#系统参数的调整" class="headerlink" title="系统参数的调整"></a>系统参数的调整</h2><p>为了让redis正常运行，需要对某些系统参数进行调整。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 避免数据被截断</span><br><span class="line">$　sysctl -w vm.overcommit_memory=1</span><br><span class="line"></span><br><span class="line"># 修改 backlog 连接数的最大值超过 redis.conf 中的 tcp-backlog 值，即默认值511</span><br><span class="line">$ sysctl -w net.core.somaxconn=512</span><br><span class="line"></span><br><span class="line"># 取消对透明巨页内存（transparent huge pages）的支持，因为这会造成 redis 使用过程产生延时和内存访问问题。</span><br><span class="line">$ echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure></p>
<p>然后将以上配置，写入相关文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure></p>
<p>输入内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.overcommit_memory = 1</span><br><span class="line">net.core.somaxconn=512</span><br></pre></td></tr></table></figure></p>
<p>对于透明巨页内存支持，并没有直接 sysctl 命令可以控制，所以需要将下面的命令放到 /etc/rc.local 的结尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure></p>
<p>通过以上配置，可以来启动redis服务了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start redis_6379</span><br><span class="line"># 设置为开机启动</span><br><span class="line">$ systemctl enable redis_6379</span><br><span class="line"># 通过以下命令，查看redis的状态</span><br><span class="line">$ systemctl status redis_6379</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20160413105018714" alt="这里写图片描述"></p>
<p>然后使用客户端来进行测试一下redis服务是否正常，参见截图：<br><img src="http://img.blog.csdn.net/20160413105130090" alt="这里写图片描述"></p>
<h1 id="redis的监控redis-stat的安装"><a href="#redis的监控redis-stat的安装" class="headerlink" title="redis的监控redis-stat的安装"></a>redis的监控redis-stat的安装</h1><p>由于redis-stat是使用ruby开发的，在安装前，请确保你的环境已经有了ruby的环境，如果没有，请自行google、百度安装之，我就不写了哦。<br>由于ruby默认使用的镜像在国外，剩下的不说了，大家都懂得，然后万能的淘宝镜像，切换一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/</span><br></pre></td></tr></table></figure></p>
<p>证据如下：<br><img src="http://img.blog.csdn.net/20160413105728889" alt="这里写图片描述"></p>
<p>然后开始安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install redis-stat</span><br></pre></td></tr></table></figure></p>
<p>然后，一般来说，你会发现报错啦，报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Building native extensions.  This could take a while...</span><br><span class="line">ERROR:  Error installing redis-stat:</span><br><span class="line">	ERROR: Failed to build gem native extension.</span><br><span class="line"></span><br><span class="line">    /usr/bin/ruby extconf.rb</span><br><span class="line">mkmf.rb can&apos;t find header files for ruby at /usr/share/include/ruby.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Gem files will remain installed in /usr/local/share/gems/gems/json-1.8.3 for inspection.</span><br><span class="line">Results logged to /usr/local/share/gems/gems/json-1.8.3/ext/json/ext/generator/gem_make.out</span><br></pre></td></tr></table></figure></p>
<p>哈哈，，我好机智，想到大家很多人会搜索这个错误信息，会不会因此被带到这里呢？就像试试认真写的博客，会有多少人看。<br>这个错呢，很简单，就是因为没有安装ruby-devel，所有通过yum给安装上吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install ruby-devel</span><br></pre></td></tr></table></figure></p>
<p>这个就不要截图了吧。没什么好看的。</p>
<p>安装完成后，再次执行 <code>gem install redis-stat</code><br><img src="http://img.blog.csdn.net/20160413110515627" alt="这里写图片描述"></p>
<p>然后，至此安装完成，看一看劳动成果吧。随便说一句，它对redis的效率影响，基本可以忽略不计，因此，可以放心的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-stat</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20160413110608484" alt="这里写图片描述"></p>
<p>然后，他会自带一个web的版本。大家可以通过浏览器来访问，具体方式留给大家自己去查一查，搜一搜吧。</p>
<p>单机版的redis服务安装与监控，就全部搞定。so easy！！！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列三：Vagrant搭建的php7环境]]></title>
      <url>http://dayutalk.cn/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9AVagrant%E6%90%AD%E5%BB%BA%E7%9A%84php7%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>本文实战教你如何搭建自己的开发环境。希望大家通过本文实战后，可以根据自己的情况搭建任意想要的环境。<br><a id="more"></a></p>
<p>前面已经把vagrant的基础知识已经基本过了一遍 了，相信只要按着教程来，你已经搭建好了自己的基础环境。接下来说一说如何搭建php7的开发环境。</p>
<blockquote>
<p>申明一下，这里使用的box，就是前面演示的centos7<br>地址奉上：<br><a href="https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/centos-7.0-x86_64.box" target="_blank" rel="external">https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/centos-7.0-x86_64.box</a></p>
</blockquote>
<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><p>首先需要跟新一些ngin的相关源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line"></span><br><span class="line">// 执行安装过程</span><br><span class="line">$ yum install nginx</span><br></pre></td></tr></table></figure></p>
<p>看到以下界面时，请稍等，如果需要输入的地方，请直接按 <code>y</code> 然后回车。<br><img src="http://img.blog.csdn.net/20160406225356057" alt="这里写图片描述"></p>
<h2 id="启动nginx并设置为开机启动"><a href="#启动nginx并设置为开机启动" class="headerlink" title="启动nginx并设置为开机启动"></a>启动nginx并设置为开机启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start nginx </span><br><span class="line">$ systemctl enable nginx</span><br></pre></td></tr></table></figure>
<h1 id="安装epel与remi源"><a href="#安装epel与remi源" class="headerlink" title="安装epel与remi源"></a>安装epel与remi源</h1><p>安装epel，epel是Fedora小组维护的一个软件仓库项目，为RHEL/CentOS提供他们默认不提供的软件包。安装时一定需要注意一下自己系统的版本额。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ivh http://mirrors.opencas.cn/epel/7/x86_64/e/epel-release-7-5.noarch.rpm</span><br></pre></td></tr></table></figure></p>
<p>2016-10-22日修改：</p>
<blockquote>
<p>最近发上面的源不能用了。请大家自己在这里找对应的版本<br><a href="http://dl.fedoraproject.org/pub/" target="_blank" rel="external">http://dl.fedoraproject.org/pub/</a><br>过不了墙的请用国内镜像<br><a href="http://mirrors.sohu.com/fedora-epel/7/x86_64/e/epel-release-7-8.noarch.rpm" target="_blank" rel="external">http://mirrors.sohu.com/fedora-epel/7/x86_64/e/epel-release-7-8.noarch.rpm</a></p>
</blockquote>
<p>remi源种包含最新的php相关信息，如：php7、mysql等，因此为了便捷获取php7的最新信息，也需要安装一下这个源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</span><br></pre></td></tr></table></figure></p>
<h1 id="iptables防火墙"><a href="#iptables防火墙" class="headerlink" title="iptables防火墙"></a>iptables防火墙</h1><p>因为以前经常使用iptables，对centos7自带的firewalld防火墙不熟悉，因此我就将关闭centos7自带的firewalld，启用自己熟悉的iptables吧。</p>
<p>首先，关闭自带的firewalld防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld.service </span><br><span class="line">$ systemctl disable firewalld.service #防止开机启动</span><br></pre></td></tr></table></figure></p>
<h2 id="安装iptables"><a href="#安装iptables" class="headerlink" title="安装iptables"></a>安装iptables</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install iptables-services</span><br></pre></td></tr></table></figure>
<p>安装进程如下图所示<br><img src="http://img.blog.csdn.net/20160406225557402" alt="这里写图片描述"></p>
<p>启动iptables防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start iptables.service </span><br><span class="line">systemctl enable iptables.service #开机自动启动</span><br></pre></td></tr></table></figure></p>
<h2 id="编辑防火墙配置文件"><a href="#编辑防火墙配置文件" class="headerlink" title="编辑防火墙配置文件"></a>编辑防火墙配置文件</h2><p>为了我们在自己的主机上能够顺利访问，需要开启以下端口，<br>vim /etc/sysconfig/iptables<br>编辑防火墙，设置80(nginx) 3306(mysql/mariadb) 6379(redis)端口，外网可访问<br><img src="http://img.blog.csdn.net/20160406225918341" alt="这里写图片描述"></p>
<h1 id="PHP7-0的安装"><a href="#PHP7-0的安装" class="headerlink" title="PHP7.0的安装"></a>PHP7.0的安装</h1><p>查看remi源中可安装的php信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list --enablerepo=remi --enablerepo=remi-php70 | grep php70</span><br></pre></td></tr></table></figure></p>
<p>该列表会列出所有可以安装的php模块信息，从中安装自己需要的模块，下面安装模块，是我自己的一个模块选择情况。其中有一部分是必须的，有一部分是可选的。比如php-fpm就是必须的，如果你用的是nginx的话。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install --enablerepo=remi --enablerepo=remi-php70 php php-opcache php-pecl-apcu php-devel php-mbstring php-mcrypt php-mysqlnd php-pecl-xdebug php-pdo php-pear php-fpm php-cli php-xml php-bcmath php-process php-gd php-common php-json php-imap php-pecl-redis php-pecl-memcached php-pecl-mongodb</span><br></pre></td></tr></table></figure></p>
<p>安装完成后,输入 <code>php -v</code> 可以查看当前安装的php版本信息。<br><img src="http://img.blog.csdn.net/20160406230204248" alt="这里写图片描述"></p>
<p>启动php-fpm，因为nginx需要通过它来解析php程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start php-fpm</span><br><span class="line">$ systemctl enable php-fpm #设置开机自启动</span><br></pre></td></tr></table></figure></p>
<h2 id="配置nginx可以访问php"><a href="#配置nginx可以访问php" class="headerlink" title="配置nginx可以访问php"></a>配置nginx可以访问php</h2><p>进入nginx的文件配置中心，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc/nginx/conf.d/</span><br><span class="line"># 复制默认的配置文件 </span><br><span class="line">$ cp default.conf php.conf</span><br></pre></td></tr></table></figure></p>
<p>首先先通过vim编辑default文件。将监听端口改为8080， 因为后面我们自己的php.conf会用到80端口。<br><img src="http://img.blog.csdn.net/20160406230633531" alt="这里写图片描述"></p>
<p>现在来编辑复制的php.conf文件，可以直接复制以下内容，至于配置的含义，后面再开一篇文章来单独讲解吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /vagrant/www;# 自己的项目目录，也就是php项目所在目录</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">	    # 请注意，一定要加index.php这项</span><br><span class="line">        index  index.php index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        # 注意此处变量的不同</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改完文件后，必须要重新启动nginx，才会使当前的配置生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl reload nginx</span><br></pre></td></tr></table></figure></p>
<h2 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h2><p>在/vagrant/www下新建一个文件index.php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    phpinfo();</span><br></pre></td></tr></table></figure>
<p>在浏览器中打开，访问对应的ip，可以看到输出的php信息<br><img src="http://img.blog.csdn.net/20160406233803608" alt="这里写图片描述"></p>
<p><em>注：如果在使用过程中，有新增加的php模块，需要重新启动php－fpm</em></p>
<p><code>systemctl reload php-fpm</code></p>
<h1 id="Mariadb的安装"><a href="#Mariadb的安装" class="headerlink" title="Mariadb的安装"></a>Mariadb的安装</h1><p>这里很多同学可能第一次听说mariadb，他呢是mysql的一个重要分子，或者可以理解为mysql的替代品，自从mysql被控制后，更新速度已经慢太多了。两者的用法基本没有区别，实际中有哪些坑，大家可以自己去踩一踩。哈哈，别说我不负责任。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">$ yum install mariadb-server</span><br><span class="line"># 启动服务</span><br><span class="line">$ systemctl start mariadb</span><br><span class="line"># 开机启动</span><br><span class="line">$ systemctl enable mariadb</span><br></pre></td></tr></table></figure></p>
<h2 id="MariaDB的安全配置"><a href="#MariaDB的安全配置" class="headerlink" title="MariaDB的安全配置"></a>MariaDB的安全配置</h2><p>MariaDB默认root密码为空，我们需要设置一下，执行脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mysql_secure_installation</span><br></pre></td></tr></table></figure></p>
<p>这个脚本会经过一些列的交互问答来进行MariaDB的安全设置。</p>
<p>首先提示输入当前的root密码：</p>
<blockquote>
<p>Enter current password for root (enter for none):<br>初始root密码为空，我们直接敲回车进行下一步。</p>
<p>Set root password? [Y/n]<br>设置root密码，默认选项为Yes，我们直接回车，提示输入密码，在这里设置您的MariaDB的root账户密码。</p>
<p>Remove anonymous users? [Y/n]<br>是否移除匿名用户，默认选项为Yes，建议按默认设置，回车继续。</p>
<p>Disallow root login remotely? [Y/n]<br>是否禁止root用户远程登录？如果您只在本机内访问MariaDB，建议按默认设置，回车继续。 如果您还有其他云主机需要使用root账号访问该数据库，则需要选择n。</p>
<p>Remove test database and access to it? [Y/n]<br>是否删除测试用的数据库和权限？ 建议按照默认设置，回车继续。</p>
<p>Reload privilege tables now? [Y/n]<br>是否重新加载权限表？因为我们上面更新了root的密码，这里需要重新加载，回车。</p>
</blockquote>
<p>完成后你会看到Success!的提示，MariaDB的安全设置已经完成。我们可以使用以下命令登录MariaDB：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>按提示输入root密码，就会进入MariaDB的交互界面，说明已经安装成功。<br><img src="http://img.blog.csdn.net/20160406232302024" alt="这里写图片描述"></p>
<p>最后我们将MariaDB设置为开机启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable mariadb</span><br></pre></td></tr></table></figure></p>
<h2 id="让外网可以进行链接"><a href="#让外网可以进行链接" class="headerlink" title="让外网可以进行链接"></a>让外网可以进行链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;root&apos;;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
<h1 id="安装composer"><a href="#安装composer" class="headerlink" title="安装composer"></a>安装composer</h1><p>composer的大名，我就不想介绍了，如果你是一个phper，没用过，我也就不怪你，毕竟但是他现在才刚过1.0版，但是如果听都没听过，请面壁去……</p>
<p>安装说明<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ php -r “readfile(‘https:<span class="comment">//getcomposer.org/installer‘);” &gt; composer-setup.php</span></span><br><span class="line"></span><br><span class="line">$ php composer-setup.php</span><br><span class="line"></span><br><span class="line">$ php -r “unlink(‘composer-setup.php’);”</span><br></pre></td></tr></table></figure></p>
<p>上述 3 条命令的作用依次是：</p>
<blockquote>
<ol>
<li>下载安装脚本（composer-setup.php）到当前目录。 </li>
<li>执行安装过程。 </li>
<li>删除安装脚本 – composer-setup.php 。</li>
</ol>
</blockquote>
<h2 id="全局安装composer"><a href="#全局安装composer" class="headerlink" title="全局安装composer"></a>全局安装composer</h2><p>全局安装是将 Composer 安装到系统环境变量 PATH 所包含的路径下面，然后就能够在命令行窗口中直接执行 composer 命令了。</p>
<p>Mac 或 Linux 系统：打开命令行窗口并执行如下命令将前面下载的 composer.phar 文件移动到 /usr/local/bin/ 目录下面：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv composer.phar /usr/local/bin/composer</span><br></pre></td></tr></table></figure>
<p>然后执行：<br><code>composer -v</code><br><img src="http://img.blog.csdn.net/20160406233243543" alt="这里写图片描述"><br>由于composer的包都在国外，这里设置一下composer的配置，让其每次运行时，都使用国内的包<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ composer config -g repo.packagist composer https:<span class="comment">//packagist.phpcomposer.com</span></span><br></pre></td></tr></table></figure></p>
<p>查看composer的配置文件<br>vim /root/.composer/config.json<br><img src="http://img.blog.csdn.net/20160406233556529" alt="这里写图片描述"><br>看到以上内容，表示配置成功！</p>
<hr>
<p>至此，基本的php7环境搭建已经完成了。然后呢，下一次说一说用vagrant搭建redis吧。当然我不会仅仅只说redis的搭建额。到时候看啊吧！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列二：Vagrant的配置文件vagrantfile详解]]></title>
      <url>http://dayutalk.cn/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9AVagrant%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6vagrantfile%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>通过配置文件轻松的完成一台机器的配置，使用过vm然后再来使用这个，你就会惊叹怎会如此方便。</p>
<a id="more"></a>
<p>上一篇文章完整的讲叙了如何安装一个vagrant的环境。这里主要说一说vagrant的配置文件Vagrantfile。我在尝试各种技术的时候，常常苦恼于很多时候没有教程把相关的配置信息说明完整。所以在我的博客里，我一定会完整的把这块给补上。</p>
<h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h1><p>在我们的开发目录下有一个文件Vagrantfile，里面包含有大量的配置信息，主要包括三个方面的配置，虚拟机的配置、SSH配置、Vagrant的一些基础配置。Vagrant是使用Ruby开发的，所以它的配置语法也是Ruby的，但是我们没有学过Ruby的人还是可以跟着它的注释知道怎么配置一些基本项的配置。</p>
<p><strong>box设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.box = <span class="string">"CentOs7"</span></span><br></pre></td></tr></table></figure></p>
<p>该名称是再使用 vagrant init 中后面跟的名字。</p>
<p><strong>hostname设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.hostname = <span class="string">"for_work"</span></span><br></pre></td></tr></table></figure></p>
<p>设置hostname非常重要，因为当我们有很多台虚拟服务器的时候，都是依靠hostname來做识别的。比如，我安装了php7 php56两台虚拟机，再启动时，我可以通过vagrant up php7来指定只启动哪一台。</p>
<p><strong>虚拟机网络设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network <span class="string">"private_network"</span>, ip: <span class="string">"192.168.33.10"</span></span><br><span class="line"><span class="comment">#config.vm.network "public_network"</span></span><br></pre></td></tr></table></figure></p>
<p>Vagrant有两种方式来进行网络连接，一种是host-only(主机模式)，意思是主机和虚拟机之间的网络互访，而不是虚拟机访问internet的技术，也就是只有你一個人自High，其他人访问不到你的虚拟机。另一种是Bridge(桥接模式)，该模式下的VM就像是局域网中的一台独立的主机，也就是说需要VM到你的路由器要IP，这样的话局域网里面其他机器就可以访问它了。我一般设置为host－only模式。<br>当然该模式，再指定ip的时候注意不要跟主机所在网段发生冲突。</p>
<p><strong>同步目录设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.synced_folder  <span class="string">"/Users/helei/www"</span>, <span class="string">"/vagrant"</span></span><br></pre></td></tr></table></figure></p>
<p>我们上面介绍过/vagrant目录默认就是当前的开发目录，这是在虚拟机开启的时候默认挂载同步的。我们还可以通过配置来设置额外的同步目录。</p>
<p><strong>端口转发设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network :forwarded_port, guest: <span class="number">80</span>, host: <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>上面这句配置可厉害了，这一行的意思是把对host机器上8080端口的访问请求forward到虚拟机的80端口的服务上，例如你在你的虚拟机上使用nginx跑了一个php应用，那么你在host机器上的浏览器中打开<a href="http://localhost时，Vagrant就会把这个请求转发到VM里面跑在80端口的nginx服务上，因此我们可以通过这个设置来帮助我们去设定host和VM之间，或是VM和VM之间的信息交互。" target="_blank" rel="external">http://localhost时，Vagrant就会把这个请求转发到VM里面跑在80端口的nginx服务上，因此我们可以通过这个设置来帮助我们去设定host和VM之间，或是VM和VM之间的信息交互。</a><br>个人不建议使用该方法，经常因为两台机子端口占用的问题，导致不能正常通信。还是使用上面说的两种网络方式进行设置吧。</p>
<hr>
<p>上面说的配置方式，均是单机模式，下面说说如何进行集群机器的部署与配置，这是vagrant让我正真激动与兴奋的地方。</p>
<p>看完下面，你会觉得超级简单</p>
<p>现在我们来建立多台VM跑起來，並且让他们之间能够相通信，假设一台是应用服务器、一台是redis服务器，那么这个结构在Vagrant中非常简单，其实和单台的配置差不多，你只需要通过config.vm.define来定义不同的角色就可以了，现在我们打开配置文件进行如下设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  config.vm.define :web do |web|</span><br><span class="line">    web.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line">          v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;web&quot;, &quot;--memory&quot;, &quot;512&quot;]</span><br><span class="line">    end</span><br><span class="line">    web.vm.box = &quot;CentOs7&quot;</span><br><span class="line">    web.vm.hostname = &quot;web&quot;</span><br><span class="line">    web.vm.network :private_network, ip: &quot;192.168.33.10&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  config.vm.define :redis do |redis|</span><br><span class="line">    redis.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line">          v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;redis&quot;, &quot;--memory&quot;, &quot;512&quot;]</span><br><span class="line">    end</span><br><span class="line">    redis.vm.box = &quot;CentOs7&quot;</span><br><span class="line">    redis.vm.hostname = &quot;redis&quot;</span><br><span class="line">    redis.vm.network :private_network, ip: &quot;192.168.33.11&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p>这里的的设置与设置单台机器非常的类似，如果还需要机器，只需要再配置文件中拷贝一下，然后重新加载一下这个配置文件就ok啦。是不是非常容易？后面我打算学hadoop的时候，就用这种方式来试试。<br>现在只需要重新启动一下vagrant up机器，你就会在虚拟机中看到两台虚拟机欢快的跑起来了。<br>然后这个时候，在使用vagrant ssh登录时，需要指明一下登录的是哪一台机器就ok啦。</p>
<hr>
<p>比如，我要登录到redis中去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh redis</span><br></pre></td></tr></table></figure></p>
<p>这么简单就完成登录了。登录成功后，可以使用ping命令，检查一下机器之间是否能够互相通信。</p>
<p>好吧，本地有了如此利器，你想模拟那样的服务器架构，都可以完成了，只有你的单机足够强大，你可以开20台虚拟机，请随意。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列一：Vagrant的安装与初识]]></title>
      <url>http://dayutalk.cn/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%9AVagrant%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>本系列文章之前首发在csdn上。觉得还不错现在迁移过来。本文主要介绍安装与一些简单介绍。后续会有更深入的探讨。<br><a id="more"></a></p>
<blockquote>
<p>实际上Vagrant只是一个让你可以方便设置你想要的虚拟机的便携式工具，它底层支持VirtualBox、VMware甚至AWS作为虚拟机系统，本书中我们将使用VirtualBox来进行说明，所以第一步需要先安裝Vagrant和VirtualBox。</p>
<p>安装环境：mac<br>注：windows环境下，基本一致</p>
</blockquote>
<h1 id="安装VirtualBox"><a href="#安装VirtualBox" class="headerlink" title="安装VirtualBox"></a>安装VirtualBox</h1><p>直接来到官网 <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">https://www.virtualbox.org/wiki/Downloads</a> 点击下载最新的virtualbox，双击安装，一路傻瓜化完成。</p>
<h1 id="安装Vagrant"><a href="#安装Vagrant" class="headerlink" title="安装Vagrant"></a>安装Vagrant</h1><p>网上有说什么使用gem命令来安装的，建议大家别进这个坑了，直接到官网 <a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">https://www.vagrantup.com/downloads.html</a> 下载最新的vagrant，然后双击安装，也是一路傻瓜化，就不说。<br>在windows下安装vagrant，为了写入相应配置到环境变量，可能会要求重新启动一下系统。</p>
<h1 id="如何配置Vagrant"><a href="#如何配置Vagrant" class="headerlink" title="如何配置Vagrant"></a>如何配置Vagrant</h1><hr>
<h2 id="下载一个合适的box"><a href="#下载一个合适的box" class="headerlink" title="下载一个合适的box"></a>下载一个合适的box</h2><p>进行完以上步骤后，就需要考虑我们的虚拟机需要使用什么操作系统了，我这里会以CentOs7.0为例。在以前使用vm的过程中，我们需要自己去下载镜像，然后进行相关的安装，设置系统等等操作。而vagrant的开源社区，提供了很多已经打包好的操作系统，在vagrant的世界里被称为box。在 <a href="http://www.vagrantbox.es/" target="_blank" rel="external">http://www.vagrantbox.es/</a> 这里你可以找到你想要的操作系统box，当然你也可以自己制作一个。后续教程会讲到，这里就不多说。</p>
<h2 id="完成一个box的安装"><a href="#完成一个box的安装" class="headerlink" title="完成一个box的安装"></a>完成一个box的安装</h2><p>我的开发机是Mac，所以我建立了如下的开发环境目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /Users/helei/vagrant</span><br><span class="line">$ cd /Users/helei/vagrant</span><br></pre></td></tr></table></figure></p>
<p>本来，vagrant提供的在线安装，非常便利，但是无奈我国有非常NB的gfw，我为了速度，就先翻墙出去把box下载到本地，然后再进行安装。</p>
<blockquote>
<p>box链接：<a href="https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/centos-7.0-x86_64.box" target="_blank" rel="external">https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/centos-7.0-x86_64.box</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box add &#123;title&#125; &#123;url&#125;</span><br><span class="line">$ vagrant init &#123;title&#125;</span><br><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure>
<p>vagrant box add 是添加box的命令<br>其中｛title｝可以自行设置，我这里使用的是 <em>centos7</em> ，｛url｝是下载到本地box路径。我的路径是：/Users/helei/vagrant/centos-7.0-x86_64.box</p>
<p>下面把一些命令执行后的输出进行展示，方便大家比对：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装box</span><br><span class="line">$ vagrant box add CentOs7 /Users/helei/vagrant/centos-7.0-x86_64.box</span><br></pre></td></tr></table></figure></p>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Downloading or copying the box...</span><br><span class="line">Extracting box...te: 47.5M/s, Estimated time remaining: --:--:--)</span><br><span class="line">Successfully added box &apos;base&apos; with provider &apos;virtualbox&apos;!</span><br></pre></td></tr></table></figure></p>
<p>box中的镜像文件被放到了：/Users/helei/.vagrant.d/boxes/，如果在window系统中应该是放到了： C:\Users\当前用户名.vagrant.d\boxes\目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果是才add 的box，就必须执行本步骤，初始化一次后，以后启动系统，就不需要执行本步骤。</span><br><span class="line">$ vagrant init CentOs7</span><br></pre></td></tr></table></figure></p>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A `Vagrantfile` has been placed in this directory.</span><br><span class="line">You are now ready to `vagrant up` your first virtual environment!</span><br><span class="line">Please read the comments in the Vagrantfile as well as documentation on `vagrantup.com` for more information on using Vagrant.</span><br></pre></td></tr></table></figure></p>
<p>这样就会在当前目录生成一个 Vagrantfile的文件，里面有很多配置信息，后面我在慢慢说，默认不做任何配置改动，也是可以启动系统的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动系统</span><br><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure></p>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...</span><br><span class="line">[default] Importing base box &apos;base&apos;...</span><br><span class="line">[default] Matching MAC address for NAT networking...</span><br><span class="line">[default] Setting the name of the VM...</span><br><span class="line">[default] Clearing any previously set forwarded ports...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="ssh链接到安装的虚拟机"><a href="#ssh链接到安装的虚拟机" class="headerlink" title="ssh链接到安装的虚拟机"></a>ssh链接到安装的虚拟机</h2><p>经过以上操作后，完成了虚拟机的安装，现在需要登录上虚拟机，进行操作。链接很简单，可以使用第三方（xshell等）shell工具或系统自带的，进行登录<br>在系统中，如mac，可直接使用 <code>vagrant ssh</code> 来完成链接。或者使用第三方如xshell，ip地址是：localhost，端口，需要观察，映射的22端口是多少。一般是2200 或者2222<br>用户名与密码均是： vagrant</p>
<h1 id="vagrant的命令详解"><a href="#vagrant的命令详解" class="headerlink" title="vagrant的命令详解"></a>vagrant的命令详解</h1><hr>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>vagrant box add</td>
<td>添加box的操作</td>
</tr>
<tr>
<td>vagrant init</td>
<td>初始化box的操作，会生成vagrant的配置文件Vagrantfile</td>
</tr>
<tr>
<td>vagrant up</td>
<td>启动本地环境</td>
</tr>
<tr>
<td>vagrant ssh</td>
<td>通过 ssh 登录本地环境所在虚拟机</td>
</tr>
<tr>
<td>vagrant halt</td>
<td>关闭本地环境</td>
</tr>
<tr>
<td>vagrant suspend</td>
<td>暂停本地环境</td>
</tr>
<tr>
<td>vagrant resume</td>
<td>恢复本地环境</td>
</tr>
<tr>
<td>vagrant reload</td>
<td>修改了 Vagrantfile 后，使之生效（相当于先 halt，再 up）</td>
</tr>
<tr>
<td>vagrant destroy</td>
<td>彻底移除本地环境</td>
</tr>
<tr>
<td>vagrant box list</td>
<td>显示当前已经添加的box列表</td>
</tr>
<tr>
<td>vagrant box remove</td>
<td>删除相应的box</td>
</tr>
<tr>
<td>vagrant package</td>
<td>打包命令，可以把当前的运行的虚拟机环境进行打包</td>
</tr>
<tr>
<td>vagrant plugin</td>
<td>用于安装卸载插件</td>
</tr>
<tr>
<td>vagrant status</td>
<td>获取当前虚拟机的状态</td>
</tr>
<tr>
<td>vagrant global-status</td>
<td>显示当前用户Vagrant的所有环境状态</td>
</tr>
</tbody>
</table>
<p>下一篇，主要讲vagrant的配置，通过配置文件，实现多台虚拟机的启动.能够很方便的实现多台机器。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP设计模式：模板方法真的很有用]]></title>
      <url>http://dayutalk.cn/2016/09/09/PHP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9C%9F%E7%9A%84%E5%BE%88%E6%9C%89%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>模版方法很好的提现了继承的思想，我用它为核心完成了支付集成的开源项目，在使用过程中受益匪浅。<br><a id="more"></a></p>
<p>在设计模式分类中，模板方法被分在 <strong>行为型模式</strong></p>
<p>在我最近的项目中我也经常使用。然后在看YII的源码时，它的身影也随处可见。忍不住想要将它说一说。希望能够帮助大家解决一些开发中灵活扩展的问题。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以在不改变一个算法的结构的情况下重定义该算法的某些特定的步骤</p>
</blockquote>
<ul>
<li>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。</li>
<li>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。</li>
</ul>
<p>上面两点是行为型模式的一个特征。以上两点在 <strong>模板方法模式</strong> 中体现的非常明显。</p>
<p>教科书给出的概念读起来总是这么绕口。搞得人云里雾里的。还是结合代码来说吧。</p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="http://www.phppan.com/wp-content/uploads/2010/09/Template.jpg" alt="image"></p>
<h1 id="模板方法code案例"><a href="#模板方法code案例" class="headerlink" title="模板方法code案例"></a>模板方法code案例</h1><p>为了让大家能够在实际中看到设计模式的使用。我就直接用YII中的一些代码片段来讲。然后大家可以下载YII下来。然后自己对照看一看。</p>
<p>根据上面的类图。首先需要一个抽象的父类。它里边定义了一个 <code>templateMethod</code>  这个方法内部会调用 <code>primitiveOperation1</code>  <code>primitiveOperation2</code> 这两个方法。但是调用的两个发放是抽象的。要在子类中来具体决定实现。</p>
<p>先把示例代码写出来，大家看一看</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseObject</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 顶层组织逻辑的方法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;primitiveOperation1();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;primitiveOperation2();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 基本方法1</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">primitiveOperation1</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * 基本方法2</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">primitiveOperation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个抽象类定义好了调用的层次。凡是继承了它的子类，都需要实现这两个方法，并且完成自己相应的逻辑。比如一个子类继承了它。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 基本方法1</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">primitiveOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'primitiveOperation1&lt;br /&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * 基本方法2</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">primitiveOperation2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'primitiveOperation2&lt;br /&gt;'</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上基本上就是模板方法模式的全部代码。不知道大家是否从中领教到它的厉害之处？我先不解释，接下来看看YII中对这种设计模式的应用</p>
<h1 id="YII中的模板方法"><a href="#YII中的模板方法" class="headerlink" title="YII中的模板方法"></a>YII中的模板方法</h1><p>凡是用过YII的都知道，它有一个 <code>Object</code> 类。这个类是整个YII的基础。今天我们不说YII。单说设计模式。就略过不说了。下面是简化后的 <code>Object代码</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Configurable</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($config = [])</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>($config)) &#123;</span><br><span class="line">            Yii::configure(<span class="keyword">$this</span>, $config);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意这个方法</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// YII中为它定义了一个空实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>YII在 <code>Object</code> 的构造函数中，调用 <code>Object::init()</code> 这个方法。但是这个方法是一个空实现，因此具体要init的东西，延迟到了子类进行实现，</p>
<p>看看YII的代码，就知道基本上所有的类都是继承自这个类，每个类的init都可以进行个性化定制。</p>
<p>它的实现，我们可以看看 <code>ActiveController</code> 中代码的实现</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActiveController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">parent</span>::init();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;modelClass === <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidConfigException(<span class="string">'The "modelClass" property must be set.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>Controller</code> 也是继承自 <code>Object</code> 大家可以自己追踪一下代码。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>模板方法模式使用的范围非常广泛。总结一下它的特点</p>
<ul>
<li>将具体的一些实现延迟到子类，可以减少父类初始化的压力</li>
<li>父类只定义调用步骤，具体每一步的实现由子类自己决定</li>
<li>这样的结构利用了一种反射的思路，由父类来调用子类的具体实现方法</li>
<li>很好的进行了代码的复用</li>
</ul>
<p>在YII中有很多模板方法的使用，大家可以自己去阅读代码看一看。这种设计模式带来的一个麻烦的地方是查看代码的不方便。<br>比如：经常继承一个类后实现了一些方法，但是这个方法的调用关系一头雾水，如果遇到这种情况，建议去父类看看是否有个方法组织调用了你重写的方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入微信企业付款功能]]></title>
      <url>http://dayutalk.cn/2016/08/16/PHP%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E4%BB%98%E6%AC%BE%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>可以利用该接口，完成转账功能，目前仅微信支持，支付宝已关闭。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.0版本</a></p>
<p>这个功能与支付宝的批量付款到支付宝帐号功能类似。但是当前支付宝这个接口已经停止审核了。</p>
<p>当前很多提问平台就用到了这两个平台。比如［来问医生］，你提的问题如果被人看了。医生得0.5元，你得0.5元。然后累积够1元后，［来问医生］就会通过微信的企业付款功能给你的微信余额增加1元。</p>
<h1 id="代码调用"><a href="#代码调用" class="headerlink" title="代码调用"></a>代码调用</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">TransferContext</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Config</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成转款单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$wxconfig = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxa244db59a34996fc'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'1331302101'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'adslkfjiKQJLAIQLJ393201482333333'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时 退款  转款，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转款数据</span></span><br><span class="line">$transData = [</span><br><span class="line">    <span class="string">'trans_no'</span> =&gt; createPayid(),</span><br><span class="line">    <span class="string">'trans_data'</span>   =&gt; [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">'serial_no'</span> =&gt; createPayid(),</span><br><span class="line">            <span class="string">'user_account'</span> =&gt; <span class="string">'otijfvr2oMz3tXnaQdKKbQeeBmhM'</span>,<span class="comment">// 微信转款时，为用户所关注公众号的openid</span></span><br><span class="line">            <span class="string">'user_name'</span> =&gt; <span class="string">'愚不可及'</span>,</span><br><span class="line">            <span class="string">'trans_fee'</span> =&gt; <span class="string">'1'</span>,</span><br><span class="line">            <span class="string">'desc'</span>  =&gt; <span class="string">'测试批量转款'</span>,</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$refund = <span class="keyword">new</span> TransferContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 微信的企业付款， 仅支持单笔</span></span><br><span class="line">    $type = Config::WEIXIN;</span><br><span class="line">    $refund-&gt;initTransfer(Config::WEIXIN, $wxconfig);</span><br><span class="line"></span><br><span class="line">    $ret = $refund-&gt;transfer($transData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump($ret);</span><br></pre></td></tr></table></figure>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>trans_no</td>
<td>商户订单号</td>
<td>商户订单号，需保持唯一性</td>
<td>是</td>
</tr>
<tr>
<td>trans_data</td>
<td>转账数据</td>
<td>转账数据详细信息，具体内容如下</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>trans_data数据</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>serial_no</td>
<td>流水号</td>
<td>对于微信该参数不需要，但请保留，后期可能支持批量退款需要</td>
<td>否</td>
</tr>
<tr>
<td>user_account</td>
<td>用户openid</td>
<td>商户appid下，某用户的openid</td>
<td>是</td>
</tr>
<tr>
<td>user_name</td>
<td>收款用户姓名</td>
<td>收款用户真实姓名。</td>
<td>是</td>
</tr>
<tr>
<td>trans_fee</td>
<td>金额</td>
<td>企业付款金额，单位为元</td>
<td>是</td>
</tr>
<tr>
<td>desc</td>
<td>企业付款描述信息</td>
<td>企业付款操作说明信息。</td>
<td>是</td>
</tr>
</tbody>
</table>
<h1 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_success</td>
<td>是否成功</td>
<td>失败会返回错误原因。T:成功  F:失败</td>
<td>是</td>
</tr>
<tr>
<td>error</td>
<td>错误原因</td>
<td>为T时有返回</td>
<td>否</td>
</tr>
<tr>
<td>response</td>
<td>成功时数据</td>
<td>成功时返回的具体数据</td>
<td>否</td>
</tr>
</tbody>
</table>
<p><strong>response数据</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>trans_no</td>
<td>商户订单号</td>
<td>商户订单号，需保持唯一性</td>
<td>是</td>
</tr>
<tr>
<td>trans_id</td>
<td>微信订单号</td>
<td>企业付款成功，返回的微信订单号</td>
<td>否</td>
</tr>
<tr>
<td>payment_time</td>
<td>微信支付成功时间</td>
<td>企业付款成功时间</td>
<td>否</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入微信退款接口]]></title>
      <url>http://dayutalk.cn/2016/08/16/PHP%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>买的东西不喜欢了，想要还给商家，申请后商家自动退换购买商品时的买家支付的费用。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.0版本</a> </p>
<p>微信的退款操作，通过封装与前面<a href="https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/" target="_blank" rel="external">支付宝退款</a>除了配置文件，基本一样。</p>
<p>退款代码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">RefundContext</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Config</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成退款单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$config = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxa244db59a34996fc'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'1331302101'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'adslkfjiKQJLAIQLJ393201482333333'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时 退款  转款，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退款数据</span></span><br><span class="line">$reundData = [</span><br><span class="line">    <span class="string">'refund_no'</span> =&gt; createPayid(),</span><br><span class="line">    <span class="string">'refund_data'</span>   =&gt; [</span><br><span class="line">        [<span class="string">'transaction_id'</span> =&gt; <span class="string">'4007572001201607098672633287'</span>, <span class="string">'amount'</span>   =&gt; <span class="string">'5'</span>, <span class="string">'refund_fee'</span> =&gt; <span class="string">'5'</span>, <span class="string">'reason'</span> =&gt; <span class="string">'微信测试金额退款'</span>],</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$refund = <span class="keyword">new</span> RefundContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 微信退款</span></span><br><span class="line">    $type = Config::WEIXIN;</span><br><span class="line">    $refund-&gt;initRefund(Config::WEIXIN, $wxconfig);</span><br><span class="line"></span><br><span class="line">    $ret = $refund-&gt;refund($reundData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump($ret);</span><br></pre></td></tr></table></figure></p>
<p>当前sdk支付宝可一次退款多笔数据。微信仅能每次退款1笔（如果想要实现一次退订多笔订单，可在客户端通过循环来处理。）</p>
<p>接下来解释下相关的配置信息</p>
<p>微信的配置文件解释参考 <a href="https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%94%AF%E4%BB%98%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%85%A5%EF%BC%9AAPP%E6%94%AF%E4%BB%98%E3%80%81%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%E3%80%81%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/" target="_blank" rel="external">微信的三种支付方式接入：APP支付、公众号支付、扫码支付</a> 中的微信配置信息。</p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction_id</td>
<td>微信交易号</td>
<td>微信系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>总金额</td>
<td>微信交易对应的交易总金额</td>
<td>是</td>
</tr>
<tr>
<td>refund_fee</td>
<td>退款金额</td>
<td>本次申请的退款金额，退款金额不能大于总金额</td>
<td>是</td>
</tr>
<tr>
<td>reason</td>
<td>退款理由</td>
<td>退款的理由，可在用户端查看到</td>
<td>是</td>
</tr>
</tbody>
</table>
<h1 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_success</td>
<td>成功标识</td>
<td>请求是否成功，T:成功，F:失败</td>
<td>是</td>
</tr>
<tr>
<td>error</td>
<td>错误提示</td>
<td>只有is_success=F时才返回</td>
<td>否</td>
</tr>
<tr>
<td>response</td>
<td>响应数据</td>
<td>查询成功后返回的数据，一个数组，is_success=T时返回</td>
<td>否</td>
</tr>
</tbody>
</table>
<p><strong>response</strong> 数据描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction_id</td>
<td>微信订单号</td>
<td>微信订单号，下单成功后，微信返回</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户订单号</td>
<td>商户系统内部的订单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_no</td>
<td>商户退款单号</td>
<td>商户退款单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_id</td>
<td>微信退款单号</td>
<td>微信退款单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_fee</td>
<td>申请退款金额</td>
<td>退款总金额,单位为元(已被我处理),可以做部分退款</td>
<td>否</td>
</tr>
<tr>
<td>amount</td>
<td>订单金额</td>
<td>订单总金额，单位为元，最多两位小数</td>
<td>否</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信支付订单、退款订单、转款订单的查询]]></title>
      <url>http://dayutalk.cn/2016/08/10/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E8%AE%A2%E5%8D%95%E3%80%81%E9%80%80%E6%AC%BE%E8%AE%A2%E5%8D%95%E3%80%81%E8%BD%AC%E6%AC%BE%E8%AE%A2%E5%8D%95%E7%9A%84%E6%9F%A5%E8%AF%A2/</url>
      <content type="html"><![CDATA[<p>主要介绍相关订单的查询，简化针对不同类型订单（支付的、退单的、转款的）的查询工作。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a></p>
<p>微信并未提供一个统一的查询接口。对应每种查询均需要不同的api。为了便于大家在项目中使用，忽略细节。对以上三种进行了封装。通过工厂的方式降低调用成本。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$wxconfig = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxxxx'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'xxxx'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxx'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">QueryContext</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Config</span>;</span><br><span class="line"></span><br><span class="line">$query = <span class="keyword">new</span> QueryContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过交易号查询，  推荐</span></span><br><span class="line">$data = [</span><br><span class="line">    <span class="comment">//'order_no'    =&gt; '2016011402433464',// 商户订单号</span></span><br><span class="line">    <span class="string">'transaction_id'</span>    =&gt; <span class="string">'4007572001201607098672633287'</span>,<span class="comment">// 微信订单查询  微信退款单查询</span></span><br><span class="line">    <span class="comment">//'trans_no'  =&gt; '1007570439201601142692427764', // 微信批量转款查询</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 微信订单查询</span></span><br><span class="line">    $query-&gt;initQuery(Config::WEIXIN, $wxconfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信退款订单状态查询</span></span><br><span class="line">    <span class="comment">//$query-&gt;initQuery(Config::WEIXIN_REFUND, $wxconfig);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信企业付款查询</span></span><br><span class="line">    <span class="comment">//$query-&gt;initQuery(Config::WEIXIN_TRANS, $wxconfig);</span></span><br><span class="line"></span><br><span class="line">    $ret = $query-&gt;query($data);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>订单查询非常简单。对于微信支付订单以及退款订单可以根据微信支付的流水号进行查询。对于微信支付的订单还可根据商户的订单号进行查询。但是强烈建议通过微信自身的流水号进行查询。</p>
<p>对于批量转款查询。需要提供再转款时，生产的转款单号（此单号是由商家自行生产的）。这里我也蛮迷惑，为什么不提供使用微信返回的转款流水号进行查询呢？</p>
<p>接下来对返回值进行解释,以下结构为一个顶层结构</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_success</td>
<td>成功标识</td>
<td>请求是否成功，T:成功，F:失败</td>
<td>是</td>
</tr>
<tr>
<td>error</td>
<td>错误提示</td>
<td>只有is_success=F时才返回</td>
<td>否</td>
</tr>
<tr>
<td>response</td>
<td>响应数据</td>
<td>查询成功后返回的数据，一个数组，is_success=T时返回</td>
<td>否</td>
</tr>
</tbody>
</table>
<h2 id="微信支付订单返回值"><a href="#微信支付订单返回值" class="headerlink" title="微信支付订单返回值"></a>微信支付订单返回值</h2><p>支付订单中关于 <code>response</code> 中包含字段的描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>交易金额</td>
<td>本次订单总金额，单位为元，最多两位小数</td>
<td>是</td>
</tr>
<tr>
<td>channel</td>
<td>支付渠道</td>
<td>本处取值： wx</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户网站唯一订单号</td>
<td>商户生成的订单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>buyer_id</td>
<td>用户标识</td>
<td>用户在商户appid下的唯一标识</td>
<td>是</td>
</tr>
<tr>
<td>trade_state</td>
<td>交易状态</td>
<td>支付成功与否，可取值：success  not_pay</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>微信交易号</td>
<td>微信系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>time_end</td>
<td>交易付款时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="微信退款订单"><a href="#微信退款订单" class="headerlink" title="微信退款订单"></a>微信退款订单</h2><p>退款有以下两点需要注意</p>
<ul>
<li>交易时间超过一年的订单无法提交退款；</li>
<li>微信支付退款支持单笔交易分多次退款，多次退款需要提交原支付订单的商户订单号和设置不同的退款单号。一笔退款失败后重新提交，要采用原来的退款单号。总退款金额不能超过用户实际支付金额。</li>
</ul>
<p>由于一笔支付订单，可能存在多笔退单的情况，因此退款记录将返回一个数组</p>
<p>退款订单中关于 <code>response</code> 中包含字段的描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>交易金额</td>
<td>本次订单总金额，单位为元，最多两位小数</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户网站唯一订单号</td>
<td>商户生成的订单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>微信交易号</td>
<td>微信系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>refund_data</td>
<td>退款数据</td>
<td>其结构是一个数组，每一个元素包含一个退单信息</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><code>refund_data</code> 中包含字段的描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>refund_no</td>
<td>商户退款单号</td>
<td>商户退款单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_id</td>
<td>微信退款单号</td>
<td>微信退款单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_channel</td>
<td>退款渠道</td>
<td>ORIGINAL—原路退款  BALANCE—退回到余额</td>
<td>是</td>
</tr>
<tr>
<td>refund_fee</td>
<td>退款金额</td>
<td>退款总金额,单位为元,可以做部分退款</td>
<td>是</td>
</tr>
<tr>
<td>refund_status</td>
<td>退款状态</td>
<td>SUCCESS—退款成功  FAIL—退款失败  PROCESSING—退款处理中  NOTSURE—未确定，需要商户原退款单号重新发起  CHANGE—转入代发</td>
<td>是</td>
</tr>
<tr>
<td>recv_accout</td>
<td>退款入账账户</td>
<td>退款入账账户</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="转款订单查询结果"><a href="#转款订单查询结果" class="headerlink" title="转款订单查询结果"></a>转款订单查询结果</h2><pre><code>&apos;trans_id&apos;  =&gt; $data[&apos;detail_id&apos;],// 付款单号
&apos;trans_status&apos;  =&gt; $data[&apos;status&apos;],// 转账状态
&apos;reason&apos;    =&gt; $data[&apos;reason&apos;],// 失败原因
&apos;buyer_id&apos;   =&gt; $data[&apos;openid&apos;],
&apos;trans_name&apos;   =&gt; $data[&apos;transfer_name&apos;],// 收款用户姓名
&apos;trans_time&apos;   =&gt; $data[&apos;transfer_time&apos;],
&apos;desc&apos;   =&gt; $data[&apos;desc&apos;],// 付款描述
</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>付款金额</td>
<td>付款金额  单位元</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户单号</td>
<td>商户使用查询API填写的单号的原路返回.</td>
<td>是</td>
</tr>
<tr>
<td>trans_id</td>
<td>付款单号</td>
<td>调用企业付款API时，微信系统内部产生的单号</td>
<td>是</td>
</tr>
<tr>
<td>trans_status</td>
<td>转账状态</td>
<td>SUCCESS:转账成功   FAILED:转账失败  PROCESSING:处理中</td>
<td>是</td>
</tr>
<tr>
<td>reason</td>
<td>失败原因</td>
<td>如果失败则有失败原因</td>
<td>否</td>
</tr>
<tr>
<td>buyer_id</td>
<td>收款用户openid</td>
<td>收款用户openid</td>
<td>是</td>
</tr>
<tr>
<td>trans_name</td>
<td>收款用户姓名</td>
<td>真实姓名，如果是需要实名验证，则会返回</td>
<td>否</td>
</tr>
<tr>
<td>trans_time</td>
<td>转账时间</td>
<td>发起转账的时间  格式：2015-04-21 20:00:00</td>
<td>是</td>
</tr>
<tr>
<td>desc</td>
<td>付款描述</td>
<td>付款时候的描述</td>
<td>是</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信的三种支付方式接入：APP支付、公众号支付、扫码支付]]></title>
      <url>http://dayutalk.cn/2016/08/10/%E5%BE%AE%E4%BF%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%94%AF%E4%BB%98%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%85%A5%EF%BC%9AAPP%E6%94%AF%E4%BB%98%E3%80%81%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%E3%80%81%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/</url>
      <content type="html"><![CDATA[<p>微信支付：app支付、公众号支付、扫码支付使用文档。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>微信的支付逻辑与支付宝的支付有一些差别。为了让客户端忽略这些差别，统一调用。本sdk做了对应处理。</p>
<p>＃ SDK调用</p>
<p>微信支付不同接口需要的参数会有差别。请大家在使用接口时，仔细查看文档。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">ChargeContext</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Config</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信支付，必须设置时区，否则发生错误</span></span><br><span class="line">date_default_timezone_set(<span class="string">'Asia/Shanghai'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成订单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单信息</span></span><br><span class="line">$payData = [</span><br><span class="line">    <span class="string">"order_no"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"amount"</span>	=&gt; <span class="string">'0.01'</span>,<span class="comment">// 单位为元 ,最小为0.01</span></span><br><span class="line">    <span class="string">"client_ip"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'测试支付'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付接口测试'</span>,</span><br><span class="line">    <span class="string">"extra_param"</span>	=&gt; <span class="string">''</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信扫码支付，需要设置的参数</span></span><br><span class="line">$payData[<span class="string">'product_id'</span>]  = <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信公众号支付，需要的参数</span></span><br><span class="line">$payData[<span class="string">'openid'</span>] = <span class="string">'otijfvr2oMz3tXnaQdKKbQeeBmhM'</span>;<span class="comment">// 需要通过微信提供的api获取该openid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 包含客户的配置文件</span><br><span class="line"> * 本次 2.0 版本，主要的改变是将配置文件独立出来，便于客户多个账号的情况</span><br><span class="line"> * 已经使用不同方式读取配置文件，如：db  file   cache等</span><br><span class="line"> */</span></span><br><span class="line">$wxconfig = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxxxx'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'xxxx'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxx'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 实例化支付环境类，进行支付创建</span><br><span class="line"> */</span></span><br><span class="line">$charge = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信 扫码支付</span></span><br><span class="line">    $type = Config::WX_CHANNEL_QR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信 APP支付</span></span><br><span class="line">    <span class="comment">//$type = Config::WX_CHANNEL_APP;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信 公众号支付</span></span><br><span class="line">    <span class="comment">//$type = Config::WX_CHANNEL_PUB;</span></span><br><span class="line">    $charge-&gt;initCharge($type, $wxconfig);</span><br><span class="line">    $ret = $charge-&gt;charge($payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($type === Config::WX_CHANNEL_QR) &#123;</span><br><span class="line">    $url = urlencode($ret);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;img alt='扫码支付' src='http://paysdk.weixin.qq.com/example/qrcode.php?data=&#123;$url&#125;' style='width:150px;height:150px;'/&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ($type === Config::WX_CHANNEL_PUB) &#123;</span><br><span class="line">    $json = $ret;</span><br><span class="line">    var_dump($json);<span class="keyword">exit</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> (stripos($type, <span class="string">'wx'</span>) !== <span class="keyword">false</span>) &#123;</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里扫码支付与公众号支付分别需要提供不同的参数。请一定注意进行区分。否则调用相应端口会抛出异常。</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>app_id</td>
<td>公众账号ID/应用id</td>
<td>微信分配的公众账号ID</td>
<td>是</td>
</tr>
<tr>
<td>mch_id</td>
<td>商户号</td>
<td>微信支付分配的商户号</td>
<td>是</td>
</tr>
<tr>
<td>md5_key</td>
<td>加密的key</td>
<td>在商户中心设置</td>
<td>是</td>
</tr>
<tr>
<td>notify_url</td>
<td>通知地址</td>
<td>接收微信支付异步通知回调地址，通知url必须为直接可访问的url，不能携带参数。</td>
<td>是</td>
</tr>
<tr>
<td>time_expire</td>
<td>交易过期时间</td>
<td>单位为分钟，过期后无法再次支付</td>
<td>是</td>
</tr>
<tr>
<td>cert_path</td>
<td>密钥文件</td>
<td>可在微信商户后台中下载</td>
<td>否，退款需要</td>
</tr>
<tr>
<td>key_path</td>
<td>密钥文件</td>
<td>可在商户中心下载</td>
<td>否，退款需要</td>
</tr>
</tbody>
</table>
<p>这里需要注意的是，app_id，由于微信的三个支付接口，需要对应两个不同的app_id。因此再开发中一定要注意。</p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>order_no</td>
<td>订单号</td>
<td>平台根据规则生成的订单号，最长64位，要在商户数据库中唯一</td>
<td>必须</td>
</tr>
<tr>
<td>amount</td>
<td>交易总金额</td>
<td>该笔订单的资金总额，单位为RMB-Yuan。取值范围为[0.01，100000000.00]，精确到小数点后两位。</td>
<td>必须</td>
</tr>
<tr>
<td>client_ip</td>
<td>客户端IP</td>
<td>用户在创建交易时，该用户当前所使用机器的IP。</td>
<td>必须</td>
</tr>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>商品的标题/交易标题/订单标题/订单关键字等。该参数最长为128个汉字。</td>
<td>必须</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>对一笔交易的具体描述信息。如果是多种商品，请将商品描述字符串累加传给body。</td>
<td>必须</td>
</tr>
<tr>
<td>extra_param</td>
<td>公用回传参数</td>
<td>如果用户请求时传递了该参数，则返回给商户时会回传该参数。</td>
<td>可选</td>
</tr>
<tr>
<td>product_id</td>
<td>商品ID</td>
<td>扫码支付，此参数必传。此id为二维码中包含的商品ID，商户自行定义。</td>
<td>可选</td>
</tr>
<tr>
<td>openid</td>
<td>用户标识</td>
<td>公众号支付，此参数必传，用户在商户appid下的唯一标识。</td>
<td>可选</td>
</tr>
</tbody>
</table>
<h1 id="返回值描述"><a href="#返回值描述" class="headerlink" title="返回值描述"></a>返回值描述</h1><p>三种支付方式返回值因为处理方式不同，微信方面返回了不同的类型。</p>
<ul>
<li>app支付返回了需要调用的数组。调用客户端的方式 <a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_12&amp;index=2" target="_blank" rel="external">查看微信文档</a></li>
<li>扫码支付返回了一个地址。可生成一个二维码，完成支付。</li>
<li>公众号支付，返回的是一个json数据。可直接放入微信的sdk完成jsapi调用。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝有密批量转款接口]]></title>
      <url>http://dayutalk.cn/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E6%89%B9%E9%87%8F%E8%BD%AC%E6%AC%BE%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>转款接口，支付宝已经停止审核啦，目前可以用微信的企业付款。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>这个接口蛮有用的，不过现阶段支付宝已经停止审核啦！微信的转账功能还可以继续使用。企业可以转账到其他支付宝账户。对于企业活动非常有帮助，比如：购买返现呀！</p>
<p>虽然现在已经不接收新的审核，但是我还是将该功能进行了集成，因为指不定什么时候又开放了，毕竟微信都有这个功能，支付宝不搞出来，实在说不过去。</p>
<h1 id="SDK调用"><a href="#SDK调用" class="headerlink" title="SDK调用"></a>SDK调用</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝配置信息</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转款接口，必须配置以下两项</span></span><br><span class="line">    <span class="string">'account'</span>   =&gt; <span class="string">'xxxxxxx@126.com'</span>,</span><br><span class="line">    <span class="string">'account_name'</span> =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成转款单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转款数据</span></span><br><span class="line">$transData = [</span><br><span class="line">    <span class="string">'trans_no'</span> =&gt; createPayid(),</span><br><span class="line">    <span class="string">'trans_data'</span>   =&gt; [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">'serial_no'</span> =&gt; createPayid(),</span><br><span class="line">            <span class="string">'user_account'</span> =&gt; <span class="string">'dayugog@gmail.com'</span>,</span><br><span class="line">            <span class="string">'user_name'</span> =&gt; <span class="string">'愚不可及'</span>,</span><br><span class="line">            <span class="string">'trans_fee'</span> =&gt; <span class="string">'0.01'</span>,</span><br><span class="line">            <span class="string">'desc'</span>  =&gt; <span class="string">'测试批量转款'</span>,</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$refund = <span class="keyword">new</span> TransferContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $refund-&gt;initTransfer(Config::ALI, $aliconfig);</span><br><span class="line">    $ret = $refund-&gt;transfer($transData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转支付宝</span></span><br><span class="line">header(<span class="string">"Location:&#123;$ret&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>这个接口也是需要管理员输入支付密码，才能够完成，完成后也会回调。回调过程请参考 <a href="https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/" target="_blank" rel="external">支付的回调统一处理</a> 已经说明。</p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>trans_no</td>
<td>转款单号</td>
<td>由商家自定义生成，可由字母、数字组成</td>
<td>是</td>
</tr>
<tr>
<td>trans_data</td>
<td>转款数据</td>
<td>详细内容见后表，它是一个数组</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>trans_data数据组成</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>serial_no</td>
<td>流水号</td>
<td>由商家自定义生成，可由字母、数字组成</td>
<td>是</td>
</tr>
<tr>
<td>user_account</td>
<td>收款方账号</td>
<td>收款方的支付宝账号，支持邮箱和手机号2种格式。</td>
<td>是</td>
</tr>
<tr>
<td>user_name</td>
<td>收款账号姓名</td>
<td>收款方的支付宝账户名。</td>
<td>是</td>
</tr>
<tr>
<td>trans_fee</td>
<td>付款金额</td>
<td>向该账号转入多少金额，单位元</td>
<td>是</td>
</tr>
<tr>
<td>desc</td>
<td>备注说明</td>
<td>可以是转款理由等，如：8月工资2W</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>这个地方SDK总做了很多工作，简化了相当多的参数，大家可以去对照原接口查看一下。<a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.rVbILN&amp;treeId=64&amp;articleId=104804&amp;docType=1" target="_blank" rel="external">支付宝原接口地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝有密退款接口]]></title>
      <url>http://dayutalk.cn/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>可针对订单完成退款操作，但是需要输入密码。不是谁都可以操作。微信退款则可以根据密钥文件自动完成，无须人为干预。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>这个接口主要用于退款操作。之前没有接入该功能时，商城用户如果想要退款，我们需要先查到对应用户的支付流水号，然后写退款申请给财务，财务到支付宝进行查询。完了之后原路退回。然后告诉程序，程序再去修改订单状态。</p>
<p>这样的流程不仅麻烦。而且充满不安全性。如果程序误操作（或者是心情太差了），操作为其他人员，那么这将会为企业带来很大的风险。</p>
<h1 id="SDK调用"><a href="#SDK调用" class="headerlink" title="SDK调用"></a>SDK调用</h1><p>支付宝支持多笔退款。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝配置信息</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成退款单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退款数据</span></span><br><span class="line">$reundData = [</span><br><span class="line">    <span class="string">'refund_no'</span> =&gt; createPayid(),</span><br><span class="line">    <span class="string">'refund_data'</span>   =&gt; [</span><br><span class="line">        [<span class="string">'transaction_id'</span> =&gt; <span class="string">'2016011421001004330041239366'</span>, <span class="string">'amount'</span>   =&gt; <span class="string">'0.01'</span>, <span class="string">'refund_fee'</span> =&gt; <span class="string">'0.01'</span>, <span class="string">'reason'</span> =&gt; <span class="string">'测试退款1'</span>],</span><br><span class="line">        [<span class="string">'transaction_id'</span> =&gt; <span class="string">'2016031521001004330271745693'</span>, <span class="string">'amount'</span>   =&gt; <span class="string">'0.01'</span>, <span class="string">'refund_fee'</span> =&gt; <span class="string">'0.01'</span>, <span class="string">'reason'</span> =&gt; <span class="string">'测试退款2'</span>],</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$refund = <span class="keyword">new</span> RefundContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $refund-&gt;initRefund(Config::ALI, $aliconfig);</span><br><span class="line">    $ret = $refund-&gt;refund($reundData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转支付宝</span></span><br><span class="line">header(<span class="string">"Location:&#123;$ret&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>以上请求发送完毕后，会跳转到生成的url。界面如下：</p>
<p><img src="https://helei112g.github.io/images/ali-refund.png" alt="image"></p>
<p>这时候，只需要要输入支付密码。就可完成退款。确认完毕后会自动完成异步通知。异步通知数据内容在 <a href="https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/" target="_blank" rel="external">支付的回调统一处理</a> 已经说明。</p>
<p>备注：支付宝支持一次退款多笔。也可单次退款一笔，请自行根据情况进行设置。</p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>refund_no</td>
<td>退款单号</td>
<td>由商家自定义生成，可由字母、数字组成</td>
<td>是</td>
</tr>
<tr>
<td>refund_data</td>
<td>退款数据</td>
<td>详细内容见后表，它是一个数组</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>refund_data数据</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction_id</td>
<td>支付宝流水号</td>
<td>支付成功时，异步通知时有返回</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>订单总金额</td>
<td>订单总金额，应该等于支付时的金额</td>
<td>否</td>
</tr>
<tr>
<td>refund_fee</td>
<td>退款金额</td>
<td>退款金额，不能超过支付的总金额</td>
<td>是</td>
</tr>
<tr>
<td>reason</td>
<td>退款理由</td>
<td>退款理由</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>一笔订单，可分多次进行退款处理。比如：一笔支付100元的订单。可分为10次，每次退款10元。该思路可扩展一下，就可实现提现功能（原路返回），想要具体了解提现功能，可咨询我！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝单笔订单查询接口]]></title>
      <url>http://dayutalk.cn/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E5%8D%95%E7%AC%94%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>查询支付宝订单状态<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>巴西奥运会来了，刚好我又是做体育行业的互联网。哎！这个月又要加班成狗了。最近遇到好多莫名其妙的问题，待我忙完这段，再跟大家分享下。今天还是继续说说 <a href="https://github.com/helei112g/payment" target="_blank" rel="external">Payment项目</a><br>今天主要说说支付宝订单查询接口。</p>
<h1 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h1><p>废话废话不多说。直接上支付宝订单查询的代码。微信的订单查询与此类似。后续也会更新文档。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝配置信息</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$data = [</span><br><span class="line">    <span class="comment">// 通过支付宝交易号查询，  推荐  效率更高</span></span><br><span class="line">    <span class="string">'transaction_id'</span>    =&gt; <span class="string">'2016011421001004330041239366'</span>,<span class="comment">// 支付宝</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过订单号查询</span></span><br><span class="line">    <span class="string">'order_no'</span>    =&gt; <span class="string">'2016011402433464'</span>,<span class="comment">// 支付宝</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$query = <span class="keyword">new</span> QueryContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 支付宝查询</span></span><br><span class="line">    $query-&gt;initQuery(Config::ALI, $aliconfig);</span><br><span class="line">    $ret = $query-&gt;query($data);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump($ret);</span><br></pre></td></tr></table></figure>
<p>非常简单，只需要提供支付宝的流水号，或者商家自己生成的订单号，就可完成订单详情的查询，当然前提是，依然要去签约这个接口（觉得支付宝真扯淡，都能够支付了，为什么查询还要单独签约？这一点微信比它强）</p>
<p>如果同时提供了 <code>transaction_id</code> 跟 <code>order_no</code> 这两个参数，会优先使用 <code>transaction_id</code> ,因为他的效率要高的多。</p>
<p>代码完成了下面分别解释下请求的参数。以及返回参数。关于支付宝的配置参数，请参考 <a href="https://helei112g.github.io/2016/07/29/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E3%80%81%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/" target="_blank" rel="external">PHP接入支付宝手机网站支付、移动支付接口</a></p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><p>查询订单的参数非常简单。这里能够查询的仅指：支付成功后的订单</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction_id</td>
<td>支付宝流水号</td>
<td>支付成功后，异步通知中会返回</td>
<td>二选一</td>
</tr>
<tr>
<td>order_no</td>
<td>商户订单号</td>
<td>商户生成的唯一订单号</td>
<td>二选一</td>
</tr>
</tbody>
</table>
<p>对于上表中的数据，两个字段二选一即可。推荐使用 <code>transaction_id</code> ，该字段查询效率更高。如果两个字段同时提供，会优先使用 <code>transaction_id</code>。</p>
<p>请求后，程序会向支付宝进行查询。查询完成后，会将返回的数据做一定处理然后返回给客户端。</p>
<h1 id="返回参数"><a href="#返回参数" class="headerlink" title="返回参数"></a>返回参数</h1><p>查询存在两种情况，失败，成功，分别对返回字段含义进行说明。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_success</td>
<td>成功标识</td>
<td>请求是否成功，T:成功，F:失败</td>
<td>是</td>
</tr>
<tr>
<td>error</td>
<td>错误提示</td>
<td>只有is_success=F时才返回</td>
<td>否</td>
</tr>
<tr>
<td>response</td>
<td>响应数据</td>
<td>查询成功后返回的数据，一个数组，is_success=T时返回</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>关于 <code>response</code> 中包含字段的描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>订单的关键字</td>
<td>是</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>提交订单时的body值</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>交易金额</td>
<td>本次订单总金额</td>
<td>是</td>
</tr>
<tr>
<td>channel</td>
<td>支付渠道</td>
<td>本处取值： ali</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户网站唯一订单号</td>
<td>商户生成的订单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>buyer_id</td>
<td>买家支付宝账户号</td>
<td>可以是Email或手机号码。</td>
<td>是</td>
</tr>
<tr>
<td>trade_state</td>
<td>交易状态</td>
<td>支付成功与否，可取值：success  not_pay</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>支付宝交易号</td>
<td>支付宝系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>time_end</td>
<td>交易付款时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>针对查询返回的数据，调用者可进行相关的业务处理。如果需要更多信息可联系我进行定制开发，也可自行更改代码完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[支付的回调统一处理]]></title>
      <url>http://dayutalk.cn/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>支付成功的订单，都需要通过第三方的回调来告知自身服务器，任务已经完成，为了让使用者专注自身的业务，这个接口封装了一些基础处理，如：验签、数据解析等<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>经过这一段时间，终于把支付宝支付相关接口完成了。文档将陆续更新。这里先把回调的文档补充完成。这样结合之前 提供的 <a href="https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%EF%BC%9A%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/" target="_blank" rel="external">支付宝即时到帐接口</a> 才能形成一个闭环。完成一次完整的支付流程。</p>
<h1 id="回调接口介绍"><a href="#回调接口介绍" class="headerlink" title="回调接口介绍"></a>回调接口介绍</h1><blockquote>
<p>支付服务商(支付宝、微信、PayPal等)处理完支付数据后。会将处理的结果数据通过服务器主动通知的方式通知给商户网站。这些处理结果数据就是服务器异步通知参数。</p>
</blockquote>
<p>简单来说，就是支付成功后，支付服务商告诉你，钱已经到账了，你应该把别个买的东西给别个了。</p>
<p>由于本次发布的接口主要都是与支付宝相关，因此本次回调的部分代码也主要先上支付宝的。微信等后期开发完成将更新相关文档。</p>
<p>针对不同的回调，我提供了统一的调用方式，让客户端专注自己的业务。不在处理支付相关的签名验证、来源验证的问题。下面代码是统一的回调处理代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 支付宝配置文件</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,<span class="comment">// 请填写自己的支付宝账号信息</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxx'</span>,<span class="comment">// 此密码无效，请填写自己对应设置的值</span></span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转款接口，必须配置以下两项</span></span><br><span class="line">    <span class="string">'account'</span>   =&gt; <span class="string">'xxxxxxx@126.com'</span>,</span><br><span class="line">    <span class="string">'account_name'</span> =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信配置文件</span></span><br><span class="line">$wxconfig = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxxxx'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'xxxx'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxx'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取异步通知上下文</span></span><br><span class="line">$notify = <span class="keyword">new</span> NotifyContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端的业务逻辑类。处理如：订单更新</span></span><br><span class="line">$callback = <span class="keyword">new</span> TestNotify();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 支付宝回调</span></span><br><span class="line">    <span class="comment">//$notify-&gt;initNotify(Config::ALI, $aliconfig);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 微信回调</span></span><br><span class="line">    $notify-&gt;initNotify(Config::WEIXIN, $wxconfig);</span><br><span class="line">    $notify-&gt;notify($callback);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端类 <code>TestNotify</code> 的注意事项 ，一定要继承 <code>PayNotifyInterface</code> 这个类</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Notify</span>\<span class="title">PayNotifyInterface</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestNotify</span> <span class="keyword">implements</span> <span class="title">PayNotifyInterface</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 客户端的业务逻辑，</span><br><span class="line">     * <span class="doctag">@param</span> array $data</span><br><span class="line">     * <span class="doctag">@return</span> bool  返回值一定是bool值</span><br><span class="line">     * <span class="doctag">@author</span> helei</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notifyProcess</span><span class="params">(array $data)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 一般支付的处理业务</span></span><br><span class="line">        <span class="number">1.</span> 检查订单是否存在</span><br><span class="line">        <span class="number">2.</span> 检查金额是否正确</span><br><span class="line">        <span class="number">3.</span> 检查订单是否已经处理过（防止重复通知）</span><br><span class="line">        <span class="number">4.</span> 更新订单</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>TestNotify::notifyProcess()</code> 方法中，我注释了常规的订单处理流程。这个地方客户端可根据自己的情况进行适当调整。只是返回结果一定需要 <strong>布尔值</strong></p>
<p>现在的重点是 <code>TestNotify::notifyProcess()</code> 方法中的参数 $data 中具体包含的值。根据不同的回调业务，返回的值也不一样。具体请往下看。</p>
<h1 id="支付宝回调通知类型"><a href="#支付宝回调通知类型" class="headerlink" title="支付宝回调通知类型"></a>支付宝回调通知类型</h1><p>支付宝的回调，与支付相关的对应三种类型。</p>
<ul>
<li>trade_status_sync  支付行为相关的异步通知</li>
<li>batch_refund_notify   有密批量退款的异步通知</li>
<li>batch_trans_notify   有密批量付款到支付宝账号的通知</li>
</ul>
<h2 id="trade-status-sync-异步通知返回数据"><a href="#trade-status-sync-异步通知返回数据" class="headerlink" title="trade_status_sync 异步通知返回数据"></a>trade_status_sync 异步通知返回数据</h2><p>该回调发生在：移动支付、即时到帐、手机网站支付接口调用后，如果支付成功，支付宝会发起回调接口。</p>
<p>返回的对应数据如下表</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>订单的关键字</td>
<td>是</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>提交订单时的body值</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>交易金额</td>
<td>本次订单总金额</td>
<td>是</td>
</tr>
<tr>
<td>channel</td>
<td>支付渠道</td>
<td>本处取值： ali</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户网站唯一订单号</td>
<td>商户生成的订单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>buyer_id</td>
<td>买家支付宝账户号</td>
<td>可以是Email或手机号码。</td>
<td>是</td>
</tr>
<tr>
<td>trade_state</td>
<td>交易状态</td>
<td>支付成功与否，可取值：success  not_pay</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>支付宝交易号</td>
<td>支付宝系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>time_end</td>
<td>交易付款时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
<tr>
<td>notify_time</td>
<td>通知时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
<tr>
<td>notify_type</td>
<td>通知类型</td>
<td>此处为：trade  表示交易</td>
<td>是</td>
</tr>
<tr>
<td>extra_param</td>
<td>商户自定义参数</td>
<td>仅即时到帐支持</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>传入到 <code>TestNotify::notifyProcess()</code> 中的数组，包括以上key。可根据以上内容进行业务处理。</p>
<h2 id="batch-refund-notify-异步通知返回数据"><a href="#batch-refund-notify-异步通知返回数据" class="headerlink" title="batch_refund_notify 异步通知返回数据"></a>batch_refund_notify 异步通知返回数据</h2><p>本类回调发生在操作退款后，支付宝会通知服务器是否退款成功。退款的界面，如下图：</p>
<p><img src="http://note.youdao.com/yws/public/resource/82ee87138ba987799b398e12b6c79c95/685E18BF0FF041C780F3E1721DA9A26A" alt="image"></p>
<p>输入支付密码后，就可完成退款。退款后支付宝会向商户服务器进行异步通知。他返回的数据如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>channel</td>
<td>渠道</td>
<td>本处取值： ali</td>
<td>是</td>
</tr>
<tr>
<td>refund_no</td>
<td>商户网站唯一退单号</td>
<td>商户生成的退单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>success_num</td>
<td>退款成功总数</td>
<td>0&lt;= success_num&lt;= 总退款笔数</td>
<td>是</td>
</tr>
<tr>
<td>notify_time</td>
<td>通知时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
<tr>
<td>notify_type</td>
<td>通知类型</td>
<td>此处为：trade  表示交易</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="batch-trans-notify-异步通知返回数据"><a href="#batch-trans-notify-异步通知返回数据" class="headerlink" title="batch_trans_notify 异步通知返回数据"></a>batch_trans_notify 异步通知返回数据</h2><p>该回调发生在批量付款后。返回的数据如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>channel</td>
<td>渠道</td>
<td>本处取值： ali</td>
<td>是</td>
</tr>
<tr>
<td>trans_no</td>
<td>商户网站唯一转账单号</td>
<td>商户生成的转账单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>pay_name</td>
<td>付款账号姓名</td>
<td>如果是个人为昵称，公司则为公司名称</td>
<td>是</td>
</tr>
<tr>
<td>pay_account</td>
<td>付款账号</td>
<td>邮箱或者手机号码</td>
<td>是</td>
</tr>
<tr>
<td>notify_time</td>
<td>通知时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
<tr>
<td>notify_type</td>
<td>通知类型</td>
<td>此处为：trade  表示交易</td>
<td>是</td>
</tr>
<tr>
<td>success</td>
<td>转账成功的详细信息</td>
<td>返回的是一个数组</td>
<td>是</td>
</tr>
<tr>
<td>fail</td>
<td>转账失败的详细信息</td>
<td>返回的是一个数组</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>备注：</strong></p>
<ul>
<li>success返回的数组中，单条记录格式如下：</li>
</ul>
<blockquote>
<p>流水号^收款方账号^收款账号姓名^付款金额^成功标识(S)^成功原因(null)^支付宝内部流水号^完成时间。</p>
</blockquote>
<ul>
<li>fail返回数据中的单条记录格式如下：</li>
</ul>
<blockquote>
<p>流水号^收款方账号^收款账号姓名^付款金额^失败标识(F)^失败原因^支付宝内部流水号^完成时间。</p>
</blockquote>
<p>OK。到此支付宝相关的回调通知数据，已经全部处理完成。这里需要大家注意一个问题，上面的数据并不是完整的支付宝返回数据。大部分经过了我的简化，如果有需要的参数，没有返回可执行修改源码或者联系我。</p>
<h1 id="微信支付回调"><a href="#微信支付回调" class="headerlink" title="微信支付回调"></a>微信支付回调</h1><p>微信的回调代码部分与支付宝相同。不同的主要是返回值</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>订单金额</td>
<td>微信默认为分，此处以处理为元，两位小数</td>
<td>是</td>
</tr>
<tr>
<td>channel</td>
<td>支付渠道</td>
<td>可取之为：ali   wx  此处为wx</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户订单号</td>
<td>商户系统的订单号，与请求一致。</td>
<td>是</td>
</tr>
<tr>
<td>buyer_id</td>
<td>用户标识</td>
<td>用户在商户appid下的唯一标识</td>
<td>是</td>
</tr>
<tr>
<td>trade_state</td>
<td>交易状态</td>
<td>表示交易成功，返回值：success</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>微信支付订单号</td>
<td>微信支付订单号</td>
<td>是</td>
</tr>
<tr>
<td>time_end</td>
<td>支付完成时间</td>
<td>支付完成时间，格式为yyyy-MM-dd HH:mm:ss</td>
<td>是</td>
</tr>
<tr>
<td>notify_time</td>
<td>异步通知发生时间</td>
<td>支付完成时间，格式为yyyy-MM-dd HH:mm:ss</td>
<td>是</td>
</tr>
<tr>
<td>notify_type</td>
<td>通知类型</td>
<td>此处为：trade  表示交易</td>
<td>是</td>
</tr>
<tr>
<td>extra_param</td>
<td>商户自定义参数</td>
<td>仅即时到帐支持</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>大家可以对比支付宝中异步通知的返回数据。对相关数据均做了命令统一、数据单位格式统一。方便再业务中进行统一处理。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝手机网站支付、移动支付接口]]></title>
      <url>http://dayutalk.cn/2016/07/29/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E3%80%81%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>支付宝手机网站、移动支付（app）接口。统一的接入方式，便于项目管理<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>前面已经说完了 PHP接入支付宝 即时到帐接口</p>
<p>回调接口也已经完成。这篇主要讲 <strong>手机网站支付</strong> 、 <strong>移动支付</strong> 接口的调用。调用方式与即时到帐 基本一样。</p>
<p>关于代码部分的详细解释，请 参看 <a href="https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%EF%BC%9A%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/" target="_blank" rel="external">PHP接入支付宝 即时到帐接口</a></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 订单数组</span></span><br><span class="line">$orderData = [</span><br><span class="line">    <span class="string">"order_no"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"amount"</span>	=&gt; <span class="string">'0.01'</span>,<span class="comment">// 单位为元 ,最小为0.01</span></span><br><span class="line">    <span class="string">"client_ip"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'      测试支付'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付接口测试'</span>,</span><br><span class="line">    <span class="string">"show_url"</span>  =&gt; <span class="string">'http://mall.tiyushe.com/goods/23.html'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支付宝配置信息</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化环境类</span></span><br><span class="line"></span><br><span class="line">$charge = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 支付宝即时到帐接口</span></span><br><span class="line">    <span class="comment">// $type = Config::ALI_CHANNEL_WEB;</span></span><br><span class="line">    <span class="comment">// $charge-&gt;initCharge($type, $aliconfig);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付宝 手机网站支接口</span></span><br><span class="line">    <span class="comment">// $type = Config::ALI_CHANNEL_WAP;</span></span><br><span class="line">    <span class="comment">// $charge-&gt;initCharge($type, $aliconfig);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付宝 移动支付接口</span></span><br><span class="line">    $type = Config::ALI_CHANNEL_APP;</span><br><span class="line">    $charge-&gt;initCharge($type, $aliconfig);</span><br><span class="line">    $ret = $charge-&gt;charge($payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($type === Config::ALI_CHANNEL_APP) &#123;</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 跳转支付宝</span></span><br><span class="line">    header(<span class="string">"Location:&#123;$ret&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>oK！大家仔细看代码。唯一不同的，仅仅是支付的方式这个常量。<br>目前常量的含义</p>
<ul>
<li>Config::ALI_CHANNEL_WEB  及时到账接口，主要用于网站支付</li>
<li>Config::ALI_CHANNEL_WAP  手机网站支付接口，主要用于手机浏览器</li>
<li>Config::ALI_CHANNEL_APP  移动支付接口，主要用于原生APP</li>
</ul>
<p>调用方式非常统一，传入的参数也被最大程度的统一化。简化了客户端的调用。这里主要对参数进行一些说明。</p>
<h1 id="支付宝配置数据"><a href="#支付宝配置数据" class="headerlink" title="支付宝配置数据"></a>支付宝配置数据</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>partner</td>
<td>合作者身份ID</td>
<td>签约的支付宝账号对应的支付宝唯一用户号。以2088开头的16位纯数字组成。</td>
<td>是</td>
</tr>
<tr>
<td>md5_key</td>
<td>MD5密钥</td>
<td><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.qt91b7&amp;treeId=62&amp;articleId=104740&amp;docType=1#s1" target="_blank" rel="external">点击这里</a></td>
<td>是</td>
</tr>
<tr>
<td>rsa_private_key</td>
<td>RSA私钥</td>
<td><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.qt91b7&amp;treeId=62&amp;articleId=104740&amp;docType=1#s0" target="_blank" rel="external">点击这里</a></td>
<td>是</td>
</tr>
<tr>
<td>notify_url</td>
<td>服务器异步通知URI</td>
<td>支付宝服务器主动通知商户网站里指定的页面http路径。(建议使用https)</td>
<td>否</td>
</tr>
<tr>
<td>return_url</td>
<td>页面跳转同步通知页面路径</td>
<td>支付宝处理完请求后，当前页面自动跳转到商户网站里指定页面的url路径。仅在即时到账接口有效</td>
<td>否</td>
</tr>
<tr>
<td>time_expire</td>
<td>超时时间</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。单位默认为分钟</td>
<td>否</td>
</tr>
</tbody>
</table>
<h1 id="订单数据"><a href="#订单数据" class="headerlink" title="订单数据"></a>订单数据</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$orderData = [</span><br><span class="line">    <span class="string">"order_no"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"amount"</span>	=&gt; <span class="string">'0.01'</span>,<span class="comment">// 单位为元 ,最小为0.01</span></span><br><span class="line">    <span class="string">"client_ip"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'      测试支付'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付接口测试'</span>,</span><br><span class="line">    <span class="string">"show_url"</span>  =&gt; <span class="string">'http://mall.tiyushe.com/goods/23.html'</span>,</span><br><span class="line">    <span class="string">"extra_param"</span>   =&gt; <span class="string">'自定义参数'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>order_no</td>
<td>订单号</td>
<td>平台根据规则生成的订单号，最长64位，要在商户数据库中唯一</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>交易总金额</td>
<td>该笔订单的资金总额，单位为RMB-Yuan。取值范围为[0.01，100000000.00]，精确到小数点后两位。</td>
<td>是</td>
</tr>
<tr>
<td>client_ip</td>
<td>客户端IP</td>
<td>用户在创建交易时，该用户当前所使用机器的IP。</td>
<td>是</td>
</tr>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>商品的标题/交易标题/订单标题/订单关键字等。该参数最长为128个汉字。</td>
<td>是</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>对一笔交易的具体描述信息。如果是多种商品，请将商品描述字符串累加传给body。</td>
<td>是</td>
</tr>
<tr>
<td>show_url</td>
<td>商品展示网址</td>
<td>收银台页面上，商品展示的超链接。</td>
<td>手机网站支付接口：必须，其他：可选</td>
</tr>
<tr>
<td>extra_param</td>
<td>公用回传参数</td>
<td>如果用户请求时传递了该参数，则返回给商户时会回传该参数。仅在即时到帐接口有效</td>
<td>是</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[php设计模式：策略模式的实际应用]]></title>
      <url>http://dayutalk.cn/2016/07/23/php%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>多学两个设计模式总是好的，自己不写，但是总要看别人的代码吧？<br><a id="more"></a></p>
<p>最近写了一个集成各家支付的开源项目（支付宝与微信）。<a href="https://github.com/helei112g/payment" target="_blank" rel="external">项目地址</a>。让调用支付变得更加简单、统一。目前已经在<a href="http://mall.tiyushe.com/" target="_blank" rel="external">公司商城</a>推行使用，上海<a href="http://yimishiji.com/" target="_blank" rel="external">一米市集</a>也采用了这个支付集成项目。</p>
<p>我可不是打广告哦，只是为了让大家可以有一个只管的了解渠道。可以去看看。</p>
<p>今天主要聊的不是支付，而是说说其中使用的一个设计模式：策略模式。</p>
<h1 id="策略模式的定义解析"><a href="#策略模式的定义解析" class="headerlink" title="策略模式的定义解析"></a>策略模式的定义解析</h1><blockquote>
<p>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</p>
</blockquote>
<p>这是书本上给的定义，是不是完全搞不懂？我结合支付，再来给你解释一下，一定就赫然开朗啦！</p>
<p>首先是这句 <strong>让算法独立于使用它的客户而变化</strong>  （我是倒着在分析哦）。<br>这是什么意思？也就是说实现一个功能，有多个方法，而选择这个方法的控制权不要交给客户端，也就说了，我换了实现方法，客户端是不需要改代码的。</p>
<p>那么要做到这样子，必然提供给客户端的一个稳定的调用类(称为环境类)，首先调用这个类能够产生一个具体算法的实例，其次这个调用类，还需要公布一个接口，让客户端调用实现具体功能。</p>
<p>那么做到以上，无论实现多少种双方，客户端的调用都是不变的。控制权都在这个调用类里边，由它来决定到底采用哪种算法。</p>
<p>下面来接着说算法部分。如果需要 <strong>环境类</strong> 提供一个实现具体功能的接口，那么这些算法必然实现了一个公共接口（称为抽象策略类）。才能确保有相同的方法提供出来。然后具体的算法都要实现这个接口。这也就是上面定义中的 <strong>将每一个算法封装起来</strong> 每一个具体的算法称为：具体策略类</p>
<p>不知道这个解释大家清楚定义了没有，如果还不清楚，看类图</p>
<h1 id="类图演示"><a href="#类图演示" class="headerlink" title="类图演示"></a>类图演示</h1><p>策略模式包含的角色如下：</p>
<ul>
<li>Context: 环境类</li>
<li>Strategy: 抽象策略类</li>
<li>ConcreteStrategy: 具体策略类</li>
</ul>
<p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/Strategy.jpg" alt="image"></p>
<p>这下子是不是很清楚了？策略模式是使用非常广泛的一个设计模式。他很好的提现了：控制反转、依赖注入等思想。有同学说，不想看文字，有本事上代码呀！嗯，我喜欢，新鲜出炉的代码来了</p>
<h1 id="策略模式PHP代码实现"><a href="#策略模式PHP代码实现" class="headerlink" title="策略模式PHP代码实现"></a>策略模式PHP代码实现</h1><p>在整个模式中，Strategy 起着承上启下的作用。我就先来实现它</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ChargeStrategy</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，抽象策略类就完成了，他的主要目的就是规范一个必须要实现的方法，环境类依赖这个接口进行编程。</p>
<p>下面接着写算法的实现。还是以支付宝支付、微信支付为例。对于用户来说他要实现的功能是支付。那么支付又有多种选择(多种算法)。但是客户端不需要做出选择，他把这个权利让 环境类 去选择。这样子客户端就简单了。所有的算法需要实现 策略类接口。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝策略类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AliCharge</span> <span class="keyword">implements</span> <span class="title">ChargeStrategy</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 完成支付宝的相关逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信策略类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WxCharge</span> <span class="keyword">implements</span> <span class="title">ChargeStrategy</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 完成微信的相关逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里声明一下，这里为了纯粹的把 策略模式 讲明白，抛开了很多细枝末节，真正的支付中的实现，大家可以去看看<a href="https://github.com/helei112g/payment" target="_blank" rel="external">项目</a>的源代码。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ChargeContext</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@var</span> ChargeStrategy $charge</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> $charge;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">initInstance</span><span class="params">($channel)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($channel == <span class="string">'ali'</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;charge = <span class="keyword">new</span> AliCharge;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($chananel == <span class="string">'wx'</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;charge = <span class="keyword">new</span> WxCharge;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;charge = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_null(<span class="keyword">$this</span>-&gt;charge)) &#123;</span><br><span class="line">            <span class="keyword">exit</span>(<span class="string">'初始化错误'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">$this</span>-&gt;charge-&gt;charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就基本完成了，而对于客户端来说，就非常简单啦。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户选择的支付方式</span></span><br><span class="line">$channel = trim($_GET[<span class="string">'channel'</span>]);</span><br><span class="line"></span><br><span class="line">$context = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化支付实例</span></span><br><span class="line">$context-&gt;initInstance($channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用功能</span></span><br><span class="line">$context-&gt;charge();</span><br></pre></td></tr></table></figure>
<p>代码写完了，不知道大家有没有感受到好处，这个模式很好的实现了开闭原则。比如说：现在新增加了一个PayPal支付方式。那么只需要添加一个PayPal的策略算法。在ChargeContext中把对应的实例初始化加进去，其他地方都不需要动的。</p>
<h1 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h1><p>最后再说几句，不知道大家注意到没有，在 <code>ChargeContext</code> 这个类中，其实还使用了 <strong>简单工厂</strong> 这个模式。这里想给大家说明的是，其实设计模式只是一些编码的技巧，完全可以自由搭配组合，基本思想就是 <a href="http://blog.csdn.net/hel12he/article/details/51351763" target="_blank" rel="external">设计模式的六大原则</a> </p>
<p>当然，实际编码中也没有必要非要都实现这六大原则。这个也没有什么规范，只能大家多去实践，然后自己约定出一套适合业务的规范就好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[支付宝：即时到账接口接入]]></title>
      <url>http://dayutalk.cn/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%EF%BC%9A%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/</url>
      <content type="html"><![CDATA[<p>支付宝即时到账接口，简化支付宝本身文档一大堆的配置。让工作变得轻松<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p><strong>特别声明：</strong></p>
<blockquote>
<p>以下文档均针对 payment 2.0 以上版本，并且PHP需要5.5以上(含)。<br>代码中所有编码均使用 utf-8 。</p>
</blockquote>
<p>通过几天的时间，终于把payment 2.0的基本结构搭好了。今天刚完成支付宝 <strong>即时到帐</strong> 接口的开发。赶紧把使用文档给补上。请大家一定仔细查看文档，实在还不行就来问我吧！（我期待你问我，反正我收钱的，哈哈）</p>
<h1 id="即时到帐-接口签约"><a href="#即时到帐-接口签约" class="headerlink" title="即时到帐 接口签约"></a>即时到帐 接口签约</h1><p>在你使用这个接口时，请先确认你是否在支付宝商户中心签约了该接口。</p>
<p><img src="https://helei112g.github.io/images/trade-api.png" alt="image"></p>
<p>在商户中心，看到 <strong>即时到帐（已添加）</strong>，说明你已签约该接口，可正常使用。如果还不知道如何签约，请 <a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.FkBnFB&amp;treeId=62&amp;articleId=104749&amp;docType=1" target="_blank" rel="external">查看支付宝即时到帐签约教程</a></p>
<p>OK！完成签约后，</p>
<p>需要把 <a href="https://github.com/helei112g/payment/tree/paymentv2" target="_blank" rel="external">payment项目导入自己的项目中</a> 安装方法，请参考<a href="http://note.youdao.com/yws/public/redirect/share?id=5f8373d4cdfeb06dbcbe21b942efc53e&amp;type=false" target="_blank" rel="external">Payment项目简介</a>。</p>
<h1 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h1><p>在项目的 <code>examples</code> 文件夹中，我已提供完整的示例。为了便于大家理解，这里对代码再进行说明。</p>
<h2 id="支付宝的配置文件"><a href="#支付宝的配置文件" class="headerlink" title="支付宝的配置文件"></a>支付宝的配置文件</h2><p>在1.x版本中，配置文件被固定写在了sdk中，这种做法太流氓了。为了不继续流氓下去，在2.x版本中，将配置信息独立出来，让大家可以根据自己的实际情况自定义，灵活程度大大增加。</p>
<p>调用时，仅需要提供给我如下的一个数组，至于配置信息写在哪里，完全由你自己决定。</p>
<p>我在示例中，是将配置信息写在 <code>examples/aliconfig.php</code> 中，然后使用 <code>require_once</code> 包含进来。你完全可以写cache中、db中。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; <span class="string">'./rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>参数介绍</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>partner</td>
<td>合作者身份ID</td>
<td>签约的支付宝账号对应的支付宝唯一用户号。以2088开头的16位纯数字组成。</td>
<td>必须</td>
</tr>
<tr>
<td>md5_key</td>
<td>MD5密钥</td>
<td><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.qt91b7&amp;treeId=62&amp;articleId=104740&amp;docType=1#s1" target="_blank" rel="external">点击这里</a></td>
<td>必须</td>
</tr>
<tr>
<td>rsa_private_key</td>
<td>RSA私钥</td>
<td><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.qt91b7&amp;treeId=62&amp;articleId=104740&amp;docType=1#s0" target="_blank" rel="external">点击这里</a></td>
<td>必须</td>
</tr>
<tr>
<td>notify_url</td>
<td>服务器异步通知URI</td>
<td>支付宝服务器主动通知商户网站里指定的页面http路径。(建议使用https)</td>
<td>可选</td>
</tr>
<tr>
<td>return_url</td>
<td>页面跳转同步通知页面路径</td>
<td>支付宝处理完请求后，当前页面自动跳转到商户网站里指定页面的http路径。</td>
<td>可选</td>
</tr>
<tr>
<td>time_expire</td>
<td>超时时间</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。单位默认为分钟</td>
<td>可选</td>
</tr>
</tbody>
</table>
<p><strong>特别说明：</strong></p>
<ul>
<li>如果上述配置文件必须的key的值为空，会抛出 <code>PayException</code> 异常</li>
<li>如果 <code>notify_url</code> 为空，虽然可支付成功，但是客户端将无法收到支付宝的回调结果。</li>
<li>建议采用https协议</li>
</ul>
<h2 id="调用支付"><a href="#调用支付" class="headerlink" title="调用支付"></a>调用支付</h2><p>项目中的示例代码，参见 <code>examples/charge.php</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  生成订单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time())</span><br><span class="line">            .substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">            .rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单信息</span></span><br><span class="line">$orderData = [</span><br><span class="line">    <span class="string">"orderTradeNo"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"totalFee"</span>	=&gt; <span class="string">'1'</span>,</span><br><span class="line">    <span class="string">"clientIp"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'我是即时到帐'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付测试即时到帐接口'</span>,</span><br><span class="line">    <span class="string">"extraCommonParam"</span>	=&gt; <span class="string">''</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$aliconfig = <span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">'/aliconfig.php'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化支付环境类，进行支付创建</span></span><br><span class="line">$charge = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $charge-&gt;initCharge(Config::ALI_CHANNEL_WEB, $aliconfig);</span><br><span class="line">    $url = $charge-&gt;charge($payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求alipay</span></span><br><span class="line">header(<span class="string">"Location:&#123;$url&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码就完成了即时到帐的全部调用，下面分步骤来说明下代码含义：</p>
<h3 id="订单信息"><a href="#订单信息" class="headerlink" title="订单信息"></a>订单信息</h3><p>此部分的key部分，必须采用以下值，否则SDK无法识别。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createPayid(); 函数是为了演示方便，随手写的一个生成订单号的函数</span></span><br><span class="line"></span><br><span class="line">$orderData = [</span><br><span class="line">    <span class="string">"order_no"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"amount"</span>	=&gt; <span class="string">'1'</span>,<span class="comment">// 单位为元</span></span><br><span class="line">    <span class="string">"client_ip"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'测试支付'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付接口测试'</span>,</span><br><span class="line">    <span class="string">"extra_param"</span>	=&gt; <span class="string">''</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>order_no</td>
<td>订单号</td>
<td>平台根据规则生成的订单号，最长64位，要在商户数据库中唯一</td>
<td>必须</td>
</tr>
<tr>
<td>amount</td>
<td>交易总金额</td>
<td>该笔订单的资金总额，单位为RMB-Yuan。取值范围为[0.01，100000000.00]，精确到小数点后两位。</td>
<td>必须</td>
</tr>
<tr>
<td>client_ip</td>
<td>客户端IP</td>
<td>用户在创建交易时，该用户当前所使用机器的IP。</td>
<td>必须</td>
</tr>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>商品的标题/交易标题/订单标题/订单关键字等。该参数最长为128个汉字。</td>
<td>必须</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>对一笔交易的具体描述信息。如果是多种商品，请将商品描述字符串累加传给body。</td>
<td>必须</td>
</tr>
<tr>
<td>extra_param</td>
<td>公用回传参数</td>
<td>如果用户请求时传递了该参数，则返回给商户时会回传该参数。</td>
<td>可选</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="签名数据"><a href="#签名数据" class="headerlink" title="签名数据"></a>签名数据</h3><p>以下是真正实现数据签名的地方，返回的数据可直接用于发起支付宝支付。大家可以对比下支付宝自身信息，是不是已经大大简化了？<br>当然简化带来的另外一个意思就是：放弃了很多我们正常情况下用不到的功能，比如：花呗分期</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化支付环境类，进行支付创建</span></span><br><span class="line">$charge = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $charge-&gt;initCharge(Config::ALI_CHANNEL_WEB, $aliconfig);</span><br><span class="line">    $url = $charge-&gt;charge($payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对于调用者，仅仅需要知道 <code>ChargeContext</code> 这一个类，这里使用了 <strong>策略模式 + 简单工厂模式</strong> 两种方法来进行调用的简化。这种方式也非常方便后期进行扩展，对于客户端与复杂的逻辑进行了隔离。</p>
<h3 id="跳转支付宝"><a href="#跳转支付宝" class="headerlink" title="跳转支付宝"></a>跳转支付宝</h3><p>通过上一步返回的是请求支付宝的url。由于在页面上可能需要通过js调用支付宝或者还有其他逻辑，因为我并没有直接重定向到支付宝，而把控制权交到了客户端手中。</p>
<p>以下代码，示例的是简单的利用返回的url，重定向到支付宝，完成支付。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"Location:&#123;$url&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>本次支付宝的即时到帐接口到这里就完成了调用。下一节把回调通知部分完成，这样一个基本的支付流程就完成了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[支付宝、微信支付接入集成]]></title>
      <url>http://dayutalk.cn/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%E3%80%81%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E9%9B%86%E6%88%90/</url>
      <content type="html"><![CDATA[<p>没有摘要，请看正文<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>从开始写代码以来，一直就与支付打交道。终于到今天，我忍无可忍啦！每次都要重新写，重新调（主要换工作后，不能把前东家的代码给拷贝走）。好吧，写一份放到github上，以后啥时候用都有了，还方便做外包（哈哈哈……）</p>
<p>之前看了 ping++ 集成的各路支付接口，觉得挺爽的，但是要收费，而且公司也不放心，怕什么时候 ping++ 坚持不住了，那到时候怎么办？我倒是觉得可能大部分公司坚持不住了，ping++ 还在呢！ 因此不自量力的自己也来集成一个吧！</p>
<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p><strong>说明：</strong></p>
<ul>
<li>PHP 5.5 以上版本，包含5.5</li>
<li>采用PSR-4标准编码，可通过composer实现自动加载。</li>
<li>如果项目无法使用composer，请通过包含项目中的 <code>autoload.php</code> 来实现自动加载</li>
<li>客户端传入的参数均使用 <strong>下划线风格</strong></li>
</ul>
<h2 id="composer安装Payment"><a href="#composer安装Payment" class="headerlink" title="composer安装Payment"></a>composer安装Payment</h2><p>如果你励志要做php，强烈建议你学习下composer。</p>
<p><em>composer学习地址： <a href="http://www.phpcomposer.com/" target="_blank" rel="external">http://www.phpcomposer.com/</a></em></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装时请自行指定版本。否则将安装稳定版，当前稳定版是1.x</span></span><br><span class="line">composer <span class="keyword">require</span> riverslei/payment</span><br></pre></td></tr></table></figure>
<p>通过composer安装后，无需任何操作，可在项目中直接使用。</p>
<h2 id="直接下载"><a href="#直接下载" class="headerlink" title="直接下载"></a>直接下载</h2><p>当然如果由于历史原因（如果没有历史原因，强烈推荐composer安装，方便后续更新），无法通过composer安装，那么请自行下载（下载地址见下方 功能介绍），并在使用时，包含 <code>autoload.php</code> 文件。这种方式就不过多介绍了。</p>
<h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>说这么多废话没什么卵用，还是先介绍下本SDK支持的支付接口</p>
<ol>
<li>支付宝支付<ul>
<li><a href="https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%EF%BC%9A%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/" target="_blank" rel="external">支付宝即时到帐</a></li>
<li><a href="https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/" target="_blank" rel="external">支付宝异步通知回调</a></li>
<li><a href="https://helei112g.github.io/2016/07/29/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E3%80%81%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/" target="_blank" rel="external">支付宝手机网站</a></li>
<li><a href="https://helei112g.github.io/2016/07/29/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E3%80%81%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/" target="_blank" rel="external">支付宝移动支付</a></li>
<li><a href="https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/" target="_blank" rel="external">支付宝有密退款</a></li>
<li><a href="https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E6%89%B9%E9%87%8F%E8%BD%AC%E6%AC%BE%E6%8E%A5%E5%8F%A3/" target="_blank" rel="external">支付宝有密批量付款</a></li>
<li><a href="https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E5%8D%95%E7%AC%94%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3/" target="_blank" rel="external">支付宝订单查询</a></li>
</ul>
</li>
</ol>
<ol>
<li>微信支付    <ul>
<li><a href="https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%94%AF%E4%BB%98%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%85%A5%EF%BC%9AAPP%E6%94%AF%E4%BB%98%E3%80%81%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%E3%80%81%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/" target="_blank" rel="external">微信公众号支付\微信扫码支付\APP支付 接口</a></li>
<li><a href="https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E8%AE%A2%E5%8D%95%E3%80%81%E9%80%80%E6%AC%BE%E8%AE%A2%E5%8D%95%E3%80%81%E8%BD%AC%E6%AC%BE%E8%AE%A2%E5%8D%95%E7%9A%84%E6%9F%A5%E8%AF%A2/" target="_blank" rel="external">订单查询接口/退款订单查询接口/企业付款查询接口</a></li>
<li><a href="https://helei112g.github.io/2016/08/16/PHP%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/" target="_blank" rel="external">微信退款接口</a></li>
<li><a href="https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/" target="_blank" rel="external">微信异步通知回调接口</a></li>
<li><a href="https://helei112g.github.io/2016/08/16/PHP%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E4%BB%98%E6%AC%BE%E5%8A%9F%E8%83%BD/" target="_blank" rel="external">企业付款接口</a></li>
</ul>
</li>
</ol>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 2.x版本</a></p>
<p>当然有很多朋友问我支不支持paypal 银联等等。我也想呀，可惜这个得慢慢来。我这基础功能还搞完呢！哈哈，当然也欢迎大家push代码给我</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[APP后端开发系列：登陆系统设计中的注意问题]]></title>
      <url>http://dayutalk.cn/2016/07/12/APP%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%9A%E7%99%BB%E9%99%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>自从接触到app开发以来，遇到很多问题，一直都是一路走，一路解决。希望这些文字能够让大家少走些弯路。<br><a id="more"></a></p>
<p>想写这个系列很久了，因为之前做这个东西花费了大量的精力，有必要分享出来与大家共享。以前也写了一些关于 <a href="http://blog.csdn.net/hel12he/article/details/47721209" target="_blank" rel="external">APP后端开发的系列文章</a> 由于当初功力不够，很多问题描述不清楚或者解决方案过于复杂、不严谨等。</p>
<p>这一次查了很多资料，问了很多相关人士。准备再结合自己实际工作中的问题再次进行一些补充。就先从登陆的设计开始吧！</p>
<h1 id="越想越糊涂"><a href="#越想越糊涂" class="headerlink" title="越想越糊涂"></a>越想越糊涂</h1><p>之前再做这一部分的时候，总想着复杂的技术，说出去多调炸天呀。一般来说登陆的流程是：</p>
<p><img src="https://helei112g.github.io/images/login-flow.png" alt="image"></p>
<p>当时对于安全性过度痴迷，确走偏了道路。首先提交的时候爬信息被人劫持，因此客户端在上传时，进行AES加密，服务端解密出结果。服务端返回的信息也会AES加密，然后客户端解密。</p>
<p>然后这里又带来另外一个问题：加密信息放在了客户端，那么一但客户端被反编译，hacker拿到秘钥，那么对于服务端来说加密就没有任何意义了。又为了不在客户端保存这么敏感的信息，就像秘钥由服务端下发。这样子服务端可随时对秘钥进行变更。</p>
<p>到这里又带来了一个新的问题，感脚一切又回到了起点：下发秘钥要走http，那么依然可能被人劫持。这时候该是加密还是怎么弄呢？如果加密，客户端又放了一个秘钥过去。那这个秘钥依然可能被人反编译。不能再从服务端获取这个秘钥吧？为了确保上个秘钥的安全，生产下一个秘钥……</p>
<p>当时就是陷入了这样的死循环，不可自拔。现在想想真是too young too simple!</p>
<h1 id="简单、有效"><a href="#简单、有效" class="headerlink" title="简单、有效"></a>简单、有效</h1><p>首先在这里还是先说一下：如果你的产品刚刚起步，不要过于纠结性能、安全</p>
<p>先说性能：你的产品才推出的时候，冷启动的用户数一般来说不会超过1000人（这已经是很不得了的冷启动人数了）。然后你的并发也不会超过100。这种级别的访问，相信机器硬件就可以帮助你解决。如果你的条件远远超出以上规模，那么你的实力绝对足以应付即将发生的事情。<br>谈谈安全：安全这个事情，从一开始就要考虑，但是不能过于纠结（我之后可以讲讲我在做短信验证码这一部分的遇到的一个经理）。过早介入，会导致系统开发速度降低，过早做了一些不需要的事情（hacker来搞你也是需要成本的，在你没价值的时候，没人愿意来搞你）。所以早期应该重视开发成本，抓紧时间，早日上线。</p>
<p>另外，安全与性能有时候也是鱼与熊掌。</p>
<h1 id="演化之路"><a href="#演化之路" class="headerlink" title="演化之路"></a>演化之路</h1><p>这一部分会有一些代码与图来进行说明。在安全方面逐步演进。前面说前期开发只要快就好，但是这里也要注意一个问题，就是后续升级能够弥补前面的错，要给未来升级留下余地。因为否则你的系统始终留下了一个隐患。</p>
<h2 id="实现功能就好"><a href="#实现功能就好" class="headerlink" title="实现功能就好"></a>实现功能就好</h2><p>这是最开始的阶段，重点考虑功能实现。用户提交username + pwd 服务端验证通过后，返回一个令牌token。</p>
<p>这里需要注意的几个部分是要为未来的升级做好准备。我经常遇到的几个初期设计是：</p>
<blockquote>
<ol>
<li>验证通过后，把用户uid+username+salt等md5后，作为token返回到客户端。</li>
<li>对token加入时间戳，过期后客户端重新提交username + pwd验证后再发一个token到客户端</li>
<li>服务端生成一个token后下发到客户端，客户端按照约定的规则加密后请求服务端。</li>
</ol>
</blockquote>
<p>先说第一种带来的问题：生成的token永久不变，那么别人获取到一个token就可以无限制的进行请求。直到你关闭了这个接口为止。为后续安全设计增加了成本。</p>
<p>第二种问题就有点老火了，虽然看似token只在一定时间范围内有效了，但是其实更不安全了。首先客户端需要保存用户的用户名与密码，如果用户手机平时不注重安全，很容易被人窃取。</p>
<p>第三种设计方案，这是我原先干过的一件事，是这三种方案中最垃圾的设计。得出的教训就是：绝不能把任何加密的事情交给客户端。这样子灵活性大打折扣。举例：还是升级接口了，现在本来token生成只是服务端的事情，服务端随时可动态改变规则，现在由于客户端也参与进来了，这事儿就麻烦了，你一改，客户端也要跟着改。没有任何灵活性可言。切记：客户端就接收，然后转发回服务端就好了。别再客户端进行加密！！！</p>
<p>经过这些坑的历练，参考oauth2.0，我现在采用以下方案：</p>
<p>用户提交username + pwd后，服务端返回以下信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">    <span class="attr">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>access_token</strong> 是用来进行访问的接口的，<strong>expires_in</strong> 是他的过期时间，到达过期时间后，需要用 <strong>refresh_token</strong>  来请求服务端刷新 <strong>access_token</strong>。</p>
<p>这里几个重点是：<strong>refresh_token</strong> 仅能使用一次，使用一次后，将被废弃。另外这个 <strong>access_token</strong> 只在 <strong>expires_in</strong> 有效期内有效。</p>
<p><strong>注意：</strong> 这里的 expires_in 仅返回秒数就好了。别返回时间戳。因为各个平台计算s的时间戳，不一致，这样子做更方便处理。</p>
<h2 id="访问频率控制"><a href="#访问频率控制" class="headerlink" title="访问频率控制"></a>访问频率控制</h2><p>上面我们简单实现了功能，现在app的流量上来了，有些功能也很复杂，如果某个接口访问量太大，会导致服务器崩溃，需要分别对每个接口每次访问设置频率（也可以统一设置每个接口访问的频率）。</p>
<p>一般我的做法是加入一个中间件。每一个接口的访问频率做好一个对应的配置文件。比如：</p>
<ul>
<li>a接口 5s内可访问1次</li>
<li>b接口 10s内可访问1次（可能非常耗时，如果同时过多请求会导致服务器崩溃）</li>
</ul>
<p>那么就把 <strong>access_token</strong> 与这些关联起来。这里需要用到redis。当用户A进来访问了 a接口 那么设置这个token 5s内不能再次访问。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($redis-&gt;get($key)) &#123;</span><br><span class="line">    <span class="comment">// 无法访问，还未到时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置频率控制key</span></span><br><span class="line">$redis-&gt;setex($key, $expires, $value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问接口</span></span><br></pre></td></tr></table></figure>
<p>这里需要考虑几个问题：</p>
<p>设置的访问时间要合理。举例：客户端一般启动的时候会请求多个接口，那么当这些请求到达后，服务端可能拒绝其中一部分访问（因为在频率控制内）</p>
<p>一般来说不需要对所有的接口都进行频率控制，仅仅针对重要的内容以及性能上有要求的接口进行频率控制。</p>
<h2 id="账号安全考虑"><a href="#账号安全考虑" class="headerlink" title="账号安全考虑"></a>账号安全考虑</h2><p>现在又进一步了，需要考虑用户账号安全的问题。比如：QQ，有时候会提醒我们你的账号在香港登陆了。如果不是自己所为，赶快修改密码之类的。</p>
<p>实现这个功能，你需要记录每次登陆、启动时每个token对应的ip地址。如果ip地址与上次的ip不在同一个范围（这个规则由自己定，因为有的运营商ip经常变化，比如：长城）。就提醒用户是不是他自己所为，如果不是，就赶快修改密码。</p>
<p>现在很多app在开发之初，都是可以多个设备同时登陆。这样带来的安全问题也很多。如果要做成单个设备登陆，需要每个token对应一个deviceToken。</p>
<p>这一部分就不继续深入讨论下去了。</p>
<h2 id="防DNS劫持"><a href="#防DNS劫持" class="headerlink" title="防DNS劫持"></a>防DNS劫持</h2><p>安全工作做得再好，如果有人能够获得大量合法用户的token，来请求你的借口，你也无法识别，因为从行为来看，这一切都是合法用户再进行。</p>
<p>以前为了防止别人获取到合法的信息，我才弄出了很狗血的客户端加密方法。导致后期升级的时候，诸多问题。这个东西其实很简单，使用https来进行请求（可以个人关键接口使用）</p>
<h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><p>才开始做app服务端的时候，总想着token的设计。怎么才能生成一个好的token呢？现在想想真不知道当初怎么想的。</p>
<h2 id="token的生成"><a href="#token的生成" class="headerlink" title="token的生成"></a>token的生成</h2><p>首先搞明白这个token的作用就是一个令牌，用来标记一个用户的身份。那么首先他要唯一。其次他从客户端上传后，服务端能够验证这个token是由服务端生成的。</p>
<p>所以token生成只要满足以上目的，你随意就好了。当然别把敏感信息暴露出去了。</p>
<p>常用的一种生成方式：</p>
<ol>
<li>该用户的uid，如：8888</li>
<li>该用户的口令，如： 123123</li>
<li>用户对应的salt，如：abcd</li>
<li>过期时间戳，如：1468293948</li>
</ol>
<p>把上面几部分拼接起来：888:123123:abcd:1468293948</p>
<p>token = md5(‘888:123123:abcd:1468293948’);</p>
<h2 id="token的验证"><a href="#token的验证" class="headerlink" title="token的验证"></a>token的验证</h2><p>对于token也有两种方法进行验证。一是：服务端生成后，将token保存起来（redis或者mysql中）。客户端穿上来之后，检查是否有该token，如果有取出对应的信息，比如uid，验证是否匹配。</p>
<p>另一种方法是：根据上传的uid，生成对应的token，然后进行比较token结果是否一致（要保障该算法如果给定的值一定，结果必须唯一。常用md5）。</p>
<p>对于个人而言更倾向于第二种方案。第一种方案效率更高（可使用redis存储这个token），但是如果redis一但雪崩，就会造成所有用户登录失效，一定时间内不可登陆。初期越简单、越可靠更好。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一部分没有太多代码，主要是思路。还有涉及到H5的登陆问题也没有说到。下篇文章会把APP中登陆后，如果搞定H5登陆的问题进行阐述。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[php设计模式：状态模式的使用场景]]></title>
      <url>http://dayutalk.cn/2016/06/28/php%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<p>最初为了减少代码中的逻辑判断，使用了该模式，不过大家在实际中还是需要权衡，太多的类未必就比if{…}else{…}更好。</p>
<a id="more"></a>
<p>在这儿给大家说点事儿。我的博客搬家到github主页上了。<a href="https://helei112g.github.io" target="_blank" rel="external">我的博客</a>。以后首发都在github上了。csdn也会继续更新。可能就是稍微慢一下。</p>
<p>另外最近搞了一个支付的开源项目。<a href="https://github.com/helei112g/payment" target="_blank" rel="external">这是项目地址</a>  目前已经支持：</p>
<ul>
<li>支付宝的 即时到帐、移动支付、加密退款接口。</li>
<li>微信的目前已经支持：app支付、扫码支付、H5支付</li>
</ul>
<p>项目还存在些bug，正在不断结合公司业务进行修改。后期可能会支持的越来越全面。</p>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>废话不多说了，回到本文主题： 状态模式</p>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
</blockquote>
<p>说实话，这定义真JB不是怎么读的懂。不过咱要试着去理解其中的精髓。谁让咱们有颗向上的心呢？</p>
<p>一句句来。</p>
<p>先说这一句： <strong>允许一个对象在其内部状态改变时改变它的行为</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($state)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;state = $state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">change</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;state == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'我是好人'</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="keyword">$this</span>-&gt;state == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'我要当坏人'</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 其他状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'爱好和平!'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下我要开始自己的理解了，这个理解不一定是上面定义的本意，但是绝对讲人话，有帮助，可实战。</p>
<p>如果 <code>state</code> 传入的值不同，则会得到不同的行为。那么这就是我理解的这一句话的意思。再说白话一点，根据不同的条件，执行不同的逻辑。</p>
<p><strong>对象看起来似乎修改了它的类</strong>  这一句更扯淡，真不知道这些人怎么想的，就不能说的通俗些？我觉得嘛，这个概念能懂就懂，不懂呢，你就这么办：那就是对于每一个条件中的逻辑，移入到不同的类中，这些类要实现一个统一的接口。还不懂？上代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface State()</span><br><span class="line">&#123;</span><br><span class="line">    // 注意这里的Context 我在后面会讲到。不等同于上面的 Context 类哦</span><br><span class="line">    public function handle(Context $context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 状态A</span><br><span class="line">class StateA implements State</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($context-&gt;term = 1) &#123;</span><br><span class="line">            // 处理逻辑，并终止程序</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $context.setState(new StateB());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 状态B</span><br><span class="line">class StateB implements State</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($context-&gt;term = 2) &#123;</span><br><span class="line">            // 处理逻辑，并终止程序</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $context.setState(new StateC());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 状态C</span><br><span class="line">class StateC implements State</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果还有其他状态，则继续往下走。如果没有，就在次终止程序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 新的Context类的实现</span><br><span class="line">class Context</span><br><span class="line">&#123;</span><br><span class="line">    private $state;// 用来保存 State 对象</span><br><span class="line">    </span><br><span class="line">    public function setState(State $state)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;state = $state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function request()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;state-&gt;handle($this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码基本上就已经演示了 <strong>状态模式</strong> 。有看官急了，写的什么狗屎？怎么用，哪儿可以用？别急，等我把这个逼装完。</p>
<h2 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h2><p>继续装逼，上类图。</p>
<p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/State.jpg" alt="类图"></p>
<p>从这个图中可以看出，纯种的状态模式，包括了以下三个角色：</p>
<ul>
<li>Context: 环境类。它呢需要在代码中传给具体的 State 类，这样State类才能改变它。记得这句 <strong>对象看起来似乎修改了它的类</strong> 吗？就着这句话再去理解下这个类。他保存有当前的状态。</li>
<li>State: 抽象的状态接口 。让具体的状态都要实现这个接口，Context依赖接口进行编程。</li>
<li>ConcreteState： 具体的状态类。专门用于处理某一个状态，如果处理不了就转发出去。</li>
</ul>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>上面讲那么多，不能真刀真枪的用到项目中，都是耍流氓。在我们的项目中其实有特别多的地方可以用到状态模式。</p>
<ul>
<li>如果项目中存在太多的 <code>if {...} elseif {...} else {...}</code> 。那么你应该考虑状态模式。<em>我觉得这个是重点考虑对象</em></li>
<li>如果每个状态中处理的业务逻辑特别复杂·那么建议考虑这种方式。</li>
<li>最后一点，如果代码中的状态相对固定。比如一个电商中购买商品的流程：未支付、已过期、待发货（已支付）、已发货、已收货。那么这种状态基本上定下来不会有太大变化，状态发生在内部中，顺序固定，不需要客户端进行处理。</li>
</ul>
<p>以上三种情况是我建议的方式。如果大家还有总结的经验，欢迎分享。</p>
<p>这里有个问题，待我写完 <strong>职责链模式</strong> 之后再来分享。因为这二者有相当多的共同之处。大家一定认真阅读我写的 <strong>使用场景</strong> 的最后一点。</p>
]]></content>
    </entry>
    
  
  
</search>
